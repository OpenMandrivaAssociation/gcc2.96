2000-11-27  Jim Wilson  <wilson@redhat.com>

	* reload1.c (reload): Use HOST_WIDE_INT for old_frame_size.

2000-09-19  Richard Henderson  <rth@cygnus.com>

	* unroll.c (copy_loop_body): Update LABEL_NUSES before
	calling invert_jump.

2000-12-12  Jim Wilson  <wilson@redhat.com>

	* rtlanal.c (may_trap_p): Check operand modes of LE, LT, GE, and GT.

2000-12-14  Jim Wilson  <wilson@redhat.com>

	* alias.c (get_alias_set): Call record_component_aliases for
	COMPLEX_TYPE.
	(record_component_aliases): Handle COMPLEX_TYPE.
	
2001-01-08  Jim Wilson  <wilson@redhat.com>

	* haifa-sched.c (BITSET_ADD, BITSET_REMOVE, bitset_member): Cast
	1 to unsigned HOST_WIDE_INT before left shift.

2000-10-26  Nathan Sidwell  <nathan@codesourcery.com>

	* tree.c (make_node, case 't'): Set alignment to that of
	char_type_node.

--- gcc/config/sparc/sparc.h.jj	Sat Feb  3 23:48:02 2001
+++ gcc/config/sparc/sparc.h	Mon Feb  5 14:56:13 2001
@@ -1727,6 +1727,13 @@ extern char leaf_reg_remap[];
 #define OUTGOING_REGNO(IN) \
  ((TARGET_FLAT || (IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)
 
+/* Define this macro if the target machine has register windows.  This
+   C expression returns true if the register is call-saved but is in the
+   register window.  */
+
+#define LOCAL_REGNO(REGNO) \
+  (TARGET_FLAT ? 0 : (REGNO) >= 16 && (REGNO) <= 31)
+
 /* Define how to find the value returned by a function.
    VALTYPE is the data type of the value (as a tree).
    If the precise function being called is known, FUNC is its FUNCTION_DECL;
--- gcc/config/ia64/crtbegin.asm.jj	Mon Jul 31 20:02:15 2000
+++ gcc/config/ia64/crtbegin.asm	Mon Feb  5 14:56:13 2001
@@ -54,9 +54,7 @@ __dso_handle:
 __dso_handle:
 	data8	0
 #endif
-#ifdef HAVE_GAS_HIDDEN
 	.hidden __dso_handle#
-#endif
 
 	/* The frame object.  */
 	/* ??? How can we rationally keep this size correct?  */
--- gcc/config/ia64/frame-ia64.c.jj	Wed Jun  7 08:41:10 2000
+++ gcc/config/ia64/frame-ia64.c	Mon Feb  5 14:56:13 2001
@@ -678,7 +678,7 @@ read_P_record (data, val, ptr, header)
 /* Frame processing routines.  */
 
 /* Initialize a single register structure.  */
-static void 
+static inline void 
 init_ia64_reg_loc (reg, size)
      ia64_reg_loc *reg;
      short size;
@@ -692,7 +692,7 @@ init_ia64_reg_loc (reg, size)
 /* Iniitialize an entire frame to the default of nothing.  */
 static void
 init_ia64_unwind_frame (frame) 
-     ia64_frame_state *frame ;
+     ia64_frame_state *frame;
 {
   int x;
   
@@ -741,7 +741,7 @@ execute_one_ia64_descriptor (addr, frame
   *len = -1;
   addr = get_unwind_record (&region_header, &r, addr);
 
-  /* process it in 2 phases, the first phase will either do the work,
+  /* Process it in 2 phases, the first phase will either do the work,
      or set up a pointer to the records we care about 
      (ie a special purpose ar perhaps, and the second will actually 
      fill in the record.  */
@@ -787,10 +787,12 @@ execute_one_ia64_descriptor (addr, frame
 	  break;
 	}
       case mem_stack_f:
-      case mem_stack_v:
-        frame->sp.when = r.record.p.t; 
 	frame->sp.l.offset = r.record.p.size;
 	frame->sp.loc_type = IA64_UNW_LOC_TYPE_OFFSET;
+        frame->sp.when = r.record.p.t; 
+	break;
+      case mem_stack_v:
+	frame->psp.when = r.record.p.t;
 	break;
       case psp_gr:
       case psp_sprel:
@@ -1091,7 +1093,7 @@ normalize_reg_loc (frame, reg)
       case IA64_UNW_LOC_TYPE_BR:
         break;
       case IA64_UNW_LOC_TYPE_SPOFF:
-        /* offset from the stack pointer, calculate the memory address
+        /* Offset from the stack pointer, calculate the memory address
 	   now.  */
 	tmp = (unsigned char *)frame->my_sp + reg->l.offset * 4;
 	reg->l.mem = tmp;
@@ -1100,7 +1102,7 @@ normalize_reg_loc (frame, reg)
       case IA64_UNW_LOC_TYPE_PSPOFF:
         /* Actualy go get the value of the PSP add the offset, and thats 
 	   the mem location we can find this value at. */
-	tmp = (*(unsigned char **)(frame->psp.l.mem)) + 16 - reg->l.offset * 4;
+	tmp = (unsigned char *)frame->my_psp + 16 - reg->l.offset * 4;
 	reg->l.mem = tmp;
 	reg->loc_type = IA64_UNW_LOC_TYPE_MEM;
         break;
@@ -1114,7 +1116,8 @@ normalize_reg_loc (frame, reg)
     }
 
 }
-/* this function looks at a reg_loc and determines if its going
+
+/* This function looks at a reg_loc and determines if its going
    to be an executed record or not between time start and end.  
    It is executed if it is exectued at START time. It is NOT
    executed if it happens at END time. */
@@ -1173,7 +1176,7 @@ copy_reg_value (src, dest)
   else
     {
       void **d;
-      if (src->reg_size> 16)
+      if (src->reg_size > 16)
         abort ();
       if (dest->loc_type != IA64_UNW_LOC_TYPE_MEM)
         abort ();
@@ -1218,7 +1221,9 @@ process_state_between (frame, start, end
   /* PSP, RP, SP, and PFS are handled seperately from here. */
 
   /* GR's, FR's and BR's are saved at an arbitrary point, so we
-      should handle them at teh very beginning.  */
+     should handle them at the very beginning.  */
+  /* ??? Err, no they aren't.  There's the spill_mask record that
+     tells us when each is processed.  */
   if (start == 0)
     {
       for (x = 0; x < 4 ; x++)
@@ -1252,25 +1257,52 @@ frame_translate (frame, unwind_time)
      ia64_frame_state *frame;
      long unwind_time;
 {
-  /* First, establish values of PFS and PSP and RP, if needed.  */
-
-  normalize_reg_loc (frame, &frame->pfs);
-  normalize_reg_loc (frame, &frame->psp);
-  normalize_reg_loc (frame, &frame->rp);
- 
+  /* ??? Is this supposed to mark the end of the stack?  */
   if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE)
     return;
 
-  /* The stack pointer at the function start is the PSP value
-     saved away.  */
-  frame->my_sp = __get_real_reg_value (&frame->psp);
+  /* At function entry, SP == PSP.  */
+  frame->my_psp = frame->my_sp;
+  if (frame->psp.loc_type != IA64_UNW_LOC_TYPE_NONE)
+    {
+      /* We've saved a frame pointer somewhere.  This will be the
+	 canonical PSP for the function.  */
+      normalize_reg_loc (frame, &frame->psp);
+      if (frame->psp.when < unwind_time)
+	frame->my_psp = __get_real_reg_value (&frame->psp);
+    }
+  else if (frame->sp.loc_type == IA64_UNW_LOC_TYPE_OFFSET)
+    {
+      /* We've a fixed sized stack frame.  The PSP is at a known offset.  */
+	
+      if (frame->sp.when < unwind_time)
+        frame->my_psp = frame->my_sp + frame->sp.l.offset;
+    }
+  /* Otherwise the stack frame size was zero and no adjustment needed.  */
 
-  if (frame->psp.loc_type != IA64_UNW_LOC_TYPE_MEM)
-    abort ();
+  /* Find PFS, RP and the spill base.  All of which might have
+     addresses based off the PSP computed above.  */
+  normalize_reg_loc (frame, &frame->pfs);
+  normalize_reg_loc (frame, &frame->rp);
 
-  /* spill base is set up off the PSP register, which should now 
-     have its value. */
-  normalize_reg_loc (frame, &frame->spill_base);
+  if (frame->spill_base.loc_type != IA64_UNW_LOC_TYPE_NONE)
+    normalize_reg_loc (frame, &frame->spill_base);
+  else
+    {
+      /* Otherwise we're supposed to infer it from the size of the
+	 saved GR/BR/FR registers, putting the top at psp+16.  */
+      long size = 0, i;
+      for (i = 0; i < 4; ++i)
+	if (frame->gr[i].when >= 0)
+	  size += 8;
+      for (i = 0; i < 5; ++i)
+	if (frame->br[i].when >= 0)
+	  size += 8;
+      for (i = 0; i < 20; ++i)
+	if (frame->fr[i].when >= 0)
+	  size += 16;
+      frame->spill_base.l.mem = frame->my_psp + 16 - size;
+    }
 
   /* If the SP is adjusted, process records up to where it
      is adjusted, then adjust it, then process the rest.  */
@@ -1279,24 +1311,23 @@ frame_translate (frame, unwind_time)
       process_state_between (frame, 0, frame->sp.when);
       if (frame->sp.loc_type != IA64_UNW_LOC_TYPE_OFFSET)
 	abort ();
-      frame->my_sp = 
-	      (unsigned char *)frame->my_sp - frame->sp.l.offset;
+      frame->my_sp = frame->my_psp - frame->sp.l.offset;
       process_state_between (frame, frame->sp.when, unwind_time);
     }
   else
     process_state_between (frame, 0, unwind_time);
 }
 
-/* this function will set a frame_state with all the required fields
+/* This function will set a frame_state with all the required fields
    from a functions unwind descriptors.
    pc is the location we need info up until (ie, the unwind point)
    frame is the frame_state structure to be set up.
    Returns a pointer to the unwind info pointer for the frame.  */
 unwind_info_ptr *
-__build_ia64_frame_state (pc, frame, bsp, pc_base_ptr)
+__build_ia64_frame_state (pc, frame, bsp, sp, pc_base_ptr)
      unsigned char *pc;
      ia64_frame_state *frame;
-     void *bsp;
+     void *bsp, *sp;
      void **pc_base_ptr;
 {
   long len;
@@ -1321,8 +1352,9 @@ __build_ia64_frame_state (pc, frame, bsp
 
   init_ia64_unwind_frame (frame);
   frame->my_bsp = bsp;
+  frame->my_sp = sp;
 
-  /* stop when we get to the end of the descriptor list, or if we
+  /* Stop when we get to the end of the descriptor list, or if we
      encounter a region whose initial offset is already past the
      PC we are unwinding too.  */
 
@@ -1336,6 +1368,7 @@ __build_ia64_frame_state (pc, frame, bsp
 	  last_region_size = len;
 	}
     }
+
   /* Now we go get the actual values.  */
   frame_translate (frame, pc_offset);
   if (pc_base_ptr)
@@ -1343,27 +1376,38 @@ __build_ia64_frame_state (pc, frame, bsp
   return unw_info_ptr;
 }
 
-/* Given an unwind info pointer, return the personailty routine.  */
+/* Given an unwind info pointer, return the personality routine.  */
 void *
 __get_personality (ptr)
      unwind_info_ptr *ptr;
 {
   void **p;
+
+  /* There is a personality routine only if one of the EHANDLER or UHANDLER
+     bits is set.  */
+  if (! (IA64_UNW_HDR_FLAGS (ptr->header)
+	 & (IA64_UNW_EHANDLER|IA64_UNW_UHANDLER)))
+    return 0;
+
   p = (void **) (ptr->unwind_descriptors
 		 + IA64_UNW_HDR_LENGTH (ptr->header) * 8);
   return *p;
 }
 
+/* Given an unwind info pointer, return the exception table.  */
 void *
 __get_except_table (ptr)
      unwind_info_ptr *ptr;
 {
-  void **p, *table;
-  p = (void **) (ptr->unwind_descriptors
-		 + IA64_UNW_HDR_LENGTH (ptr->header) * 8);
-  /* If there is no personality, there is no handler data.  */
-  if (*p == 0)
+  void *table;
+
+  /* If there is no personality, there is no handler data.
+     There is a personality routine only if one of the EHANDLER or UHANDLER
+     bits is set.  */
+  if (! (IA64_UNW_HDR_FLAGS (ptr->header)
+	 & (IA64_UNW_EHANDLER|IA64_UNW_UHANDLER)))
     return 0;
+
   table = (void *) (ptr->unwind_descriptors
 		    + IA64_UNW_HDR_LENGTH (ptr->header) * 8 + 8);
   return table;
@@ -1385,10 +1429,10 @@ __calc_caller_bsp (pfs, bsp)
 }
 
 static int 
-ia64_backtrace_helper (void **array, void *throw_pc, 
-		       ia64_frame_state *throw_frame,
-		       ia64_frame_state *frame, void *bsp, int size)
+ia64_backtrace_helper (void **array, ia64_frame_state *throw_frame,
+		       ia64_frame_state *frame, void *bsp, void *sp, int size)
 {
+  void *throw_pc = __builtin_return_address (0);
   void *pc = NULL;
   int frame_count = 0;
   unwind_info_ptr *info;
@@ -1396,7 +1440,7 @@ ia64_backtrace_helper (void **array, voi
   __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */
 
   /* Start at our stack frame, get our state.  */
-  info = __build_ia64_frame_state (throw_pc, throw_frame, bsp, NULL);
+  info = __build_ia64_frame_state (throw_pc, throw_frame, bsp, sp, NULL);
 
   *frame = *throw_frame;
 
@@ -1406,7 +1450,7 @@ ia64_backtrace_helper (void **array, voi
       --pc;
       bsp = __calc_caller_bsp 
 	((long)__get_real_reg_value (&frame->pfs), frame->my_bsp);
-      info = __build_ia64_frame_state (pc, frame, bsp, NULL);
+      info = __build_ia64_frame_state (pc, frame, bsp, frame->my_psp, NULL);
       if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE) /* We've finished. */
 	break;
     }
@@ -1419,6 +1463,7 @@ ia64_backtrace_helper (void **array, voi
 int
 __ia64_backtrace (void **array, int size)
 {
+  register void *stack_pointer __asm__("r12");
   ia64_frame_state my_frame;
   ia64_frame_state originator;	/* For the context handler is in.  */
   void *bsp;
@@ -1428,11 +1473,10 @@ __ia64_backtrace (void **array, int size
      registers. */
   __builtin_unwind_init ();
 
-label_ia64:
   bsp = __builtin_ia64_bsp ();
   
-  return ia64_backtrace_helper (array, &&label_ia64, &my_frame, 
-				&originator, bsp, size);
+  return ia64_backtrace_helper (array, &my_frame, &originator, bsp,
+				stack_pointer, size);
 }
 
 
@@ -1482,9 +1526,11 @@ print_record (f, ptr)
 						 ptr->record.r.grsave);
 	break;
       case mem_stack_f:
-      case mem_stack_v:
 	fprintf (f, "(P7) t = %d, size = %d", ptr->record.p.t, 
 					 ptr->record.p.size);
+	break;
+      case mem_stack_v:
+	fprintf (f, "(P7) t = %d", ptr->record.p.t);
 	break;
       case psp_gr:
       case rp_gr:
--- gcc/config/ia64/ia64-protos.h.jj	Mon Jul 31 20:02:15 2000
+++ gcc/config/ia64/ia64-protos.h	Thu Aug 31 04:34:39 2000
@@ -34,41 +34,53 @@ extern int symbolic_operand PARAMS((rtx,
 extern int function_operand PARAMS((rtx, enum machine_mode));
 extern int setjmp_operand PARAMS((rtx, enum machine_mode));
 extern int move_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_0_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_6bit_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_8bit_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_8bit_adjusted_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_8bit_and_adjusted_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_14bit_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_22bit_operand PARAMS((rtx, enum machine_mode));
+extern int gr_register_operand PARAMS((rtx, enum machine_mode));
+extern int fr_register_operand PARAMS((rtx, enum machine_mode));
+extern int grfr_register_operand PARAMS((rtx, enum machine_mode));
+extern int gr_nonimmediate_operand PARAMS((rtx, enum machine_mode));
+extern int grfr_nonimmediate_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_0_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_5bit_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_6bit_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_8bit_operand PARAMS((rtx, enum machine_mode));
+extern int grfr_reg_or_8bit_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_8bit_adjusted_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_8bit_and_adjusted_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_14bit_operand PARAMS((rtx, enum machine_mode));
+extern int gr_reg_or_22bit_operand PARAMS((rtx, enum machine_mode));
 extern int shift_count_operand PARAMS((rtx, enum machine_mode));
 extern int shift_32bit_count_operand PARAMS((rtx, enum machine_mode));
 extern int shladd_operand PARAMS((rtx, enum machine_mode));
 extern int fetchadd_operand PARAMS((rtx, enum machine_mode));
-extern int reg_or_fp01_operand PARAMS((rtx, enum machine_mode));
+extern int fr_reg_or_fp01_operand PARAMS((rtx, enum machine_mode));
 extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));
 extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));
 extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));
 extern int destination_operand PARAMS((rtx, enum machine_mode));
-extern int ia64_rap_fp_offset PARAMS((void));
-extern unsigned int ia64_compute_frame_size PARAMS((int));
-extern void save_restore_insns PARAMS((int));
-extern void ia64_expand_prologue PARAMS((void));
-extern void ia64_expand_epilogue PARAMS((void));
-extern void ia64_function_prologue PARAMS((FILE *, int));
-extern void ia64_funtion_epilogue PARAMS((FILE *, int));
-extern int ia64_direct_return PARAMS((void));
+extern int not_postinc_memory_operand PARAMS((rtx, enum machine_mode));
 extern int predicate_operator PARAMS((rtx, enum machine_mode));
 extern int ar_lc_reg_operand PARAMS((rtx, enum machine_mode));
+extern int ar_ccv_reg_operand PARAMS((rtx, enum machine_mode));
+extern int general_tfmode_operand PARAMS((rtx, enum machine_mode));
+extern int destination_tfmode_operand PARAMS((rtx, enum machine_mode));
+extern int tfreg_or_fp01_operand PARAMS((rtx, enum machine_mode));
 
 extern int ia64_move_ok PARAMS((rtx, rtx));
+extern int ia64_depz_field_mask PARAMS((rtx, rtx));
+extern rtx ia64_gp_save_reg PARAMS((int));
+extern rtx ia64_split_timode PARAMS((rtx[], rtx, rtx));
+extern rtx spill_tfmode_operand PARAMS((rtx, int));
 
+extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));
+extern void ia64_expand_prologue PARAMS((void));
+extern void ia64_expand_epilogue PARAMS((void));
+extern void ia64_function_prologue PARAMS((FILE *, int));
+extern void ia64_function_epilogue PARAMS((FILE *, int));
+
+extern int ia64_direct_return PARAMS((void));
 extern void ia64_expand_load_address PARAMS((rtx, rtx));
-extern void ia64_expand_fetch_and_op PARAMS ((enum fetchop_code,
-					      enum machine_mode, rtx []));
-extern void ia64_expand_op_and_fetch PARAMS ((enum fetchop_code,
-					      enum machine_mode, rtx []));
 
+extern void ia64_initialize_trampoline PARAMS((rtx, rtx, rtx));
 extern void ia64_print_operand_address PARAMS((FILE *, rtx));
 extern void ia64_print_operand PARAMS((FILE *, rtx, int));
 extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,
@@ -106,15 +118,8 @@ extern void ia64_encode_section_info PAR
 
 extern int ia64_register_move_cost PARAMS((enum reg_class, enum reg_class));
 extern int ia64_epilogue_uses PARAMS((int));
-extern void ia64_file_start PARAMS((FILE *));
-extern void ia64_expand_prologue PARAMS((void));
-extern void ia64_expand_epilogue PARAMS((void));
-extern void ia64_function_prologue PARAMS((FILE *, int));
+extern void emit_safe_across_calls PARAMS((FILE *));
 extern void ia64_output_end_prologue PARAMS((FILE *));
-extern void ia64_function_epilogue PARAMS((FILE *, int));
-extern int ia64_direct_return PARAMS((void));
-extern int ia64_rap_fp_offset PARAMS((void));
 extern void ia64_init_builtins PARAMS((void));
 extern void ia64_override_options PARAMS((void));
-extern unsigned int ia64_compute_frame_size PARAMS((int));
-extern void save_restore_insns PARAMS((int));
+extern int ia64_dbx_register_number PARAMS((int));
--- gcc/config/ia64/ia64.c.jj	Mon Jul 31 20:02:16 2000
+++ gcc/config/ia64/ia64.c	Mon Feb  5 10:43:05 2001
@@ -52,31 +52,6 @@ int ia64_asm_output_label = 0;
 struct rtx_def * ia64_compare_op0;
 struct rtx_def * ia64_compare_op1;
 
-/* Register number where ar.pfs was saved in the prologue, or zero
-   if it was not saved.  */
-
-int ia64_arpfs_regno;
-
-/* Register number where rp was saved in the prologue, or zero if it was
-   not saved.  */
-
-int ia64_rp_regno;
-
-/* Register number where frame pointer was saved in the prologue, or zero
-   if it was not saved.  */
-
-int ia64_fp_regno;
-
-/* Number of input and local registers used.  This is needed for the .regstk
-   directive, and also for debugging info.  */
-
-int ia64_input_regs;
-int ia64_local_regs;
-
-/* If true, then we must emit a .regstk directive.  */
-
-int ia64_need_regstk;
-
 /* Register names for ia64_expand_prologue.  */
 static const char * const ia64_reg_numbers[96] =
 { "r32", "r33", "r34", "r35", "r36", "r37", "r38", "r39",
@@ -121,6 +96,19 @@ const char *ia64_fixed_range_string;
 
 unsigned int ia64_section_threshold;
 
+static int find_gr_spill PARAMS ((int));
+static int next_scratch_gr_reg PARAMS ((void));
+static void mark_reg_gr_used_mask PARAMS ((rtx, void *));
+static void ia64_compute_frame_size PARAMS ((HOST_WIDE_INT));
+static void setup_spill_pointers PARAMS ((int, rtx, HOST_WIDE_INT));
+static void finish_spill_pointers PARAMS ((void));
+static rtx spill_restore_mem PARAMS ((rtx, HOST_WIDE_INT));
+static void do_spill PARAMS ((rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT, rtx));
+static void do_restore PARAMS ((rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT));
+static rtx gen_movdi_x PARAMS ((rtx, rtx, rtx));
+static rtx gen_fr_spill_x PARAMS ((rtx, rtx, rtx));
+static rtx gen_fr_restore_x PARAMS ((rtx, rtx, rtx));
+
 static enum machine_mode hfa_element_mode PARAMS ((tree, int));
 static void fix_range PARAMS ((const char *));
 static void ia64_add_gc_roots PARAMS ((void));
@@ -129,9 +117,17 @@ static void ia64_mark_machine_status PAR
 static void emit_insn_group_barriers PARAMS ((rtx));
 static void emit_predicate_relation_info PARAMS ((rtx));
 static int process_set PARAMS ((FILE *, rtx));
-static rtx ia64_expand_compare_and_swap PARAMS ((enum insn_code, tree,
-						 rtx, int));
-static rtx ia64_expand_binop_builtin PARAMS ((enum insn_code, tree, rtx));
+
+static rtx ia64_expand_fetch_and_op PARAMS ((optab, enum machine_mode,
+					     tree, rtx));
+static rtx ia64_expand_op_and_fetch PARAMS ((optab, enum machine_mode,
+					     tree, rtx));
+static rtx ia64_expand_compare_and_swap PARAMS ((enum machine_mode, int,
+						 tree, rtx));
+static rtx ia64_expand_lock_test_and_set PARAMS ((enum machine_mode,
+						  tree, rtx));
+static rtx ia64_expand_lock_release PARAMS ((enum machine_mode, tree, rtx));
+
 
 /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */
 
@@ -321,51 +317,175 @@ move_operand (op, mode)
   return general_operand (op, mode);
 }
 
-/* Return 1 if OP is a register operand, or zero.  */
+/* Return 1 if OP is a register operand that is (or could be) a GR reg.  */
+
+int
+gr_register_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (! register_operand (op, mode))
+    return 0;
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  if (GET_CODE (op) == REG)
+    {
+      unsigned int regno = REGNO (op);
+      if (regno < FIRST_PSEUDO_REGISTER)
+	return GENERAL_REGNO_P (regno);
+    }
+  return 1;
+}
+
+/* Return 1 if OP is a register operand that is (or could be) an FR reg.  */
+
+int
+fr_register_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (! register_operand (op, mode))
+    return 0;
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  if (GET_CODE (op) == REG)
+    {
+      unsigned int regno = REGNO (op);
+      if (regno < FIRST_PSEUDO_REGISTER)
+	return FR_REGNO_P (regno);
+    }
+  return 1;
+}
+
+/* Return 1 if OP is a register operand that is (or could be) a GR/FR reg.  */
+
+int
+grfr_register_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (! register_operand (op, mode))
+    return 0;
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  if (GET_CODE (op) == REG)
+    {
+      unsigned int regno = REGNO (op);
+      if (regno < FIRST_PSEUDO_REGISTER)
+	return GENERAL_REGNO_P (regno) || FR_REGNO_P (regno);
+    }
+  return 1;
+}
+
+/* Return 1 if OP is a nonimmediate operand that is (or could be) a GR reg.  */
+
+int
+gr_nonimmediate_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (! nonimmediate_operand (op, mode))
+    return 0;
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  if (GET_CODE (op) == REG)
+    {
+      unsigned int regno = REGNO (op);
+      if (regno < FIRST_PSEUDO_REGISTER)
+	return GENERAL_REGNO_P (regno);
+    }
+  return 1;
+}
+
+/* Return 1 if OP is a nonimmediate operand that is a GR/FR reg.  */
+
+int
+grfr_nonimmediate_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (! nonimmediate_operand (op, mode))
+    return 0;
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  if (GET_CODE (op) == REG)
+    {
+      unsigned int regno = REGNO (op);
+      if (regno < FIRST_PSEUDO_REGISTER)
+	return GENERAL_REGNO_P (regno) || FR_REGNO_P (regno);
+    }
+  return 1;
+}
+
+/* Return 1 if OP is a GR register operand, or zero.  */
+
+int
+gr_reg_or_0_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  return (op == const0_rtx || gr_register_operand (op, mode));
+}
+
+/* Return 1 if OP is a GR register operand, or a 5 bit immediate operand.  */
 
 int
-reg_or_0_operand (op, mode)
+gr_reg_or_5bit_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
-  return (op == const0_rtx || register_operand (op, mode));
+  return ((GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 32)
+	  || GET_CODE (op) == CONSTANT_P_RTX
+	  || gr_register_operand (op, mode));
 }
 
-/* Return 1 if OP is a register operand, or a 6 bit immediate operand.  */
+/* Return 1 if OP is a GR register operand, or a 6 bit immediate operand.  */
 
 int
-reg_or_6bit_operand (op, mode)
+gr_reg_or_6bit_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))
 	  || GET_CODE (op) == CONSTANT_P_RTX
-	  || register_operand (op, mode));
+	  || gr_register_operand (op, mode));
+}
+
+/* Return 1 if OP is a GR register operand, or an 8 bit immediate operand.  */
+
+int
+gr_reg_or_8bit_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))
+	  || GET_CODE (op) == CONSTANT_P_RTX
+	  || gr_register_operand (op, mode));
 }
 
-/* Return 1 if OP is a register operand, or an 8 bit immediate operand.  */
+/* Return 1 if OP is a GR/FR register operand, or an 8 bit immediate.  */
 
 int
-reg_or_8bit_operand (op, mode)
+grfr_reg_or_8bit_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))
 	  || GET_CODE (op) == CONSTANT_P_RTX
-	  || register_operand (op, mode));
+	  || grfr_register_operand (op, mode));
 }
 
 /* Return 1 if OP is a register operand, or an 8 bit adjusted immediate
    operand.  */
 
 int
-reg_or_8bit_adjusted_operand (op, mode)
+gr_reg_or_8bit_adjusted_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_L (INTVAL (op)))
 	  || GET_CODE (op) == CONSTANT_P_RTX
-	  || register_operand (op, mode));
+	  || gr_register_operand (op, mode));
 }
 
 /* Return 1 if OP is a register operand, or is valid for both an 8 bit
@@ -374,38 +494,38 @@ reg_or_8bit_adjusted_operand (op, mode)
    so we need the union of the immediates accepted by GT and LT.  */
 
 int
-reg_or_8bit_and_adjusted_operand (op, mode)
+gr_reg_or_8bit_and_adjusted_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op))
 	   && CONST_OK_FOR_L (INTVAL (op)))
 	  || GET_CODE (op) == CONSTANT_P_RTX
-	  || register_operand (op, mode));
+	  || gr_register_operand (op, mode));
 }
 
 /* Return 1 if OP is a register operand, or a 14 bit immediate operand.  */
 
 int
-reg_or_14bit_operand (op, mode)
+gr_reg_or_14bit_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_I (INTVAL (op)))
 	  || GET_CODE (op) == CONSTANT_P_RTX
-	  || register_operand (op, mode));
+	  || gr_register_operand (op, mode));
 }
 
 /* Return 1 if OP is a register operand, or a 22 bit immediate operand.  */
 
 int
-reg_or_22bit_operand (op, mode)
+gr_reg_or_22bit_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_J (INTVAL (op)))
 	  || GET_CODE (op) == CONSTANT_P_RTX
-	  || register_operand (op, mode));
+	  || gr_register_operand (op, mode));
 }
 
 /* Return 1 if OP is a 6 bit immediate operand.  */
@@ -460,13 +580,12 @@ fetchadd_operand (op, mode)
 /* Return 1 if OP is a floating-point constant zero, one, or a register.  */
 
 int
-reg_or_fp01_operand (op, mode)
+fr_reg_or_fp01_operand (op, mode)
      rtx op;
      enum machine_mode mode;
 {
   return ((GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (op))
-	  || GET_CODE (op) == CONSTANT_P_RTX
-	  || register_operand (op, mode));
+	  || fr_register_operand (op, mode));
 }
 
 /* Like nonimmediate_operand, but don't allow MEMs that try to use a
@@ -486,6 +605,17 @@ destination_operand (op, mode)
   return 1;
 }
 
+/* Like memory_operand, but don't allow post-increments.  */
+
+int
+not_postinc_memory_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  return (memory_operand (op, mode)
+	  && GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != 'a');
+}
+
 /* Return 1 if this is a comparison operator, which accepts an normal 8-bit
    signed immediate operand.  */
 
@@ -572,6 +702,58 @@ ar_lc_reg_operand (op, mode)
 	  && GET_CODE (op) == REG
 	  && REGNO (op) == AR_LC_REGNUM);
 }
+
+/* Return 1 if this is the ar.ccv register.  */
+
+int
+ar_ccv_reg_operand (op, mode)
+     register rtx op;
+     enum machine_mode mode;
+{
+  return ((GET_MODE (op) == mode || mode == VOIDmode)
+	  && GET_CODE (op) == REG
+	  && REGNO (op) == AR_CCV_REGNUM);
+}
+
+/* Like general_operand, but don't allow (mem (addressof)).  */
+
+int
+general_tfmode_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (! general_operand (op, mode))
+    return 0;
+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == ADDRESSOF)
+    return 0;
+  return 1;
+}
+
+/* Similarly.  */
+
+int
+destination_tfmode_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (! destination_operand (op, mode))
+    return 0;
+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == ADDRESSOF)
+    return 0;
+  return 1;
+}
+
+/* Similarly.  */
+
+int
+tfreg_or_fp01_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  if (GET_CODE (op) == SUBREG)
+    return 0;
+  return fr_reg_or_fp01_operand (op, mode);
+}
 
 /* Return 1 if the operands of a move are ok.  */
 
@@ -597,6 +779,23 @@ ia64_move_ok (dst, src)
     return GET_CODE (src) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (src);
 }
 
+/* Check if OP is a mask suitible for use with SHIFT in a dep.z instruction.
+   Return the length of the field, or <= 0 on failure.  */
+
+int
+ia64_depz_field_mask (rop, rshift)
+     rtx rop, rshift;
+{
+  unsigned HOST_WIDE_INT op = INTVAL (rop);
+  unsigned HOST_WIDE_INT shift = INTVAL (rshift);
+
+  /* Get rid of the zero bits we're shifting in.  */
+  op >>= shift;
+
+  /* We must now have a solid block of 1's at bit 0.  */
+  return exact_log2 (op + 1);
+}
+
 /* Expand a symbolic constant load.  */
 /* ??? Should generalize this, so that we can also support 32 bit pointers.  */
 
@@ -643,11 +842,149 @@ ia64_expand_load_address (dest, src)
   if (temp != dest)
     emit_move_insn (dest, temp);
 }
+
+rtx
+ia64_gp_save_reg (setjmp_p)
+     int setjmp_p;
+{
+  rtx save = cfun->machine->ia64_gp_save;
+
+  if (save != NULL)
+    {
+      /* We can't save GP in a pseudo if we are calling setjmp, because
+	 pseudos won't be restored by longjmp.  For now, we save it in r4.  */
+      /* ??? It would be more efficient to save this directly into a stack
+	 slot.  Unfortunately, the stack slot address gets cse'd across
+	 the setjmp call because the NOTE_INSN_SETJMP note is in the wrong
+	 place.  */
+
+      /* ??? Get the barf bag, Virginia.  We've got to replace this thing
+         in place, since this rtx is used in exception handling receivers.
+         Moreover, we must get this rtx out of regno_reg_rtx or reload
+         will do the wrong thing.  */
+      unsigned int old_regno = REGNO (save);
+      if (setjmp_p && old_regno != GR_REG (4))
+        {
+          REGNO (save) = GR_REG (4);
+          regno_reg_rtx[old_regno] = gen_rtx_raw_REG (DImode, old_regno);
+        }
+    }
+  else
+    {
+      if (setjmp_p)
+	save = gen_rtx_REG (DImode, GR_REG (4));
+      else if (! optimize)
+	save = gen_rtx_REG (DImode, LOC_REG (0));
+      else
+	save = gen_reg_rtx (DImode);
+      cfun->machine->ia64_gp_save = save;
+    }
+
+  return save;
+}
+
+/* Split a post-reload TImode reference into two DImode components.  */
+
+rtx
+ia64_split_timode (out, in, scratch)
+     rtx out[2];
+     rtx in, scratch;
+{
+  switch (GET_CODE (in))
+    {
+    case REG:
+      out[0] = gen_rtx_REG (DImode, REGNO (in));
+      out[1] = gen_rtx_REG (DImode, REGNO (in) + 1);
+      return NULL_RTX;
+
+    case MEM:
+      {
+	rtx base = XEXP (in, 0);
+
+	switch (GET_CODE (base))
+	  {
+	  case REG:
+	    out[0] = change_address (in, DImode, NULL_RTX);
+	    break;
+	  case POST_MODIFY:
+	    base = XEXP (base, 0);
+	    out[0] = change_address (in, DImode, NULL_RTX);
+	    break;
+
+	  /* Since we're changing the mode, we need to change to POST_MODIFY
+	     as well to preserve the size of the increment.  Either that or
+	     do the update in two steps, but we've already got this scratch
+	     register handy so let's use it.  */
+	  case POST_INC:
+	    base = XEXP (base, 0);
+	    out[0] = change_address (in, DImode,
+	      gen_rtx_POST_MODIFY (Pmode, base,plus_constant (base, 16)));
+	    break;
+	  case POST_DEC:
+	    base = XEXP (base, 0);
+	    out[0] = change_address (in, DImode,
+	      gen_rtx_POST_MODIFY (Pmode, base,plus_constant (base, -16)));
+	    break;
+	  default:
+	    abort ();
+	  }
+
+	if (scratch == NULL_RTX)
+	  abort ();
+	out[1] = change_address (in, DImode, scratch);
+	return gen_adddi3 (scratch, base, GEN_INT (8));
+      }
+
+    case CONST_INT:
+    case CONST_DOUBLE:
+      split_double (in, &out[0], &out[1]);
+      return NULL_RTX;
+
+    default:
+      abort ();
+    }
+}
+
+/* ??? Fixing GR->FR TFmode moves during reload is hard.  You need to go
+   through memory plus an extra GR scratch register.  Except that you can
+   either get the first from SECONDARY_MEMORY_NEEDED or the second from
+   SECONDARY_RELOAD_CLASS, but not both.
+
+   We got into problems in the first place by allowing a construct like
+   (subreg:TF (reg:TI)), which we got from a union containing a long double.  
+   This solution attempts to prevent this situation from ocurring.  When
+   we see something like the above, we spill the inner register to memory.  */
+
+rtx
+spill_tfmode_operand (in, force)
+     rtx in;
+     int force;
+{
+  if (GET_CODE (in) == SUBREG
+      && GET_MODE (SUBREG_REG (in)) == TImode
+      && GET_CODE (SUBREG_REG (in)) == REG)
+    {
+      rtx mem = gen_mem_addressof (SUBREG_REG (in), NULL_TREE);
+      return gen_rtx_MEM (TFmode, copy_to_reg (XEXP (mem, 0)));
+    }
+  else if (force && GET_CODE (in) == REG)
+    {
+      rtx mem = gen_mem_addressof (in, NULL_TREE);
+      return gen_rtx_MEM (TFmode, copy_to_reg (XEXP (mem, 0)));
+    }
+  else if (GET_CODE (in) == MEM
+	   && GET_CODE (XEXP (in, 0)) == ADDRESSOF)
+    {
+      return change_address (in, TFmode, copy_to_reg (XEXP (in, 0)));
+    }
+  else
+    return in;
+}
 
 /* Begin the assembly file.  */
 
 void
-ia64_file_start (f)
+emit_safe_across_calls (f)
      FILE *f;
 {
   unsigned int rs, re;
@@ -680,340 +1017,653 @@ ia64_file_start (f)
     fputc ('\n', f);
 }
 
+
 /* Structure to be filled in by ia64_compute_frame_size with register
    save masks and offsets for the current function.  */
 
 struct ia64_frame_info
 {
-  long total_size;		/* # bytes that the entire frame takes up.  */
-  long var_size;		/* # bytes that variables take up.  */
-  long args_size;		/* # bytes that outgoing arguments take up.  */
-  long pretend_size;		/* # bytes that stdarg arguments take up.  */
-  long pretend_pad_size;	/* # bytes padding to align stdarg args.  */
-  long extra_size;		/* # bytes of extra gunk.  */
-  long gr_size;			/* # bytes needed to store general regs.  */
-  long fr_size;			/* # bytes needed to store FP regs.  */
-  long fr_pad_size;		/* # bytes needed to align FP save area.  */
-  long pr_size;			/* # bytes needed to store predicate regs.  */
-  long br_size;			/* # bytes needed to store branch regs.  */
-  long ar_size;			/* # bytes needed to store AR regs.  */
+  HOST_WIDE_INT total_size;	/* size of the stack frame, not including
+				   the caller's scratch area.  */
+  HOST_WIDE_INT spill_cfa_off;	/* top of the reg spill area from the cfa.  */
+  HOST_WIDE_INT spill_size;	/* size of the gr/br/fr spill area.  */
+  HOST_WIDE_INT extra_spill_size;  /* size of spill area for others.  */
   HARD_REG_SET mask;		/* mask of saved registers.  */
-  int initialized;		/* != 0 is frame size already calculated.  */
+  unsigned int gr_used_mask;	/* mask of registers in use as gr spill 
+				   registers or long-term scratches.  */
+  int n_spilled;		/* number of spilled registers.  */
+  int reg_fp;			/* register for fp.  */
+  int reg_save_b0;		/* save register for b0.  */
+  int reg_save_pr;		/* save register for prs.  */
+  int reg_save_ar_pfs;		/* save register for ar.pfs.  */
+  int reg_save_ar_unat;		/* save register for ar.unat.  */
+  int reg_save_ar_lc;		/* save register for ar.lc.  */
+  int n_input_regs;		/* number of input registers used.  */
+  int n_local_regs;		/* number of local registers used.  */
+  int n_output_regs;		/* number of output registers used.  */
+  int n_rotate_regs;		/* number of rotating registers used.  */
+
+  char need_regstk;		/* true if a .regstk directive needed.  */
+  char initialized;		/* true if the data is finalized.  */
 };
 
-/* Current frame information calculated by compute_frame_size.  */
-struct ia64_frame_info current_frame_info;
+/* Current frame information calculated by ia64_compute_frame_size.  */
+static struct ia64_frame_info current_frame_info;
 
-/* Helper function for INITIAL_ELIMINATION_OFFSET.  Return the offset from the
-   frame pointer where b0 is saved.  */
+/* Helper function for ia64_compute_frame_size: find an appropriate general
+   register to spill some special register to.  SPECIAL_SPILL_MASK contains
+   bits in GR0 to GR31 that have already been allocated by this routine.
+   TRY_LOCALS is true if we should attempt to locate a local regnum.  */
 
-int
-ia64_rap_fp_offset ()
+static int
+find_gr_spill (try_locals)
+     int try_locals;
+{
+  int regno;
+
+  /* If this is a leaf function, first try an otherwise unused
+     call-clobbered register.  */
+  if (current_function_is_leaf)
+    {
+      for (regno = GR_REG (1); regno <= GR_REG (31); regno++)
+	if (! regs_ever_live[regno]
+	    && call_used_regs[regno]
+	    && ! fixed_regs[regno]
+	    && ! global_regs[regno]
+	    && ((current_frame_info.gr_used_mask >> regno) & 1) == 0)
+	  {
+	    current_frame_info.gr_used_mask |= 1 << regno;
+	    return regno;
+	  }
+    }
+
+  if (try_locals)
+    {
+      regno = current_frame_info.n_local_regs;
+      if (regno < 80)
+	{
+	  current_frame_info.n_local_regs = regno + 1;
+	  return LOC_REG (0) + regno;
+	}
+    }
+
+  /* Failed to find a general register to spill to.  Must use stack.  */
+  return 0;
+}
+
+/* In order to make for nice schedules, we try to allocate every temporary
+   to a different register.  We must of course stay away from call-saved,
+   fixed, and global registers.  We must also stay away from registers
+   allocated in current_frame_info.gr_used_mask, since those include regs
+   used all through the prologue.
+
+   Any register allocated here must be used immediately.  The idea is to
+   aid scheduling, not to solve data flow problems.  */
+
+static int last_scratch_gr_reg;
+
+static int
+next_scratch_gr_reg ()
 {
-  return - current_frame_info.br_size;
+  int i, regno;
+
+  for (i = 0; i < 32; ++i)
+    {
+      regno = (last_scratch_gr_reg + i + 1) & 31;
+      if (call_used_regs[regno]
+	  && ! fixed_regs[regno]
+	  && ! global_regs[regno]
+	  && ((current_frame_info.gr_used_mask >> regno) & 1) == 0)
+	{
+	  last_scratch_gr_reg = regno;
+	  return regno;
+	}
+    }
+
+  /* There must be _something_ available.  */
+  abort ();
+}
+
+/* Helper function for ia64_compute_frame_size, called through
+   diddle_return_value.  Mark REG in current_frame_info.gr_used_mask.  */
+
+static void
+mark_reg_gr_used_mask (reg, data)
+     rtx reg;
+     void *data ATTRIBUTE_UNUSED;
+{
+  unsigned int regno = REGNO (reg);
+  if (regno < 32)
+    current_frame_info.gr_used_mask |= 1 << regno;
 }
 
 /* Returns the number of bytes offset between the frame pointer and the stack
    pointer for the current function.  SIZE is the number of bytes of space
    needed for local variables.  */
-unsigned int
+
+static void
 ia64_compute_frame_size (size)
-     int size;
+     HOST_WIDE_INT size;
 {
-  int total_size;
-  int extra_size;
-  int gr_size = 0;
-  int fr_size = 0;
-  int fr_pad_size = 0;
-  int pr_size = 0;
-  int br_size = 0;
-  int ar_size = 0;
-  int pretend_pad_size = 0;
-  int tmp;
-  int regno;
+  HOST_WIDE_INT total_size;
+  HOST_WIDE_INT spill_size = 0;
+  HOST_WIDE_INT extra_spill_size = 0;
+  HOST_WIDE_INT pretend_args_size;
   HARD_REG_SET mask;
+  int n_spilled = 0;
+  int spilled_gr_p = 0;
+  int spilled_fr_p = 0;
+  unsigned int regno;
+  int i;
 
-  /* Reload used to round the frame size to STACK_BOUNDARY.  Now we do it
-     here.  */
-  size = IA64_STACK_ALIGN (size);
+  if (current_frame_info.initialized)
+    return;
 
+  memset (&current_frame_info, 0, sizeof current_frame_info);
   CLEAR_HARD_REG_SET (mask);
 
-  /* Calculate space needed for general registers.  */
-  /* We never need to save any of the stacked registers, which are regs
-     32 to 127.  */
-  for (regno = GR_REG (0); regno <= GR_REG (31); regno++)
-    if (regs_ever_live[regno] && ! call_used_regs[regno])
-      {
-	SET_HARD_REG_BIT (mask, regno);
-	gr_size += 8;
-      }
+  /* Don't allocate scratches to the return register.  */
+  diddle_return_value (mark_reg_gr_used_mask, NULL);
+
+  /* Don't allocate scratches to the EH scratch registers.  */
+  if (cfun->machine->ia64_eh_epilogue_sp)
+    mark_reg_gr_used_mask (cfun->machine->ia64_eh_epilogue_sp, NULL);
+  if (cfun->machine->ia64_eh_epilogue_bsp)
+    mark_reg_gr_used_mask (cfun->machine->ia64_eh_epilogue_bsp, NULL);
+
+  /* Find the size of the register stack frame.  We have only 80 local
+     registers, because we reserve 8 for the inputs and 8 for the
+     outputs.  */
+
+  /* Skip HARD_FRAME_POINTER_REGNUM (loc79) when frame_pointer_needed,
+     since we'll be adjusting that down later.  */
+  regno = LOC_REG (78) + ! frame_pointer_needed;
+  for (; regno >= LOC_REG (0); regno--)
+    if (regs_ever_live[regno])
+      break;
+  current_frame_info.n_local_regs = regno - LOC_REG (0) + 1;
+
+  if (cfun->machine->n_varargs > 0)
+    current_frame_info.n_input_regs = 8;
+  else
+    {
+      for (regno = IN_REG (7); regno >= IN_REG (0); regno--)
+	if (regs_ever_live[regno])
+	  break;
+      current_frame_info.n_input_regs = regno - IN_REG (0) + 1;
+    }
 
-  /* Allocate space to save/restore the unat from.  */
-  if (gr_size != 0
-      || current_function_varargs || current_function_stdarg)
-    gr_size += 8;
+  for (regno = OUT_REG (7); regno >= OUT_REG (0); regno--)
+    if (regs_ever_live[regno])
+      break;
+  i = regno - OUT_REG (0) + 1;
+
+  /* When -p profiling, we need one output register for the mcount argument.
+     Likwise for -a profiling for the bb_init_func argument.  For -ax
+     profiling, we need two output registers for the two bb_init_trace_func
+     arguments.  */
+  if (profile_flag || profile_block_flag == 1)
+    i = MAX (i, 1);
+  else if (profile_block_flag == 2)
+    i = MAX (i, 2);
+  current_frame_info.n_output_regs = i;
 
-  /* Calculate space needed for FP registers.  */
-  for (regno = FR_REG (0); regno <= FR_REG (127); regno++)
+  /* ??? No rotating register support yet.  */
+  current_frame_info.n_rotate_regs = 0;
+
+  /* Discover which registers need spilling, and how much room that
+     will take.  Begin with floating point and general registers, 
+     which will always wind up on the stack.  */
+
+  for (regno = FR_REG (2); regno <= FR_REG (127); regno++)
     if (regs_ever_live[regno] && ! call_used_regs[regno])
       {
 	SET_HARD_REG_BIT (mask, regno);
-	fr_size += 16;
+	spill_size += 16;
+	n_spilled += 1;
+	spilled_fr_p = 1;
       }
 
-  /* Calculate space needed for predicate registers.  */
-  for (regno = PR_REG (0); regno <= PR_REG (63); regno++)
+  for (regno = GR_REG (1); regno <= GR_REG (31); regno++)
     if (regs_ever_live[regno] && ! call_used_regs[regno])
       {
 	SET_HARD_REG_BIT (mask, regno);
-	pr_size = 8;
+	spill_size += 8;
+	n_spilled += 1;
+	spilled_gr_p = 1;
       }
 
-  /* Calculate space needed for branch registers.  */
-  for (regno = BR_REG (0); regno <= BR_REG (7); regno++)
+  for (regno = BR_REG (1); regno <= BR_REG (7); regno++)
     if (regs_ever_live[regno] && ! call_used_regs[regno])
       {
 	SET_HARD_REG_BIT (mask, regno);
-	br_size += 8;
+	spill_size += 8;
+	n_spilled += 1;
       }
 
-  /* The FR save area needs to be 16-byte aligned.  */
-  if (fr_size)
+  /* Now come all special registers that might get saved in other
+     general registers.  */
+  
+  if (frame_pointer_needed)
     {
-      tmp = (size + fr_size + br_size);
-      fr_pad_size = IA64_STACK_ALIGN (tmp) - tmp;
+      current_frame_info.reg_fp = find_gr_spill (1);
+      /* We should have gotten at least LOC79, since that's what
+	 HARD_FRAME_POINTER_REGNUM is.  */
+      if (current_frame_info.reg_fp == 0)
+	abort ();
     }
-  else
-    fr_pad_size = 0;
 
-  /* AR.LC, for reasons unexplained, is call saved.  */
-  if (regs_ever_live[AR_LC_REGNUM])
+  if (! current_function_is_leaf)
     {
-      SET_HARD_REG_BIT (mask, AR_LC_REGNUM);
-      ar_size = 8;
+      /* Emit a save of BR0 if we call other functions.  Do this even
+	 if this function doesn't return, as EH depends on this to be
+	 able to unwind the stack.  */
+      SET_HARD_REG_BIT (mask, BR_REG (0));
+
+      current_frame_info.reg_save_b0 = find_gr_spill (1);
+      if (current_frame_info.reg_save_b0 == 0)
+	{
+	  spill_size += 8;
+	  n_spilled += 1;
+	}
+
+      /* Similarly for ar.pfs.  */
+      SET_HARD_REG_BIT (mask, AR_PFS_REGNUM);
+      current_frame_info.reg_save_ar_pfs = find_gr_spill (1);
+      if (current_frame_info.reg_save_ar_pfs == 0)
+	{
+	  extra_spill_size += 8;
+	  n_spilled += 1;
+	}
+    }
+  else
+    {
+      if (regs_ever_live[BR_REG (0)] && ! call_used_regs[BR_REG (0)])
+	{
+	  SET_HARD_REG_BIT (mask, BR_REG (0));
+	  spill_size += 8;
+	  n_spilled += 1;
+	}
+    }
+
+  /* Unwind descriptor hackery: things are most efficient if we allocate
+     consecutive GR save registers for RP, PFS, FP in that order. However,
+     it is absolutely critical that FP get the only hard register that's
+     guaranteed to be free, so we allocated it first.  If all three did
+     happen to be allocated hard regs, and are consecutive, rearrange them
+     into the preferred order now.  */
+  if (current_frame_info.reg_fp != 0
+      && current_frame_info.reg_save_b0 == current_frame_info.reg_fp + 1
+      && current_frame_info.reg_save_ar_pfs == current_frame_info.reg_fp + 2)
+    {
+      current_frame_info.reg_save_b0 = current_frame_info.reg_fp;
+      current_frame_info.reg_save_ar_pfs = current_frame_info.reg_fp + 1;
+      current_frame_info.reg_fp = current_frame_info.reg_fp + 2;
+    }
+
+  /* See if we need to store the predicate register block.  */
+  for (regno = PR_REG (0); regno <= PR_REG (63); regno++)
+    if (regs_ever_live[regno] && ! call_used_regs[regno])
+      break;
+  if (regno <= PR_REG (63))
+    {
+      SET_HARD_REG_BIT (mask, PR_REG (0));
+      current_frame_info.reg_save_pr = find_gr_spill (1);
+      if (current_frame_info.reg_save_pr == 0)
+	{
+	  extra_spill_size += 8;
+	  n_spilled += 1;
+	}
+
+      /* ??? Mark them all as used so that register renaming and such
+	 are free to use them.  */
+      for (regno = PR_REG (0); regno <= PR_REG (63); regno++)
+	regs_ever_live[regno] = 1;
     }
 
-  /* If we have an odd number of words of pretend arguments written to the
-     stack, then the FR save area will be unaligned.  We pad below this area
-     to keep things 16 byte aligned.  This needs to be kept distinct, to
-     avoid confusing it with padding added below the GR save area, which does
-     not affect the FR area alignment.  */
-  pretend_pad_size = current_function_pretend_args_size % 16;
-
-  /* The 16 bytes is for the scratch area.  */
-  tmp = (size + gr_size + fr_pad_size + fr_size + pr_size + br_size + ar_size
-	 + current_function_outgoing_args_size + 16);
-  tmp += (current_function_pretend_args_size
-	  ? current_function_pretend_args_size - 16
-	  : 0) + pretend_pad_size;
-  total_size = IA64_STACK_ALIGN (tmp);
-  extra_size = total_size - tmp + 16;
-
-  /* If this is a leaf routine, and if there is no stack space needed for
-     register saves, then don't allocate the 16 byte scratch area.  */
-  if (total_size == 16 && current_function_is_leaf)
+  /* If we're forced to use st8.spill, we're forced to save and restore
+     ar.unat as well.  */
+  if (spilled_gr_p || cfun->machine->n_varargs)
     {
-      total_size = 0;
-      extra_size = 0;
+      SET_HARD_REG_BIT (mask, AR_UNAT_REGNUM);
+      current_frame_info.reg_save_ar_unat = find_gr_spill (spill_size == 0);
+      if (current_frame_info.reg_save_ar_unat == 0)
+	{
+	  extra_spill_size += 8;
+	  n_spilled += 1;
+	}
+    }
+
+  if (regs_ever_live[AR_LC_REGNUM])
+    {
+      SET_HARD_REG_BIT (mask, AR_LC_REGNUM);
+      current_frame_info.reg_save_ar_lc = find_gr_spill (spill_size == 0);
+      if (current_frame_info.reg_save_ar_lc == 0)
+	{
+	  extra_spill_size += 8;
+	  n_spilled += 1;
+	}
     }
 
+  /* If we have an odd number of words of pretend arguments written to
+     the stack, then the FR save area will be unaligned.  We round the
+     size of this area up to keep things 16 byte aligned.  */
+  if (spilled_fr_p)
+    pretend_args_size = IA64_STACK_ALIGN (current_function_pretend_args_size);
+  else
+    pretend_args_size = current_function_pretend_args_size;
+
+  total_size = (spill_size + extra_spill_size + size + pretend_args_size
+		+ current_function_outgoing_args_size);
+  total_size = IA64_STACK_ALIGN (total_size);
+
+  /* We always use the 16-byte scratch area provided by the caller, but
+     if we are a leaf function, there's no one to which we need to provide
+     a scratch area.  */
+  if (current_function_is_leaf)
+    total_size = MAX (0, total_size - 16);
+
   current_frame_info.total_size = total_size;
-  current_frame_info.var_size = size;
-  current_frame_info.args_size = current_function_outgoing_args_size;
-  current_frame_info.pretend_size
-    = (current_function_pretend_args_size
-       ? current_function_pretend_args_size - 16
-       : 0);
-  current_frame_info.pretend_pad_size = pretend_pad_size;
-  current_frame_info.extra_size = extra_size;
-  current_frame_info.gr_size = gr_size;
-  current_frame_info.fr_size = fr_size;
-  current_frame_info.fr_pad_size = fr_pad_size;
-  current_frame_info.pr_size = pr_size;
-  current_frame_info.br_size = br_size;
-  current_frame_info.ar_size = ar_size;
+  current_frame_info.spill_cfa_off = pretend_args_size - 16;
+  current_frame_info.spill_size = spill_size;
+  current_frame_info.extra_spill_size = extra_spill_size;
   COPY_HARD_REG_SET (current_frame_info.mask, mask);
+  current_frame_info.n_spilled = n_spilled;
   current_frame_info.initialized = reload_completed;
-
-  return total_size;
 }
 
-void
-save_restore_insns (save_p)
-     int save_p;
+/* Compute the initial difference between the specified pair of registers.  */
+
+HOST_WIDE_INT
+ia64_initial_elimination_offset (from, to)
+     int from, to;
 {
-  rtx insn;
+  HOST_WIDE_INT offset;
 
-  if (current_frame_info.gr_size
-      + current_frame_info.fr_size
-      + current_frame_info.br_size
-      + current_frame_info.pr_size
-      + current_frame_info.ar_size)
-    {
-      rtx tmp_reg = gen_rtx_REG (DImode, GR_REG (2));
-      rtx tmp_post_inc = gen_rtx_POST_INC (DImode, tmp_reg);
-      rtx tmp2_reg = gen_rtx_REG (DImode, GR_REG (3));
-      int offset = (current_frame_info.total_size
-		    - (current_frame_info.gr_size + current_frame_info.fr_size
-		       + current_frame_info.fr_pad_size
-		       + current_frame_info.br_size
-		       + current_frame_info.pr_size
-		       + current_frame_info.ar_size
-		       + current_frame_info.var_size
-		       + current_frame_info.pretend_size
-		       + current_frame_info.pretend_pad_size));
-      rtx offset_rtx;
-      int regno;
-
-      /* If there is a frame pointer, then we use it instead of the stack
-	 pointer, so that the stack pointer does not need to be valid when
-	 the epilogue starts.  See EXIT_IGNORE_STACK.  */
-      if (frame_pointer_needed)
-	offset = offset - current_frame_info.total_size;
+  ia64_compute_frame_size (get_frame_size ());
+  switch (from)
+    {
+    case FRAME_POINTER_REGNUM:
+      if (to == HARD_FRAME_POINTER_REGNUM)
+	{
+	  if (current_function_is_leaf)
+	    offset = -current_frame_info.total_size;
+	  else
+	    offset = -(current_frame_info.total_size
+		       - current_function_outgoing_args_size - 16);
+	}
+      else if (to == STACK_POINTER_REGNUM)
+	{
+	  if (current_function_is_leaf)
+	    offset = 0;
+	  else
+	    offset = 16 + current_function_outgoing_args_size;
+	}
+      else
+	abort ();
+      break;
 
-      if (CONST_OK_FOR_I (offset))
-	offset_rtx = GEN_INT (offset);
+    case ARG_POINTER_REGNUM:
+      /* Arguments start above the 16 byte save area, unless stdarg
+	 in which case we store through the 16 byte save area.  */
+      if (to == HARD_FRAME_POINTER_REGNUM)
+	offset = 16 - current_function_pretend_args_size;
+      else if (to == STACK_POINTER_REGNUM)
+	offset = (current_frame_info.total_size
+		  + 16 - current_function_pretend_args_size);
       else
-	{
-	  offset_rtx = tmp_reg;
-	  insn = emit_insn (gen_movdi (tmp_reg, GEN_INT (offset)));
-	  if (save_p)
-	    RTX_FRAME_RELATED_P (insn) = 1;
-	}
-      insn = emit_insn (gen_adddi3 (tmp_reg,
-				    (frame_pointer_needed ? frame_pointer_rtx
-				     : stack_pointer_rtx),
-				    offset_rtx));
-      if (save_p)
-	RTX_FRAME_RELATED_P (insn) = 1;
+	abort ();
+      break;
 
-      /* If one is used, we save/restore all of them.  */
-      for (regno = PR_REG (0); regno <= PR_REG (63); regno++)
-	if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
-	  {
-	    rtx mem = gen_rtx_MEM (DImode, tmp_post_inc);
-	    if (save_p)
-	      {
-		insn = emit_insn (gen_pr_spill (tmp2_reg));
-		RTX_FRAME_RELATED_P (insn) = 1;
-		insn = emit_insn (gen_movdi (mem, tmp2_reg));
-		RTX_FRAME_RELATED_P (insn) = 1;
-	      }
-	    else
-	      {
-		insn = emit_insn (gen_movdi (tmp2_reg, mem));
-		insn = emit_insn (gen_pr_restore (tmp2_reg));
-	      }
-	    break;
-	  }
+    case RETURN_ADDRESS_POINTER_REGNUM:
+      offset = 0;
+      break;
 
-      /* Must save/restore ar.unat if any GR is spilled/restored.  */
-      if (current_frame_info.gr_size != 0
-	  || current_function_varargs || current_function_stdarg)
+    default:
+      abort ();
+    }
+
+  return offset;
+}
+
+/* If there are more than a trivial number of register spills, we use
+   two interleaved iterators so that we can get two memory references
+   per insn group.
+
+   In order to simplify things in the prologue and epilogue expanders,
+   we use helper functions to fix up the memory references after the
+   fact with the appropriate offsets to a POST_MODIFY memory mode.
+   The following data structure tracks the state of the two iterators
+   while insns are being emitted.  */
+
+struct spill_fill_data
+{
+  rtx init_after;		/* point at which to emit intializations */
+  rtx init_reg[2];		/* initial base register */
+  rtx iter_reg[2];		/* the iterator registers */
+  rtx *prev_addr[2];		/* address of last memory use */
+  HOST_WIDE_INT prev_off[2];	/* last offset */
+  int n_iter;			/* number of iterators in use */
+  int next_iter;		/* next iterator to use */
+  unsigned int save_gr_used_mask;
+};
+
+static struct spill_fill_data spill_fill_data;
+
+static void
+setup_spill_pointers (n_spills, init_reg, cfa_off)
+     int n_spills;
+     rtx init_reg;
+     HOST_WIDE_INT cfa_off;
+{
+  int i;
+
+  spill_fill_data.init_after = get_last_insn ();
+  spill_fill_data.init_reg[0] = init_reg;
+  spill_fill_data.init_reg[1] = init_reg;
+  spill_fill_data.prev_addr[0] = NULL;
+  spill_fill_data.prev_addr[1] = NULL;
+  spill_fill_data.prev_off[0] = cfa_off;
+  spill_fill_data.prev_off[1] = cfa_off;
+  spill_fill_data.next_iter = 0;
+  spill_fill_data.save_gr_used_mask = current_frame_info.gr_used_mask;
+
+  spill_fill_data.n_iter = 1 + (n_spills > 2);
+  for (i = 0; i < spill_fill_data.n_iter; ++i)
+    {
+      int regno = next_scratch_gr_reg ();
+      spill_fill_data.iter_reg[i] = gen_rtx_REG (DImode, regno);
+      current_frame_info.gr_used_mask |= 1 << regno;
+    }
+}
+
+static void
+finish_spill_pointers ()
+{
+  current_frame_info.gr_used_mask = spill_fill_data.save_gr_used_mask;
+}
+
+static rtx
+spill_restore_mem (reg, cfa_off)
+     rtx reg;
+     HOST_WIDE_INT cfa_off;
+{
+  int iter = spill_fill_data.next_iter;
+  HOST_WIDE_INT disp = spill_fill_data.prev_off[iter] - cfa_off;
+  rtx disp_rtx = GEN_INT (disp);
+  rtx mem;
+
+  if (spill_fill_data.prev_addr[iter])
+    {
+      if (CONST_OK_FOR_N (disp))
+	*spill_fill_data.prev_addr[iter]
+	  = gen_rtx_POST_MODIFY (DImode, spill_fill_data.iter_reg[iter],
+				 gen_rtx_PLUS (DImode,
+					       spill_fill_data.iter_reg[iter],
+					       disp_rtx));
+      else
 	{
-	  rtx mem = gen_rtx_MEM (DImode, tmp_post_inc);
-	  if (save_p)
+	  /* ??? Could use register post_modify for loads.  */
+	  if (! CONST_OK_FOR_I (disp))
 	    {
-	      insn = emit_insn (gen_unat_spill (tmp2_reg));
-	      if (save_p)
-		RTX_FRAME_RELATED_P (insn) = 1;
-	      insn = emit_insn (gen_movdi (mem, tmp2_reg));
-	      if (save_p)
-		RTX_FRAME_RELATED_P (insn) = 1;
+	      rtx tmp = gen_rtx_REG (DImode, next_scratch_gr_reg ());
+	      emit_move_insn (tmp, disp_rtx);
+	      disp_rtx = tmp;
 	    }
-	  else
+	  emit_insn (gen_adddi3 (spill_fill_data.iter_reg[iter],
+				 spill_fill_data.iter_reg[iter], disp_rtx));
+	}
+    }
+  /* Micro-optimization: if we've created a frame pointer, it's at
+     CFA 0, which may allow the real iterator to be initialized lower,
+     slightly increasing parallelism.  Also, if there are few saves
+     it may eliminate the iterator entirely.  */
+  else if (disp == 0
+	   && spill_fill_data.init_reg[iter] == stack_pointer_rtx
+	   && frame_pointer_needed)
+    {
+      mem = gen_rtx_MEM (GET_MODE (reg), hard_frame_pointer_rtx);
+      MEM_ALIAS_SET (mem) = get_varargs_alias_set ();
+      return mem;
+    }
+  else
+    {
+      rtx seq;
+
+      if (disp == 0)
+	seq = gen_movdi (spill_fill_data.iter_reg[iter],
+			 spill_fill_data.init_reg[iter]);
+      else
+	{
+	  start_sequence ();
+
+	  if (! CONST_OK_FOR_I (disp))
 	    {
-	      insn = emit_insn (gen_movdi (tmp2_reg, mem));
-	      if (save_p)
-		RTX_FRAME_RELATED_P (insn) = 1;
-	      /* The restore happens after the last ld8.fill instruction.  */
+	      rtx tmp = gen_rtx_REG (DImode, next_scratch_gr_reg ());
+	      emit_move_insn (tmp, disp_rtx);
+	      disp_rtx = tmp;
 	    }
+
+	  emit_insn (gen_adddi3 (spill_fill_data.iter_reg[iter],
+				 spill_fill_data.init_reg[iter],
+				 disp_rtx));
+
+	  seq = gen_sequence ();
+	  end_sequence ();
 	}
 
-      for (regno = GR_REG (0); regno <= GR_REG (127); regno++)
-	if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
-	  {
-	    rtx mem = gen_rtx_MEM (DImode, tmp_post_inc);
-	    if (save_p)
-	      insn = emit_insn (gen_gr_spill (mem,
-					      gen_rtx_REG (DImode, regno)));
-	    else
-	      insn = emit_insn (gen_gr_restore (gen_rtx_REG (DImode, regno),
-						mem));
-	    if (save_p)
-	      RTX_FRAME_RELATED_P (insn) = 1;
-	  }
+      /* Careful for being the first insn in a sequence.  */
+      if (spill_fill_data.init_after)
+	spill_fill_data.init_after
+	  = emit_insn_after (seq, spill_fill_data.init_after);
+      else
+	{
+	  rtx first = get_insns ();
+	  if (first)
+	    spill_fill_data.init_after
+	      = emit_insn_before (seq, first);
+	  else
+	    spill_fill_data.init_after = emit_insn (seq);
+	}
+    }
 
-      /* Now restore the unat register if necessary.  */
-      if ((current_frame_info.gr_size != 0
-	   || current_function_varargs || current_function_stdarg)
-	  && ! save_p)
-	emit_insn (gen_unat_restore (tmp2_reg));
+  mem = gen_rtx_MEM (GET_MODE (reg), spill_fill_data.iter_reg[iter]);
 
-      for (regno = FR_REG (0); regno <= FR_REG (127); regno++)
-	if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
-	  {
-	    rtx mem = gen_rtx_MEM (XFmode, tmp_post_inc);
-	    if (save_p)
-	      insn = emit_insn (gen_fr_spill (mem,
-					      gen_rtx_REG (XFmode, regno)));
-	    else
-	      insn = emit_insn (gen_fr_restore (gen_rtx_REG (XFmode, regno),
-						mem));
-	    if (save_p)
-	      RTX_FRAME_RELATED_P (insn) = 1;
-	  }
+  /* ??? Not all of the spills are for varargs, but some of them are.
+     The rest of the spills belong in an alias set of their own.  But
+     it doesn't actually hurt to include them here.  */
+  MEM_ALIAS_SET (mem) = get_varargs_alias_set ();
 
-      for (regno = BR_REG (0); regno <= BR_REG (7); regno++)
-	if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
-	  {
-	    rtx src, dest;
+  spill_fill_data.prev_addr[iter] = &XEXP (mem, 0);
+  spill_fill_data.prev_off[iter] = cfa_off;
 
-	    if (save_p)
-	      {
-		src = gen_rtx_REG (DImode, regno);
-		dest = gen_rtx_MEM (DImode, tmp_post_inc);
-	      }
-	    else
-	      {
-		src = gen_rtx_MEM (DImode, tmp_post_inc);
-		dest = gen_rtx_REG (DImode, regno);
-	      }
+  if (++iter >= spill_fill_data.n_iter)
+    iter = 0;
+  spill_fill_data.next_iter = iter;
 
-	    insn = emit_insn (gen_movdi (tmp2_reg, src));
-	    if (save_p)
-	      RTX_FRAME_RELATED_P (insn) = 1;
-	    insn = emit_insn (gen_movdi (dest, tmp2_reg));
-	    if (save_p)
-	      RTX_FRAME_RELATED_P (insn) = 1;
-	  }
+  return mem;
+}
 
-      if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_LC_REGNUM))
-	{
-	  rtx src, dest;
+static void
+do_spill (move_fn, reg, cfa_off, frame_reg)
+     rtx (*move_fn) PARAMS ((rtx, rtx, rtx));
+     rtx reg, frame_reg;
+     HOST_WIDE_INT cfa_off;
+{
+  rtx mem, insn;
 
-	  if (save_p)
-	    {
-	      src = gen_rtx_REG (DImode, AR_LC_REGNUM);
-	      dest = gen_rtx_MEM (DImode, tmp_post_inc);
-	    }
-	  else
-	    {
-	      src = gen_rtx_MEM (DImode, tmp_post_inc);
-	      dest = gen_rtx_REG (DImode, AR_LC_REGNUM);
-	    }
+  mem = spill_restore_mem (reg, cfa_off);
+  insn = emit_insn ((*move_fn) (mem, reg, GEN_INT (cfa_off)));
+
+  if (frame_reg)
+    {
+      rtx base;
+      HOST_WIDE_INT off;
 
-	  insn = emit_insn (gen_movdi (tmp2_reg, src));
-	  if (save_p)
-	    RTX_FRAME_RELATED_P (insn) = 1;
-	  insn = emit_insn (gen_movdi (dest, tmp2_reg));
-	  if (save_p)
-	    RTX_FRAME_RELATED_P (insn) = 1;
+      RTX_FRAME_RELATED_P (insn) = 1;
+
+      /* Don't even pretend that the unwind code can intuit its way 
+	 through a pair of interleaved post_modify iterators.  Just
+	 provide the correct answer.  */
+
+      if (frame_pointer_needed)
+	{
+	  base = hard_frame_pointer_rtx;
+	  off = - cfa_off;
+	}
+      else
+	{
+	  base = stack_pointer_rtx;
+	  off = current_frame_info.total_size - cfa_off;
 	}
+
+      REG_NOTES (insn)
+	= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,
+		gen_rtx_SET (VOIDmode,
+			     gen_rtx_MEM (GET_MODE (reg),
+					  plus_constant (base, off)),
+			     frame_reg),
+		REG_NOTES (insn));
     }
 }
 
+static void
+do_restore (move_fn, reg, cfa_off)
+     rtx (*move_fn) PARAMS ((rtx, rtx, rtx));
+     rtx reg;
+     HOST_WIDE_INT cfa_off;
+{
+  emit_insn ((*move_fn) (reg, spill_restore_mem (reg, cfa_off),
+			 GEN_INT (cfa_off)));
+}
+
+/* Wrapper functions that discards the CONST_INT spill offset.  These
+   exist so that we can give gr_spill/gr_fill the offset they need and
+   use a consistant function interface.  */
+
+static rtx
+gen_movdi_x (dest, src, offset)
+     rtx dest, src;
+     rtx offset ATTRIBUTE_UNUSED;
+{
+  return gen_movdi (dest, src);
+}
+
+static rtx
+gen_fr_spill_x (dest, src, offset)
+     rtx dest, src;
+     rtx offset ATTRIBUTE_UNUSED;
+{
+  return gen_fr_spill (dest, src);
+}
+
+static rtx
+gen_fr_restore_x (dest, src, offset)
+     rtx dest, src;
+     rtx offset ATTRIBUTE_UNUSED;
+{
+  return gen_fr_restore (dest, src);
+}
 
 /* Called after register allocation to add any instructions needed for the
    prologue.  Using a prologue insn is favored compared to putting all of the
@@ -1023,33 +1673,37 @@ save_restore_insns (save_p)
    insn to prevent such scheduling.
 
    Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1
-   so that the debug info generation code can handle them properly.  */
+   so that the debug info generation code can handle them properly.
+
+   The register save area is layed out like so:
+   cfa+16
+	[ varargs spill area ]
+	[ fr register spill area ]
+	[ br register spill area ]
+	[ ar register spill area ]
+	[ pr register spill area ]
+	[ gr register spill area ] */
 
 /* ??? Get inefficient code when the frame size is larger than can fit in an
    adds instruction.  */
 
-/* ??? If this is a leaf function, then fp/rp/ar.pfs should be put in the
-   low 32 regs.  */
-
-/* ??? Should not reserve a local register for rp/ar.pfs.  Should
-   instead check to see if any local registers are unused, and if so,
-   allocate them to rp/ar.pfs in that order.  Not sure what to do about
-   fp, we may still need to reserve a local register for it.  */
-
 void
 ia64_expand_prologue ()
 {
-  rtx insn, offset;
-  int i, locals, inputs, outputs, rotates;
-  int frame_size = ia64_compute_frame_size (get_frame_size ());
-  int epilogue_p;
-  edge e;
-
-  /* If there is no epilogue, then we don't need some prologue insns.  We
-     need to avoid emitting the dead prologue insns, because flow will complain
-     about them.  */
+  rtx insn, ar_pfs_save_reg, ar_unat_save_reg;
+  int i, epilogue_p, regno, alt_regno, cfa_off, n_varargs;
+  rtx reg, alt_reg;
+
+  ia64_compute_frame_size (get_frame_size ());
+  last_scratch_gr_reg = 15;
+
+  /* If there is no epilogue, then we don't need some prologue insns.
+     We need to avoid emitting the dead prologue insns, because flow
+     will complain about them.  */
   if (optimize)
     {
+      edge e;
+
       for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)
 	if ((e->flags & EDGE_FAKE) == 0
 	    && (e->flags & EDGE_FALLTHRU) != 0)
@@ -1059,193 +1713,309 @@ ia64_expand_prologue ()
   else
     epilogue_p = 1;
 
-  /* Find the highest local register used.  */
-  /* We have only 80 local registers, because we reserve 8 for the inputs
-     and 8 for the outputs.  */
+  /* Set the local, input, and output register names.  We need to do this
+     for GNU libc, which creates crti.S/crtn.S by splitting initfini.c in
+     half.  If we use in/loc/out register names, then we get assembler errors
+     in crtn.S because there is no alloc insn or regstk directive in there.  */
+  if (! TARGET_REG_NAMES)
+    {
+      int inputs = current_frame_info.n_input_regs;
+      int locals = current_frame_info.n_local_regs;
+      int outputs = current_frame_info.n_output_regs;
+
+      for (i = 0; i < inputs; i++)
+	reg_names[IN_REG (i)] = ia64_reg_numbers[i];
+      for (i = 0; i < locals; i++)
+	reg_names[LOC_REG (i)] = ia64_reg_numbers[inputs + i];
+      for (i = 0; i < outputs; i++)
+	reg_names[OUT_REG (i)] = ia64_reg_numbers[inputs + locals + i];
+    }
+
+  /* Set the frame pointer register name.  The regnum is logically loc79,
+     but of course we'll not have allocated that many locals.  Rather than
+     worrying about renumbering the existing rtxs, we adjust the name.  */
+  if (current_frame_info.reg_fp)
+    {
+      const char *tmp = reg_names[HARD_FRAME_POINTER_REGNUM];
+      reg_names[HARD_FRAME_POINTER_REGNUM]
+	= reg_names[current_frame_info.reg_fp];
+      reg_names[current_frame_info.reg_fp] = tmp;
+    }
+
+  /* Fix up the return address placeholder.  */
+  /* ??? We can fail if __builtin_return_address is used, and we didn't
+     allocate a register in which to save b0.  I can't think of a way to
+     eliminate RETURN_ADDRESS_POINTER_REGNUM to a local register and
+     then be sure that I got the right one.  Further, reload doesn't seem
+     to care if an eliminable register isn't used, and "eliminates" it
+     anyway.  */
+  if (regs_ever_live[RETURN_ADDRESS_POINTER_REGNUM]
+      && current_frame_info.reg_save_b0 != 0)
+    XINT (return_address_pointer_rtx, 0) = current_frame_info.reg_save_b0;
+
+  /* We don't need an alloc instruction if we've used no outputs or locals.  */
+  if (current_frame_info.n_local_regs == 0
+      && current_frame_info.n_output_regs == 0)
+    {
+      /* If there is no alloc, but there are input registers used, then we
+	 need a .regstk directive.  */
+      current_frame_info.need_regstk = (TARGET_REG_NAMES != 0);
+      ar_pfs_save_reg = NULL_RTX;
+    }
+  else
+    {
+      current_frame_info.need_regstk = 0;
 
-  for (i = LOC_REG (79); i >= LOC_REG (0); i--)
-    if (regs_ever_live[i])
-      break;
-  locals = i - LOC_REG (0) + 1;
+      if (current_frame_info.reg_save_ar_pfs)
+	regno = current_frame_info.reg_save_ar_pfs;
+      else
+	regno = next_scratch_gr_reg ();
+      ar_pfs_save_reg = gen_rtx_REG (DImode, regno);
 
-  /* Likewise for inputs.  */
+      insn = emit_insn (gen_alloc (ar_pfs_save_reg, 
+				   GEN_INT (current_frame_info.n_input_regs),
+				   GEN_INT (current_frame_info.n_local_regs),
+				   GEN_INT (current_frame_info.n_output_regs),
+				   GEN_INT (current_frame_info.n_rotate_regs)));
+      RTX_FRAME_RELATED_P (insn) = (current_frame_info.reg_save_ar_pfs != 0);
+    }
+
+  /* Set up frame pointer, stack pointer, and spill iterators.  */
+
+  n_varargs = cfun->machine->n_varargs;
+  setup_spill_pointers (current_frame_info.n_spilled + n_varargs,
+			stack_pointer_rtx, 0);
 
-  for (i = IN_REG (7); i >= IN_REG (0); i--)
-    if (regs_ever_live[i])
-      break;
-  inputs = i - IN_REG (0) + 1;
+  if (frame_pointer_needed)
+    {
+      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
 
-#if 0
-  /* If the function was declared with syscall_linkage, then we may need to
-     preserve all declared input registers, even if they weren't used.
-     Currently, syscall_linkage does not have this effect.  */
-
-  if (lookup_attribute ("syscall_linkage",
-			TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))
-    inputs = MAX (inputs, current_function_args_info.words);
-#endif
+  if (current_frame_info.total_size != 0)
+    {
+      rtx frame_size_rtx = GEN_INT (- current_frame_info.total_size);
+      rtx offset;
 
-  /* Likewise for outputs.  */
+      if (CONST_OK_FOR_I (- current_frame_info.total_size))
+	offset = frame_size_rtx;
+      else
+	{
+	  regno = next_scratch_gr_reg ();
+ 	  offset = gen_rtx_REG (DImode, regno);
+	  emit_move_insn (offset, frame_size_rtx);
+	}
 
-  for (i = OUT_REG (7); i >= OUT_REG (0); i--)
-    if (regs_ever_live[i])
-      break;
-  outputs = i - OUT_REG (0) + 1;
+      insn = emit_insn (gen_adddi3 (stack_pointer_rtx,
+				    stack_pointer_rtx, offset));
 
-  /* When -p profiling, we need one output register for the mcount argument.
-     Likwise for -a profiling for the bb_init_func argument.  For -ax
-     profiling, we need two output registers for the two bb_init_trace_func
-     arguments.  */
-  if (profile_flag || profile_block_flag == 1)
-    outputs = MAX (outputs, 1);
-  else if (profile_block_flag == 2)
-    outputs = MAX (outputs, 2);
+      if (! frame_pointer_needed)
+	{
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	  if (GET_CODE (offset) != CONST_INT)
+	    {
+	      REG_NOTES (insn)
+		= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,
+			gen_rtx_SET (VOIDmode,
+				     stack_pointer_rtx,
+				     gen_rtx_PLUS (DImode,
+						   stack_pointer_rtx,
+						   frame_size_rtx)),
+			REG_NOTES (insn));
+	    }
+	}
 
-  /* No rotating register support as yet.  */
+      /* ??? At this point we must generate a magic insn that appears to
+	 modify the stack pointer, the frame pointer, and all spill
+	 iterators.  This would allow the most scheduling freedom.  For
+	 now, just hard stop.  */
+      emit_insn (gen_blockage ());
+    }
 
-  rotates = 0;
+  /* Must copy out ar.unat before doing any integer spills.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM))
+    {
+      if (current_frame_info.reg_save_ar_unat)
+	ar_unat_save_reg
+	  = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_unat);
+      else
+	{
+	  alt_regno = next_scratch_gr_reg ();
+	  ar_unat_save_reg = gen_rtx_REG (DImode, alt_regno);
+	  current_frame_info.gr_used_mask |= 1 << alt_regno;
+	}
 
-  /* Allocate two extra locals for saving/restoring rp and ar.pfs.  Also
-     allocate one local for use as the frame pointer if frame_pointer_needed
-     is true.  */
-  /* ??? If this is a leaf function, then we aren't using one of these local
-     registers for the RP anymore.  */
-  locals += 2 + frame_pointer_needed;
-
-  /* Save these values in global registers for debugging info.  */
-  ia64_input_regs = inputs;
-  ia64_local_regs = locals;
+      reg = gen_rtx_REG (DImode, AR_UNAT_REGNUM);
+      insn = emit_move_insn (ar_unat_save_reg, reg);
+      RTX_FRAME_RELATED_P (insn) = (current_frame_info.reg_save_ar_unat != 0);
+
+      /* Even if we're not going to generate an epilogue, we still
+	 need to save the register so that EH works.  */
+      if (! epilogue_p && current_frame_info.reg_save_ar_unat)
+	emit_insn (gen_rtx_USE (VOIDmode, ar_unat_save_reg));
+    }
+  else
+    ar_unat_save_reg = NULL_RTX;
 
-  /* Set the local, input, and output register names.  We need to do this
-     for GNU libc, which creates crti.S/crtn.S by splitting initfini.c in
-     half.  If we use in/loc/out register names, then we get assembler errors
-     in crtn.S because there is no alloc insn or regstk directive in there.
-     We give in/loc/out names to unused registers, to make invalid uses of
-     them easy to spot.  */
-  if (! TARGET_REG_NAMES)
+  /* Spill all varargs registers.  Do this before spilling any GR registers,
+     since we want the UNAT bits for the GR registers to override the UNAT
+     bits from varargs, which we don't care about.  */
+
+  cfa_off = -16;
+  for (regno = GR_ARG_FIRST + 7; n_varargs > 0; --n_varargs, --regno)
     {
-      for (i = 0; i < 8; i++)
-	{
-	  if (i < inputs)
-	    reg_names[IN_REG (i)] = ia64_reg_numbers[i];
-	  else
-	    reg_names[IN_REG (i)] = ia64_input_reg_names[i];
-	}
-      for (i = 0; i < 80; i++)
+      reg = gen_rtx_REG (DImode, regno);
+      do_spill (gen_gr_spill, reg, cfa_off += 8, NULL_RTX);
+    }
+
+  /* Locate the bottom of the register save area.  */
+  cfa_off = (current_frame_info.spill_cfa_off
+	     + current_frame_info.spill_size
+	     + current_frame_info.extra_spill_size);
+
+  /* Save the predicate register block either in a register or in memory.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, PR_REG (0)))
+    {
+      reg = gen_rtx_REG (DImode, PR_REG (0));
+      if (current_frame_info.reg_save_pr != 0)
 	{
-	  if (i < locals)
-	    reg_names[LOC_REG (i)] = ia64_reg_numbers[inputs + i];
-	  else
-	    reg_names[LOC_REG (i)] = ia64_local_reg_names[i];
+	  alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_pr);
+	  insn = emit_move_insn (alt_reg, reg);
+
+	  /* ??? Denote pr spill/fill by a DImode move that modifies all
+	     64 hard registers.  */
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	  REG_NOTES (insn)
+	    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,
+			gen_rtx_SET (VOIDmode, alt_reg, reg),
+			REG_NOTES (insn));
+
+	  /* Even if we're not going to generate an epilogue, we still
+	     need to save the register so that EH works.  */
+	  if (! epilogue_p)
+	    emit_insn (gen_rtx_USE (VOIDmode, alt_reg));
 	}
-      for (i = 0; i < 8; i++)
+      else
 	{
-	  if (i < outputs)
-	    reg_names[OUT_REG (i)] = ia64_reg_numbers[inputs + locals + i];
-	  else
-	    reg_names[OUT_REG (i)] = ia64_output_reg_names[i];
+	  alt_regno = next_scratch_gr_reg ();
+	  alt_reg = gen_rtx_REG (DImode, alt_regno);
+	  insn = emit_move_insn (alt_reg, reg);
+	  do_spill (gen_movdi_x, alt_reg, cfa_off, reg);
+	  cfa_off -= 8;
 	}
     }
 
-  /* Set the frame pointer register name now that it is known, and the
-     local register names are known.  */
-  if (frame_pointer_needed)
+  /* Handle AR regs in numerical order.  All of them get special handling.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM)
+      && current_frame_info.reg_save_ar_unat == 0)
     {
-      reg_names[FRAME_POINTER_REGNUM]
-	= reg_names[LOC_REG (locals - 3)];
-      ia64_fp_regno = LOC_REG (inputs + locals - 3);
+      reg = gen_rtx_REG (DImode, AR_UNAT_REGNUM);
+      do_spill (gen_movdi_x, ar_unat_save_reg, cfa_off, reg);
+      cfa_off -= 8;
     }
-  else
-    ia64_fp_regno = 0;
 
-  /* We don't need an alloc instruction if this is a leaf function, and the
-     locals and outputs are both zero sized.  Since we have already allocated
-     two locals for rp and ar.pfs, we check for two locals.  */
-  /* Leaf functions can use output registers as call-clobbered temporaries.  */
-  if (locals == 2 && outputs == 0 && current_function_is_leaf)
+  /* The alloc insn already copied ar.pfs into a general register.  The
+     only thing we have to do now is copy that register to a stack slot
+     if we'd not allocated a local register for the job.  */
+  if (current_frame_info.reg_save_ar_pfs == 0
+      && ! current_function_is_leaf)
     {
-      /* If there is no alloc, but there are input registers used, then we
-	 need a .regstk directive.  */
-      if (TARGET_REG_NAMES)
-	ia64_need_regstk = 1;
-      else
-	ia64_need_regstk = 0;
-
-      ia64_arpfs_regno = 0;
-      ia64_rp_regno = 0;
+      reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);
+      do_spill (gen_movdi_x, ar_pfs_save_reg, cfa_off, reg);
+      cfa_off -= 8;
     }
-  else
-    {
-      ia64_need_regstk = 0;
-      ia64_arpfs_regno = LOC_REG (locals - 1);
-
-      insn = emit_insn (gen_alloc (gen_rtx_REG (DImode, ia64_arpfs_regno),
-				   GEN_INT (inputs), GEN_INT (locals),
-				   GEN_INT (outputs), GEN_INT (rotates)));
-      RTX_FRAME_RELATED_P (insn) = 1;
 
-      /* Emit a save of BR_REG (0) if we call other functions.
-	 Do this even if this function doesn't return, as EH
-         depends on this to be able to unwind the stack.  */
-      if (! current_function_is_leaf)
-	{
-	  rtx ia64_rp_reg;
-
-	  ia64_rp_regno = LOC_REG (locals - 2);
-	  ia64_rp_reg = gen_rtx_REG (DImode, ia64_rp_regno);
-	  insn = emit_move_insn (ia64_rp_reg, gen_rtx_REG (DImode,
-							   BR_REG (0)));
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_LC_REGNUM))
+    {
+      reg = gen_rtx_REG (DImode, AR_LC_REGNUM);
+      if (current_frame_info.reg_save_ar_lc != 0)
+	{
+	  alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_lc);
+	  insn = emit_move_insn (alt_reg, reg);
 	  RTX_FRAME_RELATED_P (insn) = 1;
-	  if (! epilogue_p)
-	    {
-	      /* If we don't have an epilogue, then the return value
-		 doesn't appear to be needed and the above store will
-		 appear dead and will elicit a warning from flow.  */
-	      emit_insn (gen_rtx_USE (VOIDmode, ia64_rp_reg));
-	    }
 
-	  /* Fix up the return address placeholder.  */
-	  if (regs_ever_live[RETURN_ADDRESS_POINTER_REGNUM])
-	    XINT (return_address_pointer_rtx, 0) = ia64_rp_regno;
+	  /* Even if we're not going to generate an epilogue, we still
+	     need to save the register so that EH works.  */
+	  if (! epilogue_p)
+	    emit_insn (gen_rtx_USE (VOIDmode, alt_reg));
 	}
       else
-	ia64_rp_regno = 0;
+	{
+	  alt_regno = next_scratch_gr_reg ();
+	  alt_reg = gen_rtx_REG (DImode, alt_regno);
+	  emit_move_insn (alt_reg, reg);
+	  do_spill (gen_movdi_x, alt_reg, cfa_off, reg);
+	  cfa_off -= 8;
+	}
     }
 
-  /* Set up frame pointer and stack pointer.  */
-  if (frame_pointer_needed)
-    {
-      insn = emit_insn (gen_movdi (hard_frame_pointer_rtx, stack_pointer_rtx));
-      RTX_FRAME_RELATED_P (insn) = 1;
-    }
-  if (frame_size != 0)
+  /* We should now be at the base of the gr/br/fr spill area.  */
+  if (cfa_off != (current_frame_info.spill_cfa_off
+		  + current_frame_info.spill_size))
+    abort ();
+
+  /* Spill all general registers.  */
+  for (regno = GR_REG (1); regno <= GR_REG (31); ++regno)
+    if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
+      {
+	reg = gen_rtx_REG (DImode, regno);
+	do_spill (gen_gr_spill, reg, cfa_off, reg);
+	cfa_off -= 8;
+      }
+
+  /* Handle BR0 specially -- it may be getting stored permanently in
+     some GR register.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, BR_REG (0)))
     {
-      if (CONST_OK_FOR_I (-frame_size))
-	offset = GEN_INT (-frame_size);
-      else
+      reg = gen_rtx_REG (DImode, BR_REG (0));
+      if (current_frame_info.reg_save_b0 != 0)
 	{
-	  /* ??? We use r2 to tell process_set that this is a stack pointer
-	     decrement.  See also ia64_expand_epilogue.  */
-	  offset = gen_rtx_REG (DImode, GR_REG (2));
-	  insn = emit_insn (gen_movdi (offset, GEN_INT (-frame_size)));
+	  alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_b0);
+	  insn = emit_move_insn (alt_reg, reg);
 	  RTX_FRAME_RELATED_P (insn) = 1;
+
+	  /* Even if we're not going to generate an epilogue, we still
+	     need to save the register so that EH works.  */
+	  if (! epilogue_p)
+	    emit_insn (gen_rtx_USE (VOIDmode, alt_reg));
 	}
-      /* If there is a frame pointer, then we need to make the stack pointer
-	 decrement depend on the frame pointer, so that the stack pointer
-	 update won't be moved past fp-relative stores to the frame.  */
-      if (frame_pointer_needed)
-	insn = emit_insn (gen_prologue_allocate_stack (stack_pointer_rtx,
-						       stack_pointer_rtx,
-						       offset,
-						       hard_frame_pointer_rtx));
       else
-	insn = emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,
-				      offset));
-      RTX_FRAME_RELATED_P (insn) = 1;
+	{
+	  alt_regno = next_scratch_gr_reg ();
+	  alt_reg = gen_rtx_REG (DImode, alt_regno);
+	  emit_move_insn (alt_reg, reg);
+	  do_spill (gen_movdi_x, alt_reg, cfa_off, reg);
+	  cfa_off -= 8;
+	}
     }
 
-  /* Save registers to frame.  */
-  save_restore_insns (1);
+  /* Spill the rest of the BR registers.  */
+  for (regno = BR_REG (1); regno <= BR_REG (7); ++regno)
+    if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
+      {
+	alt_regno = next_scratch_gr_reg ();
+	alt_reg = gen_rtx_REG (DImode, alt_regno);
+	reg = gen_rtx_REG (DImode, regno);
+	emit_move_insn (alt_reg, reg);
+	do_spill (gen_movdi_x, alt_reg, cfa_off, reg);
+	cfa_off -= 8;
+      }
+
+  /* Align the frame and spill all FR registers.  */
+  for (regno = FR_REG (2); regno <= FR_REG (127); ++regno)
+    if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
+      {
+        if (cfa_off & 15)
+	  abort ();
+	reg = gen_rtx_REG (TFmode, regno);
+	do_spill (gen_fr_spill_x, reg, cfa_off, reg);
+	cfa_off -= 16;
+      }
+
+  if (cfa_off != current_frame_info.spill_cfa_off)
+    abort ();
+
+  finish_spill_pointers ();
 }
 
 /* Called after register allocation to add any instructions needed for the
@@ -1258,74 +2028,241 @@ ia64_expand_prologue ()
 void
 ia64_expand_epilogue ()
 {
-  rtx insn;
+  rtx insn, reg, alt_reg, ar_unat_save_reg;
+  int regno, alt_regno, cfa_off;
+
+  ia64_compute_frame_size (get_frame_size ());
+
+  /* If there is a frame pointer, then we use it instead of the stack
+     pointer, so that the stack pointer does not need to be valid when
+     the epilogue starts.  See EXIT_IGNORE_STACK.  */
+  if (frame_pointer_needed)
+    setup_spill_pointers (current_frame_info.n_spilled,
+			  hard_frame_pointer_rtx, 0);
+  else
+    setup_spill_pointers (current_frame_info.n_spilled, stack_pointer_rtx, 
+			  current_frame_info.total_size);
+
+  if (current_frame_info.total_size != 0)
+    {
+      /* ??? At this point we must generate a magic insn that appears to
+         modify the spill iterators and the frame pointer.  This would
+	 allow the most scheduling freedom.  For now, just hard stop.  */
+      emit_insn (gen_blockage ());
+    }
+
+  /* Locate the bottom of the register save area.  */
+  cfa_off = (current_frame_info.spill_cfa_off
+	     + current_frame_info.spill_size
+	     + current_frame_info.extra_spill_size);
+
+  /* Restore the predicate registers.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, PR_REG (0)))
+    {
+      if (current_frame_info.reg_save_pr != 0)
+	alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_pr);
+      else
+	{
+	  alt_regno = next_scratch_gr_reg ();
+	  alt_reg = gen_rtx_REG (DImode, alt_regno);
+	  do_restore (gen_movdi_x, alt_reg, cfa_off);
+	  cfa_off -= 8;
+	}
+      reg = gen_rtx_REG (DImode, PR_REG (0));
+      emit_move_insn (reg, alt_reg);
+    }
 
-  /* Restore registers from frame.  */
-  save_restore_insns (0);
+  /* Restore the application registers.  */
 
-  /* ??? The gen_epilogue_deallocate_stack call below does not work.  This
-     is mainly because there is no fp+offset addressing mode, so most loads
-     from the frame do not actually use the frame pointer; they use a pseudo
-     computed from the frame pointer.  The same problem exists with the
-     stack pointer when there is no frame pointer.  I think this can be
-     fixed only by making the dependency analysis code in sched smarter, so
-     that it recognizes references to the frame, and makes succeeding stack
-     pointer updates anti-dependent on them.  */
-  emit_insn (gen_blockage ());
+  /* Load the saved unat from the stack, but do not restore it until
+     after the GRs have been restored.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM))
+    {
+      if (current_frame_info.reg_save_ar_unat != 0)
+        ar_unat_save_reg
+	  = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_unat);
+      else
+	{
+	  alt_regno = next_scratch_gr_reg ();
+	  ar_unat_save_reg = gen_rtx_REG (DImode, alt_regno);
+	  current_frame_info.gr_used_mask |= 1 << alt_regno;
+	  do_restore (gen_movdi_x, ar_unat_save_reg, cfa_off);
+	  cfa_off -= 8;
+	}
+    }
+  else
+    ar_unat_save_reg = NULL_RTX;
+      
+  if (current_frame_info.reg_save_ar_pfs != 0)
+    {
+      alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_pfs);
+      reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);
+      emit_move_insn (reg, alt_reg);
+    }
+  else if (! current_function_is_leaf)
+    {
+      alt_regno = next_scratch_gr_reg ();
+      alt_reg = gen_rtx_REG (DImode, alt_regno);
+      do_restore (gen_movdi_x, alt_reg, cfa_off);
+      cfa_off -= 8;
+      reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);
+      emit_move_insn (reg, alt_reg);
+    }
 
-  if (cfun->machine->ia64_eh_epilogue_sp == NULL_RTX)
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_LC_REGNUM))
     {
-    if (frame_pointer_needed)
+      if (current_frame_info.reg_save_ar_lc != 0)
+	alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_ar_lc);
+      else
+	{
+	  alt_regno = next_scratch_gr_reg ();
+	  alt_reg = gen_rtx_REG (DImode, alt_regno);
+	  do_restore (gen_movdi_x, alt_reg, cfa_off);
+	  cfa_off -= 8;
+	}
+      reg = gen_rtx_REG (DImode, AR_LC_REGNUM);
+      emit_move_insn (reg, alt_reg);
+    }
+
+  /* We should now be at the base of the gr/br/fr spill area.  */
+  if (cfa_off != (current_frame_info.spill_cfa_off
+		  + current_frame_info.spill_size))
+    abort ();
+
+  /* Restore all general registers.  */
+  for (regno = GR_REG (1); regno <= GR_REG (31); ++regno)
+    if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
       {
-	/* If there is a frame pointer, then we need to make the stack pointer
-	   restore depend on the frame pointer, so that the stack pointer
-	   restore won't be moved up past fp-relative loads from the frame.  */
-	insn
-	  = emit_insn (gen_epilogue_deallocate_stack (stack_pointer_rtx,
-						      hard_frame_pointer_rtx));
-	RTX_FRAME_RELATED_P (insn) = 1;
+	reg = gen_rtx_REG (DImode, regno);
+	do_restore (gen_gr_restore, reg, cfa_off);
+	cfa_off -= 8;
       }
-    else
+  
+  /* Restore the branch registers.  Handle B0 specially, as it may
+     have gotten stored in some GR register.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, BR_REG (0)))
+    {
+      if (current_frame_info.reg_save_b0 != 0)
+	alt_reg = gen_rtx_REG (DImode, current_frame_info.reg_save_b0);
+      else
+	{
+	  alt_regno = next_scratch_gr_reg ();
+	  alt_reg = gen_rtx_REG (DImode, alt_regno);
+	  do_restore (gen_movdi_x, alt_reg, cfa_off);
+	  cfa_off -= 8;
+	}
+      reg = gen_rtx_REG (DImode, BR_REG (0));
+      emit_move_insn (reg, alt_reg);
+    }
+    
+  for (regno = BR_REG (1); regno <= BR_REG (7); ++regno)
+    if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
       {
-	int frame_size = current_frame_info.total_size;
-	rtx offset;
+	alt_regno = next_scratch_gr_reg ();
+	alt_reg = gen_rtx_REG (DImode, alt_regno);
+	do_restore (gen_movdi_x, alt_reg, cfa_off);
+	cfa_off -= 8;
+	reg = gen_rtx_REG (DImode, regno);
+	emit_move_insn (reg, alt_reg);
+      }
 
-	if (frame_size != 0)
-	  {
-	    if (CONST_OK_FOR_I (frame_size))
-	      offset = GEN_INT (frame_size);
-	    else
-	      {
-		/* ??? We use r3 to tell process_set that this is a stack
-		   pointer increment.  See also ia64_expand_prologue.  */
-		offset = gen_rtx_REG (DImode, GR_REG (3));
-		emit_insn (gen_movdi (offset, GEN_INT (frame_size)));
-	      }
-	    insn = emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,
-					  offset));
-	    RTX_FRAME_RELATED_P (insn) = 1;
-	  }
+  /* Restore floating point registers.  */
+  for (regno = FR_REG (2); regno <= FR_REG (127); ++regno)
+    if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))
+      {
+        if (cfa_off & 15)
+	  abort ();
+	reg = gen_rtx_REG (TFmode, regno);
+	do_restore (gen_fr_restore_x, reg, cfa_off);
+	cfa_off -= 16;
       }
+
+  /* Restore ar.unat for real.  */
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM))
+    {
+      reg = gen_rtx_REG (DImode, AR_UNAT_REGNUM);
+      emit_move_insn (reg, ar_unat_save_reg);
     }
-    /* Return via eh_epilogue, so we already have our new stack pointer.  */
-  else
-    emit_insn (gen_movdi (stack_pointer_rtx, cfun->machine->ia64_eh_epilogue_sp));
 
-  if (ia64_arpfs_regno)
-    emit_insn (gen_pfs_restore (gen_rtx_REG (DImode, ia64_arpfs_regno)));
+  if (cfa_off != current_frame_info.spill_cfa_off)
+    abort ();
+
+  finish_spill_pointers ();
 
-  if (ia64_rp_regno)
-    emit_move_insn (gen_rtx_REG (DImode, BR_REG (0)),
-		    gen_rtx_REG (DImode, ia64_rp_regno));
+  if (current_frame_info.total_size || cfun->machine->ia64_eh_epilogue_sp)
+    {
+      /* ??? At this point we must generate a magic insn that appears to
+         modify the spill iterators, the stack pointer, and the frame
+	 pointer.  This would allow the most scheduling freedom.  For now,
+	 just hard stop.  */
+      emit_insn (gen_blockage ());
+    }
 
-  if (cfun->machine->ia64_eh_epilogue_bsp != NULL_RTX)
+  if (cfun->machine->ia64_eh_epilogue_sp)
+    emit_move_insn (stack_pointer_rtx, cfun->machine->ia64_eh_epilogue_sp);
+  else if (frame_pointer_needed)
+    {
+      insn = emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
+  else if (current_frame_info.total_size)
     {
-      /* We have to restore the bsp.  */
-      emit_insn (gen_set_bsp (cfun->machine->ia64_eh_epilogue_bsp));
+      rtx offset, frame_size_rtx;
+
+      frame_size_rtx = GEN_INT (current_frame_info.total_size);
+      if (CONST_OK_FOR_I (current_frame_info.total_size))
+	offset = frame_size_rtx;
+      else
+	{
+	  regno = next_scratch_gr_reg ();
+	  offset = gen_rtx_REG (DImode, regno);
+	  emit_move_insn (offset, frame_size_rtx);
+	}
+
+      insn = emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,
+				    offset));
+
+      RTX_FRAME_RELATED_P (insn) = 1;
+      if (GET_CODE (offset) != CONST_INT)
+	{
+	  REG_NOTES (insn)
+	    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,
+			gen_rtx_SET (VOIDmode,
+				     stack_pointer_rtx,
+				     gen_rtx_PLUS (DImode,
+						   stack_pointer_rtx,
+						   frame_size_rtx)),
+			REG_NOTES (insn));
+	}
     }
+
+  if (cfun->machine->ia64_eh_epilogue_bsp)
+    emit_insn (gen_set_bsp (cfun->machine->ia64_eh_epilogue_bsp));
+ 
   emit_jump_insn (gen_return_internal (gen_rtx_REG (DImode, BR_REG (0))));
 }
 
+/* Return 1 if br.ret can do all the work required to return from a
+   function.  */
+
+int
+ia64_direct_return ()
+{
+  if (reload_completed && ! frame_pointer_needed)
+    {
+      ia64_compute_frame_size (get_frame_size ());
+
+      return (current_frame_info.total_size == 0
+	      && current_frame_info.n_spilled == 0
+	      && current_frame_info.reg_save_b0 == 0
+	      && current_frame_info.reg_save_pr == 0
+	      && current_frame_info.reg_save_ar_pfs == 0
+	      && current_frame_info.reg_save_ar_unat == 0
+	      && current_frame_info.reg_save_ar_lc == 0);
+    }
+  return 0;
+}
+
 /* Emit the function prologue.  */
 
 void
@@ -1333,39 +2270,66 @@ ia64_function_prologue (file, size)
      FILE *file;
      int size ATTRIBUTE_UNUSED;
 {
-  rtx insn;
-  if (ia64_need_regstk)
-    fprintf (file, "\t.regstk %d, 0, 0, 0\n", ia64_input_regs);
+  int mask, grsave, grsave_prev;
+
+  if (current_frame_info.need_regstk)
+    fprintf (file, "\t.regstk %d, %d, %d, %d\n",
+	     current_frame_info.n_input_regs,
+	     current_frame_info.n_local_regs,
+	     current_frame_info.n_output_regs,
+	     current_frame_info.n_rotate_regs);
 
   if (!flag_unwind_tables && (!flag_exceptions || exceptions_via_longjmp))
     return;
 
-  /* Emit the .prologue directive. in order to do this, we need to find
-     where the stack pointer is moved toa GR, if it is, and mark it.  */
+  /* Emit the .prologue directive.  */
 
-  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))
+  mask = 0;
+  grsave = grsave_prev = 0;
+  if (current_frame_info.reg_save_b0 != 0)
     {
-      if (RTX_FRAME_RELATED_P (insn) && GET_CODE (insn) == INSN)
-        {
-	  rtx pat = PATTERN (insn);
-	  if (GET_CODE (pat) == SET)
-	    {
-	      rtx dest = SET_DEST (pat);
-	      rtx src = SET_SRC (pat);
-	      if (GET_CODE (src) == REG && REGNO (src) == STACK_POINTER_REGNUM
-		  && GET_CODE (dest) == REG)
-		{
-		  int reg = REGNO (dest);
-		  if (REGNO (dest) == FRAME_POINTER_REGNUM)
-		    reg = ia64_fp_regno;
-		  fprintf (file, "\t.prologue 0x2, %d\n", reg);
-		  break;
-		}
-	    }
-        }
+      mask |= 8;
+      grsave = grsave_prev = current_frame_info.reg_save_b0;
     }
-  if (insn == NULL_RTX)
-    fprintf (file, "\t.prologue\n");
+  if (current_frame_info.reg_save_ar_pfs != 0
+      && (grsave_prev == 0
+	  || current_frame_info.reg_save_ar_pfs == grsave_prev + 1))
+    {
+      mask |= 4;
+      if (grsave_prev == 0)
+	grsave = current_frame_info.reg_save_ar_pfs;
+      grsave_prev = current_frame_info.reg_save_ar_pfs;
+    }
+  if (current_frame_info.reg_fp != 0
+      && (grsave_prev == 0
+	  || current_frame_info.reg_fp == grsave_prev + 1))
+    {
+      mask |= 2;
+      if (grsave_prev == 0)
+	grsave = HARD_FRAME_POINTER_REGNUM;
+      grsave_prev = current_frame_info.reg_fp;
+    }
+  if (current_frame_info.reg_save_pr != 0
+      && (grsave_prev == 0
+	  || current_frame_info.reg_save_pr == grsave_prev + 1))
+    {
+      mask |= 1;
+      if (grsave_prev == 0)
+	grsave = current_frame_info.reg_save_pr;
+    }
+
+  if (mask)
+    fprintf (file, "\t.prologue %d, %d\n", mask,
+	     ia64_dbx_register_number (grsave));
+  else
+    fputs ("\t.prologue\n", file);
+
+  /* Emit a .spill directive, if necessary, to relocate the base of
+     the register spill area.  */
+  if (current_frame_info.spill_cfa_off != -16)
+    fprintf (file, "\t.spill %ld\n",
+	     (long) (current_frame_info.spill_cfa_off
+		     + current_frame_info.spill_size));
 }
 
 /* Emit the .body directive at the scheduled end of the prologue.  */
@@ -1387,53 +2351,106 @@ ia64_function_epilogue (file, size)
      FILE *file ATTRIBUTE_UNUSED;
      int size ATTRIBUTE_UNUSED;
 {
-}
+  /* Reset from the function's potential modifications.  */
+  XINT (return_address_pointer_rtx, 0) = RETURN_ADDRESS_POINTER_REGNUM;
 
-/* Return 1 if br.ret can do all the work required to return from a
-   function.  */
+  if (current_frame_info.reg_fp)
+    {
+      const char *tmp = reg_names[HARD_FRAME_POINTER_REGNUM];
+      reg_names[HARD_FRAME_POINTER_REGNUM]
+	= reg_names[current_frame_info.reg_fp];
+      reg_names[current_frame_info.reg_fp] = tmp;
+    }
+  if (! TARGET_REG_NAMES)
+    {
+      int i;
+
+      for (i = 0; i < current_frame_info.n_input_regs; i++)
+	reg_names[IN_REG (i)] = ia64_input_reg_names[i];
+      for (i = 0; i < current_frame_info.n_local_regs; i++)
+	reg_names[LOC_REG (i)] = ia64_local_reg_names[i];
+      for (i = 0; i < current_frame_info.n_output_regs; i++)
+	reg_names[OUT_REG (i)] = ia64_output_reg_names[i];
+    }
+  current_frame_info.initialized = 0;
+}
 
 int
-ia64_direct_return ()
+ia64_dbx_register_number (regno)
+     int regno;
 {
-  return (reload_completed && ! frame_pointer_needed
-	  && ia64_compute_frame_size (get_frame_size ()) == 0);
+  /* In ia64_expand_prologue we quite literally renamed the frame pointer
+     from its home at loc79 to something inside the register frame.  We
+     must perform the same renumbering here for the debug info.  */
+  if (current_frame_info.reg_fp)
+    {
+      if (regno == HARD_FRAME_POINTER_REGNUM)
+	regno = current_frame_info.reg_fp;
+      else if (regno == current_frame_info.reg_fp)
+	regno = HARD_FRAME_POINTER_REGNUM;
+    }
+
+  if (IN_REGNO_P (regno))
+    return 32 + regno - IN_REG (0);
+  else if (LOC_REGNO_P (regno))
+    return 32 + current_frame_info.n_input_regs + regno - LOC_REG (0);
+  else if (OUT_REGNO_P (regno))
+    return (32 + current_frame_info.n_input_regs
+	    + current_frame_info.n_local_regs + regno - OUT_REG (0));
+  else
+    return regno;
 }
 
+void
+ia64_initialize_trampoline (addr, fnaddr, static_chain)
+     rtx addr, fnaddr, static_chain;
+{
+  rtx addr_reg, eight = GEN_INT (8);
+
+  /* Load up our iterator.  */
+  addr_reg = gen_reg_rtx (Pmode);
+  emit_move_insn (addr_reg, addr);
+
+  /* The first two words are the fake descriptor:
+     __ia64_trampoline, ADDR+16.  */
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),
+		  gen_rtx_SYMBOL_REF (Pmode, "__ia64_trampoline"));
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg),
+		  copy_to_reg (plus_constant (addr, 16)));
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+
+  /* The third word is the target descriptor.  */
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), fnaddr);
+  emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));
+
+  /* The fourth word is the static chain.  */
+  emit_move_insn (gen_rtx_MEM (Pmode, addr_reg), static_chain);
+}
 
 /* Do any needed setup for a variadic function.  CUM has not been updated
-   for the last named argument which has type TYPE and mode MODE.  */
+   for the last named argument which has type TYPE and mode MODE.
+
+   We generate the actual spill instructions during prologue generation.  */
+
 void
 ia64_setup_incoming_varargs (cum, int_mode, type, pretend_size, second_time)
      CUMULATIVE_ARGS cum;
-     int             int_mode ATTRIBUTE_UNUSED;
-     tree            type ATTRIBUTE_UNUSED;
+     int             int_mode;
+     tree            type;
      int *           pretend_size;
-     int	     second_time;
+     int	     second_time ATTRIBUTE_UNUSED;
 {
-  /* If this is a stdarg function, then don't save the current argument.  */
-  int offset = ! current_function_varargs;
+  /* If this is a stdarg function, then skip the current argument.  */
+  if (! current_function_varargs)
+    ia64_function_arg_advance (&cum, int_mode, type, 1);
 
   if (cum.words < MAX_ARGUMENT_SLOTS)
     {
-      if (! second_time)
-	{
-	  int i;
-	  int first_reg = GR_ARG_FIRST + cum.words + offset;
-	  rtx reg1 = gen_reg_rtx (Pmode);
-	  rtx mem1 = gen_rtx_MEM (DImode, reg1);
-
-	  /* We must emit st8.spill insns instead of st8 because we might
-	     be saving non-argument registers, and non-argument registers
-	     might not contain valid values.  */
-	  emit_move_insn (reg1, virtual_incoming_args_rtx);
-	  for (i = first_reg; i < GR_ARG_FIRST + 8; i++)
-	    {
-	      emit_insn (gen_gr_spill (mem1, gen_rtx_REG (DImode, i)));
-	      emit_insn (gen_adddi3 (reg1, reg1, GEN_INT (8)));
-	    }
-	}
-      *pretend_size = ((MAX_ARGUMENT_SLOTS - cum.words - offset)
-		       * UNITS_PER_WORD);
+      int n = MAX_ARGUMENT_SLOTS - cum.words;
+      *pretend_size = n * UNITS_PER_WORD;
+      cfun->machine->n_varargs = n;
     }
 }
 
@@ -1542,8 +2559,17 @@ ia64_function_arg (cum, mode, type, name
   int offset = 0;
   enum machine_mode hfa_mode = VOIDmode;
 
-  /* Arguments larger than 8 bytes start at the next even boundary.  */
-  if (words > 1 && (cum->words & 1))
+  /* Integer and float arguments larger than 8 bytes start at the next even
+     boundary.  Aggregates larger than 8 bytes start at the next even boundary
+     if the aggregate has 16 byte alignment.  Net effect is that types with
+     alignment greater than 8 start at the next even boundary.  */
+  /* ??? The ABI does not specify how to handle aggregates with alignment from
+     9 to 15 bytes, or greater than 16.   We handle them all as if they had
+     16 byte alignment.  Such aggregates can occur only if gcc extensions are
+     used.  */
+  if ((type ? (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)
+       : (words > 1))
+      && (cum->words & 1))
     offset = 1;
 
   /* If all argument slots are used, then it must go on the stack.  */
@@ -1587,7 +2613,6 @@ ia64_function_arg (cum, mode, type, name
 				      gen_rtx_REG (hfa_mode, (FR_ARG_FIRST
 							      + fp_regs)),
 				      GEN_INT (offset));
-	  /* ??? Padding for XFmode type?  */
 	  offset += hfa_size;
 	  args_byte_size += hfa_size;
 	  fp_regs++;
@@ -1684,8 +2709,11 @@ ia64_function_arg_partial_nregs (cum, mo
 	       / UNITS_PER_WORD);
   int offset = 0;
 
-  /* Arguments larger than 8 bytes start at the next even boundary.  */
-  if (words > 1 && (cum->words & 1))
+  /* Arguments with alignment larger than 8 bytes start at the next even
+     boundary.  */
+  if ((type ? (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)
+       : (words > 1))
+      && (cum->words & 1))
     offset = 1;
 
   /* If all argument slots are used, then it must go on the stack.  */
@@ -1723,8 +2751,11 @@ ia64_function_arg_advance (cum, mode, ty
   if (cum->words >= MAX_ARGUMENT_SLOTS)
     return;
 
-  /* Arguments larger than 8 bytes start at the next even boundary.  */
-  if (words > 1 && (cum->words & 1))
+  /* Arguments with alignment larger than 8 bytes start at the next even
+     boundary.  */
+  if ((type ? (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)
+       : (words > 1))
+      && (cum->words & 1))
     offset = 1;
 
   cum->words += words + offset;
@@ -1761,7 +2792,6 @@ ia64_function_arg_advance (cum, mode, ty
       for (; (offset < byte_size && fp_regs < MAX_ARGUMENT_SLOTS
 	      && args_byte_size < (MAX_ARGUMENT_SLOTS * UNITS_PER_WORD));)
 	{
-	  /* ??? Padding for XFmode type?  */
 	  offset += hfa_size;
 	  args_byte_size += hfa_size;
 	  fp_regs++;
@@ -1823,12 +2853,11 @@ rtx
 ia64_va_arg (valist, type)
      tree valist, type;
 {
-  HOST_WIDE_INT size;
   tree t;
 
-  /* Arguments larger than 8 bytes are 16 byte aligned.  */
-  size = int_size_in_bytes (type);
-  if (size > UNITS_PER_WORD)
+  /* Arguments with alignment larger than 8 bytes start at the next even
+     boundary.  */
+  if (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)
     {
       t = build (PLUS_EXPR, TREE_TYPE (valist), valist,
 		 build_int_2 (2 * UNITS_PER_WORD - 1, 0));
@@ -1864,7 +2893,6 @@ ia64_return_in_memory (valtype)
     {
       int hfa_size = GET_MODE_SIZE (hfa_mode);
 
-      /* ??? Padding for XFmode type?  */
       if (byte_size / hfa_size > MAX_ARGUMENT_SLOTS)
 	return 1;
       else
@@ -1907,7 +2935,6 @@ ia64_function_value (valtype, func)
 	  loc[i] = gen_rtx_EXPR_LIST (VOIDmode,
 				      gen_rtx_REG (hfa_mode, FR_ARG_FIRST + i),
 				      GEN_INT (offset));
-	  /* ??? Padding for XFmode type?  */
 	  offset += hfa_size;
 	}
 
@@ -2060,19 +3087,10 @@ ia64_print_operand (file, x, code)
 
 	  case POST_INC:
 	    value = GET_MODE_SIZE (GET_MODE (x));
-
-	    /* ??? This is for ldf.fill and stf.spill which use XFmode,
-	       but which actually need 16 bytes increments.  Perhaps we
-	       can change them to use TFmode instead.  Or don't use
-	       POST_DEC/POST_INC for them.  */
-	    if (value == 12)
-	      value = 16;
 	    break;
 
 	  case POST_DEC:
 	    value = - (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (x));
-	    if (value == -12)
-	      value = -16;
 	    break;
 	  }
 
@@ -2114,11 +3132,14 @@ ia64_print_operand (file, x, code)
       break;
 
     case 'r':
-      /* If this operand is the constant zero, write it as zero.  */
+      /* If this operand is the constant zero, write it as register zero.
+	 Any register, zero, or CONST_INT value is OK here.  */
       if (GET_CODE (x) == REG)
 	fputs (reg_names[REGNO (x)], file);
       else if (x == CONST0_RTX (GET_MODE (x)))
 	fputs ("r0", file);
+      else if (GET_CODE (x) == CONST_INT)
+	output_addr_const (file, x);
       else
 	output_operand_lossage ("invalid %%r value");
       return;
@@ -2208,17 +3229,28 @@ ia64_register_move_cost (from, to)
 {
   int from_hard, to_hard;
   int from_gr, to_gr;
+  int from_fr, to_fr;
 
   from_hard = (from == BR_REGS || from == AR_M_REGS || from == AR_I_REGS);
   to_hard = (to == BR_REGS || to == AR_M_REGS || to == AR_I_REGS);
   from_gr = (from == GENERAL_REGS);
   to_gr = (to == GENERAL_REGS);
+  from_fr = (from == FR_REGS);
+  to_fr = (to == FR_REGS);
 
   if (from_hard && to_hard)
     return 8;
   else if ((from_hard && !to_gr) || (!from_gr && to_hard))
     return 6;
 
+  /* ??? Moving from FR<->GR must be more expensive than 2, so that we get
+     secondary memory reloads for TFmode moves.  Unfortunately, we don't
+     have the mode here, so we can't check that.  */
+  /* Moreover, we have to make this at least as high as MEMORY_MOVE_COST
+     to avoid spectacularly poor register class preferencing for TFmode.  */
+  else if (from_fr != to_fr)
+    return 5;
+
   return 2;
 }
 
@@ -2238,49 +3270,74 @@ ia64_secondary_reload_class (class, mode
   if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)
     regno = true_regnum (x);
 
-  /* ??? This is required because of a bad gcse/cse/global interaction.
-     We end up with two pseudos with overlapping lifetimes both of which are
-     equiv to the same constant, and both which need to be in BR_REGS.  This
-     results in a BR_REGS to BR_REGS copy which doesn't exist.  To reproduce,
-     return NO_REGS here, and compile divdi3 in libgcc2.c.  This seems to be
-     a cse bug.  cse_basic_block_end changes depending on the path length,
-     which means the qty_first_reg check in make_regs_eqv can give different
-     answers at different times.  */
-  /* ??? At some point I'll probably need a reload_indi pattern to handle
-     this.  */
-  if (class == BR_REGS && BR_REGNO_P (regno))
-    return GR_REGS;
-
-  /* This is needed if a pseudo used as a call_operand gets spilled to a
-     stack slot.  */
-  if (class == BR_REGS && GET_CODE (x) == MEM)
-    return GR_REGS;
-
-  /* This can happen when a paradoxical subreg is an operand to the muldi3
-     pattern.  */
-  /* ??? This shouldn't be necessary after instruction scheduling is enabled,
-     because paradoxical subregs are not accepted by register_operand when
-     INSN_SCHEDULING is defined.  Or alternatively, stop the paradoxical subreg
-     stupidity in the *_operand functions in recog.c.  */
-  if (class == FR_REGS
-      && GET_CODE (x) == MEM
-      && (GET_MODE (x) == SImode || GET_MODE (x) == HImode
-	  || GET_MODE (x) == QImode))
-    return GR_REGS;
-
-  /* This can happen because of the ior/and/etc patterns that accept FP
-     registers as operands.  If the third operand is a constant, then it
-     needs to be reloaded into a FP register.  */
-  if (class == FR_REGS && GET_CODE (x) == CONST_INT)
-    return GR_REGS;
-
-  /* ??? This happens if we cse/gcse a CCmode value across a call, and the
-     function has a nonlocal goto.  This is because global does not allocate
-     call crossing pseudos to hard registers when current_function_has_
-     nonlocal_goto is true.  This is relatively common for C++ programs that
-     use exceptions.  To reproduce, return NO_REGS and compile libstdc++.  */
-  if (class == PR_REGS && GET_CODE (x) == MEM)
-    return GR_REGS;
+  switch (class)
+    {
+    case BR_REGS:
+      /* ??? This is required because of a bad gcse/cse/global interaction.
+	 We end up with two pseudos with overlapping lifetimes both of which
+	 are equiv to the same constant, and both which need to be in BR_REGS.
+	 This results in a BR_REGS to BR_REGS copy which doesn't exist.  To
+	 reproduce, return NO_REGS here, and compile divdi3 in libgcc2.c.
+	 This seems to be a cse bug.  cse_basic_block_end changes depending
+	 on the path length, which means the qty_first_reg check in
+	 make_regs_eqv can give different answers at different times.  */
+      /* ??? At some point I'll probably need a reload_indi pattern to handle
+	 this.  */
+      if (BR_REGNO_P (regno))
+	return GR_REGS;
+
+      /* This is needed if a pseudo used as a call_operand gets spilled to a
+	 stack slot.  */
+      if (GET_CODE (x) == MEM)
+	return GR_REGS;
+      break;
+
+    case FR_REGS:
+      /* This can happen when a paradoxical subreg is an operand to the
+	 muldi3 pattern.  */
+      /* ??? This shouldn't be necessary after instruction scheduling is
+	 enabled, because paradoxical subregs are not accepted by
+	 register_operand when INSN_SCHEDULING is defined.  Or alternatively,
+	 stop the paradoxical subreg stupidity in the *_operand functions
+	 in recog.c.  */
+      if (GET_CODE (x) == MEM
+	  && (GET_MODE (x) == SImode || GET_MODE (x) == HImode
+	      || GET_MODE (x) == QImode))
+	return GR_REGS;
+
+      /* This can happen because of the ior/and/etc patterns that accept FP
+	 registers as operands.  If the third operand is a constant, then it
+	 needs to be reloaded into a FP register.  */
+      if (GET_CODE (x) == CONST_INT)
+	return GR_REGS;
+
+      /* This can happen because of register elimination in a muldi3 insn.
+	 E.g. `26107 * (unsigned long)&u'.  */
+      if (GET_CODE (x) == PLUS)
+	return GR_REGS;
+      break;
+
+    case PR_REGS:
+      /* ??? This happens if we cse/gcse a CCmode value across a call,
+	 and the function has a nonlocal goto.  This is because global
+	 does not allocate call crossing pseudos to hard registers when
+	 current_function_has_nonlocal_goto is true.  This is relatively
+	 common for C++ programs that use exceptions.  To reproduce,
+	 return NO_REGS and compile libstdc++.  */
+      if (GET_CODE (x) == MEM)
+	return GR_REGS;
+      break;
+
+    case GR_REGS:
+      /* Since we have no offsettable memory addresses, we need a temporary
+	 to hold the address of the second word.  */
+      if (mode == TImode)
+	return GR_REGS;
+      break;
+
+    default:
+      break;
+    }
 
   return NO_REGS;
 }
@@ -2410,9 +3467,6 @@ ia64_init_machine_status (p)
 {
   p->machine =
     (struct machine_function *) xcalloc (1, sizeof (struct machine_function));
-
-  /* Reset from the previous function's potential modifications.  */
-  XINT (return_address_pointer_rtx, 0) = RETURN_ADDRESS_POINTER_REGNUM;
 }
 
 static void
@@ -2421,6 +3475,7 @@ ia64_mark_machine_status (p)
 {
   ggc_mark_rtx (p->machine->ia64_eh_epilogue_sp);
   ggc_mark_rtx (p->machine->ia64_eh_epilogue_bsp);
+  ggc_mark_rtx (p->machine->ia64_gp_save);
 }
 
 
@@ -2458,7 +3513,8 @@ ia64_override_options ()
 /* This is used for volatile asms which may require a stop bit immediately
    before and after them.  */
 #define REG_VOLATILE	(FIRST_PSEUDO_REGISTER + 2)
-#define NUM_REGS	(FIRST_PSEUDO_REGISTER + 3)
+#define AR_UNAT_BIT_0	(FIRST_PSEUDO_REGISTER + 3)
+#define NUM_REGS	(AR_UNAT_BIT_0 + 64)
 
 /* For each register, we keep track of how many times it has been
    written in the current instruction group.  If a register is written
@@ -2494,7 +3550,8 @@ struct reg_flags
 
 static void rws_update PARAMS ((struct reg_write_state *, int,
 				struct reg_flags, int));
-static int rws_access_reg PARAMS ((int, struct reg_flags, int));
+static int rws_access_regno PARAMS ((int, struct reg_flags, int));
+static int rws_access_reg PARAMS ((rtx, struct reg_flags, int));
 static int rtx_needs_barrier PARAMS ((rtx, struct reg_flags, int));
 
 /* Update *RWS for REGNO, which is being written by the current instruction,
@@ -2517,13 +3574,12 @@ rws_update (rws, regno, flags, pred)
    a dependency with an earlier instruction in the same group.  */
 
 static int
-rws_access_reg (regno, flags, pred)
+rws_access_regno (regno, flags, pred)
      int regno;
      struct reg_flags flags;
      int pred;
 {
   int need_barrier = 0;
-  int is_predicate_reg;
 
   if (regno >= NUM_REGS)
     abort ();
@@ -2538,27 +3594,13 @@ rws_access_reg (regno, flags, pred)
 
       /* Update info for current instruction.  */
       rws_update (rws_insn, regno, flags, pred);
-
-      /* ??? This is necessary because predicate regs require two hard
-	 registers.  However, this should be using HARD_REGNO_NREGS so that
-	 it works for all multi-reg hard registers, instead of only for
-	 predicate registers.  */
-      is_predicate_reg = REGNO_REG_CLASS (regno) == PR_REGS;
-      if (is_predicate_reg)
-	rws_update (rws_insn, regno + 1, flags, pred);
-
-      /* ??? Likewise.  */
       write_count = rws_sum[regno].write_count;
-      if (is_predicate_reg)
-	write_count = MAX (write_count, rws_sum[regno + 1].write_count);
 
       switch (write_count)
 	{
 	case 0:
 	  /* The register has not been written yet.  */
 	  rws_update (rws_sum, regno, flags, pred);
-	  if (is_predicate_reg)
-	    rws_update (rws_sum, regno + 1, flags, pred);
 	  break;
 
 	case 1:
@@ -2569,8 +3611,6 @@ rws_access_reg (regno, flags, pred)
 	  if ((rws_sum[regno].first_pred ^ 1) != pred)
 	    need_barrier = 1;
 	  rws_update (rws_sum, regno, flags, pred);
-	  if (is_predicate_reg)
-	    rws_update (rws_sum, regno + 1, flags, pred);
 	  break;
 
 	case 2:
@@ -2635,6 +3675,26 @@ rws_access_reg (regno, flags, pred)
   return need_barrier;
 }
 
+static int
+rws_access_reg (reg, flags, pred)
+     rtx reg;
+     struct reg_flags flags;
+     int pred;
+{
+  int regno = REGNO (reg);
+  int n = HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg));
+
+  if (n == 1)
+    return rws_access_regno (regno, flags, pred);
+  else
+    {
+      int need_barrier = 0;
+      while (--n >= 0)
+	need_barrier |= rws_access_regno (regno + n, flags, pred);
+      return need_barrier;
+    }
+}
+
 /* Handle an access to rtx X of type FLAGS using predicate register PRED.
    Return 1 is this access creates a dependency with an earlier instruction
    in the same group.  */
@@ -2726,9 +3786,10 @@ rtx_needs_barrier (x, flags, pred)
 	  break;
 	}
       need_barrier = rtx_needs_barrier (src, flags, pred);
+
       /* This instruction unconditionally uses a predicate register.  */
       if (cond)
-	need_barrier |= rws_access_reg (REGNO (cond), flags, 0);
+	need_barrier |= rws_access_reg (cond, flags, 0);
 
       dst = SET_DEST (x);
       if (GET_CODE (dst) == ZERO_EXTRACT)
@@ -2743,9 +3804,7 @@ rtx_needs_barrier (x, flags, pred)
 
     case CALL:
       new_flags.is_write = 0;
-      /* ??? Why is this here?  It seems unnecessary.  */
-      need_barrier |= rws_access_reg (REG_GP, new_flags, pred);
-      need_barrier |= rws_access_reg (AR_EC_REGNUM, new_flags, pred);
+      need_barrier |= rws_access_regno (AR_EC_REGNUM, new_flags, pred);
 
       /* Avoid multiple register writes, in case this is a pattern with
 	 multiple CALL rtx.  This avoids an abort in rws_access_reg.  */
@@ -2754,9 +3813,9 @@ rtx_needs_barrier (x, flags, pred)
       if (! rws_insn[REG_AR_CFM].write_count)
 	{
 	  new_flags.is_write = 1;
-	  need_barrier |= rws_access_reg (REG_RP, new_flags, pred);
-	  need_barrier |= rws_access_reg (AR_PFS_REGNUM, new_flags, pred);
-	  need_barrier |= rws_access_reg (REG_AR_CFM, new_flags, pred);
+	  need_barrier |= rws_access_regno (REG_RP, new_flags, pred);
+	  need_barrier |= rws_access_regno (AR_PFS_REGNUM, new_flags, pred);
+	  need_barrier |= rws_access_regno (REG_AR_CFM, new_flags, pred);
 	}
       break;
 
@@ -2803,7 +3862,7 @@ rtx_needs_barrier (x, flags, pred)
 	  if (! rws_insn[REG_VOLATILE].write_count)
 	    {
 	      new_flags.is_write = 1;
-	      rws_access_reg (REG_VOLATILE, new_flags, pred);
+	      rws_access_regno (REG_VOLATILE, new_flags, pred);
 	    }
 	  return 1;
 	}
@@ -2828,7 +3887,13 @@ rtx_needs_barrier (x, flags, pred)
       x = SUBREG_REG (x);
       /* FALLTHRU */
     case REG:
-      need_barrier = rws_access_reg (REGNO (x), flags, pred);
+      if (REGNO (x) == AR_UNAT_REGNUM)
+	{
+	  for (i = 0; i < 64; ++i)
+	    need_barrier |= rws_access_regno (AR_UNAT_BIT_0 + i, flags, pred);
+	}
+      else
+	need_barrier = rws_access_reg (x, flags, pred);
       break;
 
     case MEM:
@@ -2847,9 +3912,9 @@ rtx_needs_barrier (x, flags, pred)
 	abort ();
 
       new_flags.is_write = 0;
-      need_barrier  = rws_access_reg (REGNO (XEXP (x, 0)), new_flags, pred);
+      need_barrier  = rws_access_reg (XEXP (x, 0), new_flags, pred);
       new_flags.is_write = 1;
-      need_barrier |= rws_access_reg (REGNO (XEXP (x, 0)), new_flags, pred);
+      need_barrier |= rws_access_reg (XEXP (x, 0), new_flags, pred);
       break;
 
     case POST_MODIFY:
@@ -2857,10 +3922,10 @@ rtx_needs_barrier (x, flags, pred)
 	abort ();
 
       new_flags.is_write = 0;
-      need_barrier  = rws_access_reg (REGNO (XEXP (x, 0)), new_flags, pred);
+      need_barrier  = rws_access_reg (XEXP (x, 0), new_flags, pred);
       need_barrier |= rtx_needs_barrier (XEXP (x, 1), new_flags, pred);
       new_flags.is_write = 1;
-      need_barrier |= rws_access_reg (REGNO (XEXP (x, 0)), new_flags, pred);
+      need_barrier |= rws_access_reg (XEXP (x, 0), new_flags, pred);
       break;
 
       /* Handle common unary and binary ops for efficiency.  */
@@ -2884,54 +3949,36 @@ rtx_needs_barrier (x, flags, pred)
     case UNSPEC:
       switch (XINT (x, 1))
 	{
-	  /* ??? For the st8.spill/ld8.fill instructions, we can ignore unat
-	     dependencies as long as we don't have both a spill and fill in
-	     the same instruction group.  We need to check for that.  */
 	case 1: /* st8.spill */
 	case 2: /* ld8.fill */
+	  {
+	    HOST_WIDE_INT offset = INTVAL (XVECEXP (x, 0, 1));
+	    HOST_WIDE_INT bit = (offset >> 3) & 63;
+
+	    need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);
+	    new_flags.is_write = (XINT (x, 1) == 1);
+	    need_barrier |= rws_access_regno (AR_UNAT_BIT_0 + bit,
+					      new_flags, pred);
+	    break;
+	  }
+	  
 	case 3: /* stf.spill */
 	case 4: /* ldf.spill */
 	case 8: /* popcnt */
 	  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);
 	  break;
 
-	case 5: /* mov =pr */
-	  /* This reads all predicate registers.  */
-	  for (i = PR_REG (1); i < PR_REG (64); i++)
-	    need_barrier |= rws_access_reg (i, flags, pred);
-	  break;
-
-	case 6:
-	case 7:
-	  abort ();
-
-	  /* ??? Should track unat reads and writes.  */
-	case 9: /* mov =ar.unat */
-	case 10: /* mov ar.unat= */
-	  break;
-        case 11: /* mov ar.ccv= */
-          break;
         case 12: /* mf */
-          break;
-        case 13: /* cmpxchg_acq */
-          break;
-        case 14: /* val_compare_and_swap */
-          break;
-        case 15: /* lock_release */
-          break;
-        case 16: /* lock_test_and_set */
-          break;
-        case 17: /* _and_fetch */
-          break;
-        case 18: /* fetch_and_ */
-          break;
         case 19: /* fetchadd_acq */
-          break;
 	case 20: /* mov = ar.bsp */
-          break;
 	case 21: /* flushrs */
           break;
 
+        case 13: /* cmpxchg_acq */
+	  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 1), flags, pred);
+	  need_barrier |= rtx_needs_barrier (XVECEXP (x, 0, 2), flags, pred);
+	  break;
+
 	default:
 	  abort ();
 	}
@@ -2944,39 +3991,23 @@ rtx_needs_barrier (x, flags, pred)
 	  /* Alloc must always be the first instruction.  Currently, we
 	     only emit it at the function start, so we don't need to worry
 	     about emitting a stop bit before it.  */
-	  need_barrier = rws_access_reg (AR_PFS_REGNUM, flags, pred);
+	  need_barrier = rws_access_regno (AR_PFS_REGNUM, flags, pred);
 
 	  new_flags.is_write = 1;
-	  need_barrier |= rws_access_reg (REG_AR_CFM, new_flags, pred);
+	  need_barrier |= rws_access_regno (REG_AR_CFM, new_flags, pred);
 	  return need_barrier;
 
 	case 1: /* blockage */
 	case 2: /* insn group barrier */
 	  return 0;
 
-	case 3: /* flush_cache */
-	  return rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);
-
-	case 4: /* mov ar.pfs= */
-	  new_flags.is_write = 1;
-	  need_barrier = rws_access_reg (AR_PFS_REGNUM, new_flags, pred);
-	  break;
-
 	case 5: /* set_bsp  */
 	  need_barrier = 1;
           break;
 
-	case 6: /* mov pr= */
-	  /* This writes all predicate registers.  */
-	  new_flags.is_write = 1;
-	  /* We need to skip by two, because rws_access_reg always writes
-	     to two predicate registers at a time.  */
-	  /* ??? Strictly speaking, we shouldn't be counting writes to pr0.  */
-	  for (i = PR_REG (0); i < PR_REG (64); i += 2)
-	    need_barrier |= rws_access_reg (i, new_flags, pred);
-	  break;
-
 	case 7: /* pred.rel.mutex */
+	case 8: /* safe_across_calls all */
+	case 9: /* safe_across_calls normal */
 	  return 0;
 
 	default:
@@ -2986,12 +4017,12 @@ rtx_needs_barrier (x, flags, pred)
 
     case RETURN:
       new_flags.is_write = 0;
-      need_barrier  = rws_access_reg (REG_RP, flags, pred);
-      need_barrier |= rws_access_reg (AR_PFS_REGNUM, flags, pred);
+      need_barrier  = rws_access_regno (REG_RP, flags, pred);
+      need_barrier |= rws_access_regno (AR_PFS_REGNUM, flags, pred);
 
       new_flags.is_write = 1;
-      need_barrier |= rws_access_reg (AR_EC_REGNUM, new_flags, pred);
-      need_barrier |= rws_access_reg (REG_AR_CFM, new_flags, pred);
+      need_barrier |= rws_access_regno (AR_EC_REGNUM, new_flags, pred);
+      need_barrier |= rws_access_regno (REG_AR_CFM, new_flags, pred);
       break;
 
     default:
@@ -3025,6 +4056,128 @@ rtx_needs_barrier (x, flags, pred)
   return need_barrier;
 }
 
+/* This structure is used to track some details about the previous insns
+   groups so we can determine if it may be necessary to insert NOPs to
+   workaround hardware errata.  */
+static struct group
+{
+  HARD_REG_SET p_reg_set;
+  HARD_REG_SET gr_reg_conditionally_set;
+} last_group[3];
+
+/* Index into the last_group array.  */
+static int group_idx;
+
+static void emit_group_barrier_after PARAMS ((rtx));
+static int errata_find_address_regs PARAMS ((rtx *, void *));
+static void errata_emit_nops PARAMS ((rtx));
+
+/* Create a new group barrier, emit it after AFTER, and advance group_idx.  */
+static void
+emit_group_barrier_after (after)
+     rtx after;
+{
+  emit_insn_after (gen_insn_group_barrier (), after);
+  group_idx = (group_idx + 1) % 3;
+  memset (last_group + group_idx, 0, sizeof last_group[group_idx]);
+}
+
+/* Called through for_each_rtx; determines if a hard register that was
+   conditionally set in the previous group is used as an address register.
+   It ensures that for_each_rtx returns 1 in that case.  */
+static int
+errata_find_address_regs (xp, data)
+     rtx *xp;
+     void *data ATTRIBUTE_UNUSED;
+{
+  rtx x = *xp;
+  if (GET_CODE (x) != MEM)
+    return 0;
+  x = XEXP (x, 0);
+  if (GET_CODE (x) == POST_MODIFY)
+    x = XEXP (x, 0);
+  if (GET_CODE (x) == REG)
+    {
+      struct group *prev_group = last_group + (group_idx + 2) % 3;
+      if (TEST_HARD_REG_BIT (prev_group->gr_reg_conditionally_set,
+			     REGNO (x)))
+	return 1;
+      return -1;
+    }
+  return 0;
+}
+
+/* Called for each insn; this function keeps track of the state in
+   last_group and emits additional NOPs if necessary to work around
+   an Itanium A/B step erratum.  */
+static void
+errata_emit_nops (insn)
+     rtx insn;
+{
+  struct group *this_group = last_group + group_idx;
+  struct group *prev_group = last_group + (group_idx + 2) % 3;
+  rtx pat = PATTERN (insn);
+  rtx cond = GET_CODE (pat) == COND_EXEC ? COND_EXEC_TEST (pat) : 0;
+  rtx real_pat = cond ? COND_EXEC_CODE (pat) : pat;
+  enum attr_type type;
+  rtx set = real_pat;
+
+  if (GET_CODE (real_pat) == USE
+      || GET_CODE (real_pat) == CLOBBER
+      || GET_CODE (real_pat) == ASM_INPUT
+      || GET_CODE (real_pat) == ADDR_VEC
+      || GET_CODE (real_pat) == ADDR_DIFF_VEC
+      || asm_noperands (insn) >= 0)
+    return;
+
+  /* single_set doesn't work for COND_EXEC insns, so we have to duplicate
+     parts of it.  */
+
+  if (GET_CODE (set) == PARALLEL)
+    {
+      int i;
+      set = XVECEXP (real_pat, 0, 0);
+      for (i = 1; i < XVECLEN (real_pat, 0); i++)
+	if (GET_CODE (XVECEXP (real_pat, 0, i)) != USE
+	    && GET_CODE (XVECEXP (real_pat, 0, i)) != CLOBBER)
+	  {
+	    set = 0;
+	    break;
+	  }
+    }
+
+  if (set && GET_CODE (set) != SET)
+    set = 0;
+
+  type  = get_attr_type (insn);
+
+  if (type == TYPE_F
+      && set && REG_P (SET_DEST (set)) && PR_REGNO_P (REGNO (SET_DEST (set))))
+    SET_HARD_REG_BIT (this_group->p_reg_set, REGNO (SET_DEST (set)));
+
+  if ((type == TYPE_M || type == TYPE_A) && cond && set
+      && REG_P (SET_DEST (set))
+      && GET_CODE (SET_SRC (set)) != PLUS
+      && GET_CODE (SET_SRC (set)) != MINUS
+      && (GET_CODE (SET_SRC (set)) != MEM
+	  || GET_CODE (XEXP (SET_SRC (set), 0)) != POST_MODIFY)
+      && GENERAL_REGNO_P (REGNO (SET_DEST (set))))
+    {
+      if (GET_RTX_CLASS (GET_CODE (cond)) != '<'
+	  || ! REG_P (XEXP (cond, 0)))
+	abort ();
+
+      if (TEST_HARD_REG_BIT (prev_group->p_reg_set, REGNO (XEXP (cond, 0))))
+	SET_HARD_REG_BIT (this_group->gr_reg_conditionally_set, REGNO (SET_DEST (set)));
+    }
+  if (for_each_rtx (&real_pat, errata_find_address_regs, NULL))
+    {
+      emit_insn_before (gen_insn_group_barrier (), insn);
+      emit_insn_before (gen_nop (), insn);
+      emit_insn_before (gen_insn_group_barrier (), insn);
+    }
+}
+
 /* INSNS is an chain of instructions.  Scan the chain, and insert stop bits
    as necessary to eliminate dependendencies.  */
 
@@ -3036,16 +4189,37 @@ emit_insn_group_barriers (insns)
 
   memset (rws_sum, 0, sizeof (rws_sum));
 
+  group_idx = 0;
+  memset (last_group, 0, sizeof last_group);
+
   prev_insn = 0;
   for (insn = insns; insn; insn = NEXT_INSN (insn))
     {
       int need_barrier = 0;
       struct reg_flags flags;
 
+      if ((TARGET_B_STEP || TARGET_A_STEP) && INSN_P (insn))
+	errata_emit_nops (insn);
+
       memset (&flags, 0, sizeof (flags));
       switch (GET_CODE (insn))
 	{
 	case NOTE:
+	  /* For very small loops we can wind up with extra stop bits
+	     inside the loop because of not putting a stop after the
+	     assignment to ar.lc before the loop label.  */
+	  /* ??? Ideally we'd do this for any register used in the first
+	     insn group that's been written recently.  */
+          if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)
+	    {
+	      need_barrier = rws_access_regno (AR_LC_REGNUM, flags, 0);
+	      if (need_barrier)
+		{
+		  emit_group_barrier_after (insn);
+		  memset (rws_sum, 0, sizeof(rws_sum));
+		  prev_insn = NULL_RTX;
+		}
+	    }
 	  break;
 
 	case CALL_INSN:
@@ -3058,33 +4232,60 @@ emit_insn_group_barriers (insns)
 	      /* PREV_INSN null can happen if the very first insn is a
 		 volatile asm.  */
 	      if (prev_insn)
-		emit_insn_after (gen_insn_group_barrier (), prev_insn);
+		emit_group_barrier_after (prev_insn);
 	      memcpy (rws_sum, rws_insn, sizeof (rws_sum));
 	    }
 
-	  /* A call must end a group, otherwise the assembler might pack
+	  /* A call must end a bundle, otherwise the assembler might pack
 	     it in with a following branch and then the function return
 	     goes to the wrong place.  Do this unconditionally for 
 	     unconditional calls, simply because it (1) looks nicer and
 	     (2) keeps the data structures more accurate for the insns
 	     following the call.  */
+	  /* ??? A call doesn't have to end a bundle if it is followed by
+	     a mutex call or branch.  Two mutex calls/branches can be put in
+	     the same bundle.  */
 
 	  need_barrier = 1;
+#if 0
+	  /* this isn't safe; we can't suppress the stop bit after a
+	     br.call because all instructions packed into the same
+	     bundle would be skipped when returning from the
+	     subroutine.  --davidm 00/11/16 */
 	  if (GET_CODE (PATTERN (insn)) == COND_EXEC)
 	    {
 	      rtx next_insn = insn;
+	      enum attr_type type = TYPE_A;
+
 	      do
 		next_insn = next_nonnote_insn (next_insn);
 	      while (next_insn
 		     && GET_CODE (next_insn) == INSN
 		     && (GET_CODE (PATTERN (next_insn)) == USE
 			 || GET_CODE (PATTERN (next_insn)) == CLOBBER));
-	      if (next_insn && GET_CODE (next_insn) != JUMP_INSN)
+
+	      /* A call ends a bundle if there is a stop bit after it,
+		 or if it is followed by a non-B-type instruction.
+		 In the later case, we can elide the stop bit, and get faster
+		 code when the predicate is false.  */
+	      /* ??? The proper solution for this problem is to make gcc
+		 explicitly bundle instructions.  Then we don't need to
+		 emit stop bits to force the assembler to start a new
+		 bundle.  */
+
+	      /* Check the instruction type if it is not a branch or call.  */
+	      if (next_insn && GET_CODE (next_insn) == INSN)
+		type = get_attr_type (next_insn);
+
+	      if (next_insn && GET_CODE (next_insn) != JUMP_INSN
+		  && GET_CODE (next_insn) != CALL_INSN
+		  && type != TYPE_B && type != TYPE_UNKNOWN)
 		need_barrier = 0;
 	    }
+#endif
 	  if (need_barrier)
 	    {
-	      emit_insn_after (gen_insn_group_barrier (), insn);
+	      emit_group_barrier_after (insn);
 	      memset (rws_sum, 0, sizeof (rws_sum));
 	      prev_insn = NULL_RTX;
 	    }
@@ -3104,16 +4305,36 @@ emit_insn_group_barriers (insns)
 	    {
 	      rtx pat = PATTERN (insn);
 
-	      /* We play dependency tricks with the epilogue in order to
-		 get proper schedules.  Undo this for dv analysis.  */
-	      if (INSN_CODE (insn) == CODE_FOR_epilogue_deallocate_stack)
-		pat = XVECEXP (pat, 0, 0);
-
-	      /* ??? Similarly, the pattern we use for br.cloop
-		 confuses the code above.  The second element of the
-		 vector is representative.  */
-	      else if (INSN_CODE (insn) == CODE_FOR_doloop_end_internal)
-		pat = XVECEXP (pat, 0, 1);
+	      /* Ug.  Hack hacks hacked elsewhere.  */
+	      switch (INSN_CODE (insn))
+		{
+		  /* We play dependency tricks with the epilogue in order
+		     to get proper schedules.  Undo this for dv analysis.  */
+		case CODE_FOR_epilogue_deallocate_stack:
+		  pat = XVECEXP (pat, 0, 0);
+		  break;
+
+		  /* The pattern we use for br.cloop confuses the code above.
+		     The second element of the vector is representative.  */
+		case CODE_FOR_doloop_end_internal:
+		  pat = XVECEXP (pat, 0, 1);
+		  break;
+
+		  /* We include ar.unat in the rtl pattern so that sched2
+		     does not move the ar.unat save/restore after/before
+		     a gr spill/fill.  However, we special case these
+		     insns based on their unspec number so as to model
+		     their precise ar.unat bit operations.  If we pass on
+		     the use/clobber of the whole ar.unat register we'll
+		     waste this effort.  */
+		case CODE_FOR_gr_spill_internal:
+		case CODE_FOR_gr_restore_internal:
+		  pat = XVECEXP (pat, 0, 0);
+		  break;
+
+		default:
+		  break;
+		}
 
 	      memset (rws_insn, 0, sizeof (rws_insn));
 	      need_barrier |= rtx_needs_barrier (pat, flags, 0);
@@ -3121,14 +4342,14 @@ emit_insn_group_barriers (insns)
 	      /* Check to see if the previous instruction was a volatile
 		 asm.  */
 	      if (! need_barrier)
-		need_barrier = rws_access_reg (REG_VOLATILE, flags, 0);
+		need_barrier = rws_access_regno (REG_VOLATILE, flags, 0);
 
 	      if (need_barrier)
 		{
 		  /* PREV_INSN null can happen if the very first insn is a
 		     volatile asm.  */
 		  if (prev_insn)
-		    emit_insn_after (gen_insn_group_barrier (), prev_insn);
+		    emit_group_barrier_after (prev_insn);
 		  memcpy (rws_sum, rws_insn, sizeof (rws_sum));
 		}
 	      prev_insn = insn;
@@ -3188,6 +4409,35 @@ emit_predicate_relation_info (insns)
 	    head = n;
 	  }
     }
+
+  /* Look for conditional calls that do not return, and protect predicate
+     relations around them.  Otherwise the assembler will assume the call
+     returns, and complain about uses of call-clobbered predicates after
+     the call.  */
+  for (i = n_basic_blocks - 1; i >= 0; --i)
+    {
+      basic_block bb = BASIC_BLOCK (i);
+      rtx insn = bb->head;
+      
+      while (1)
+	{
+	  if (GET_CODE (insn) == CALL_INSN
+	      && GET_CODE (PATTERN (insn)) == COND_EXEC
+	      && find_reg_note (insn, REG_NORETURN, NULL_RTX))
+	    {
+	      rtx b = emit_insn_before (gen_safe_across_calls_all (), insn);
+	      rtx a = emit_insn_after (gen_safe_across_calls_normal (), insn);
+	      if (bb->head == insn)
+		bb->head = b;
+	      if (bb->end == insn)
+		bb->end = a;
+	    }
+	  
+	  if (insn == bb->end)
+	    break;
+	  insn = NEXT_INSN (insn);
+	}
+    }
 }
 
 /* Perform machine dependent operations on the rtl chain INSNS.  */
@@ -3237,7 +4487,12 @@ ia64_epilogue_uses (regno)
   if (regno == R_BR (0))
     return 1;
 
-  if (regno == AR_LC_REGNUM)
+  if (regs_ever_live[AR_LC_REGNUM] && regno == AR_LC_REGNUM)
+    return 1;
+  if (! current_function_is_leaf && regno == AR_PFS_REGNUM)
+    return 1;
+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_UNAT_REGNUM)
+      && regno == AR_UNAT_REGNUM)
     return 1;
 
   return 0;
@@ -3379,15 +4639,9 @@ ia64_encode_section_info (decl)
 
 /* Output assmebly directives for prologue regions.  */
 
-static int spill_offset;
-static int sp_offset;
-static int spill_offset_emitted = 1;
-static rtx tmp_reg = NULL_RTX;
-static int tmp_saved = -1;
-
-
 /* This function processes a SET pattern looking for specific patterns
    which result in emitting an assembly directive required for unwinding.  */
+
 static int
 process_set (asm_out_file, pat)
      FILE *asm_out_file;
@@ -3395,20 +4649,26 @@ process_set (asm_out_file, pat)
 {
   rtx src = SET_SRC (pat);
   rtx dest = SET_DEST (pat);
-  static rtx frame_reg = NULL_RTX;
-  static int frame_size = 0;
+  int src_regno, dest_regno;
+
+  /* Look for the ALLOC insn.  */
+  if (GET_CODE (src) == UNSPEC_VOLATILE
+      && XINT (src, 1) == 0
+      && GET_CODE (dest) == REG)
+    {
+      dest_regno = REGNO (dest);
+
+      /* If this isn't the final destination for ar.pfs, the alloc
+	 shouldn't have been marked frame related.  */
+      if (dest_regno != current_frame_info.reg_save_ar_pfs)
+	abort ();
 
-  /* Look for the ALLOC insn.  reg = alloc .... */
-  if (GET_CODE (src) == UNSPEC_VOLATILE && XINT (src, 1) == 0
-      && GET_CODE (dest) == REG && GR_REGNO_P (REGNO (dest)))
-    {
-      /* Assume this is a stack allocate insn.  */
       fprintf (asm_out_file, "\t.save ar.pfs, r%d\n",
-	       REGNO (dest) + ia64_input_regs);
+	       ia64_dbx_register_number (dest_regno));
       return 1;
     }
 
-  /* look for SP = .... */
+  /* Look for SP = .... */
   if (GET_CODE (dest) == REG && REGNO (dest) == STACK_POINTER_REGNUM)
     {
       if (GET_CODE (src) == PLUS)
@@ -3423,166 +4683,175 @@ process_set (asm_out_file, pat)
 		  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC,
 			   -INTVAL (op1));
 		  fputc ('\n', asm_out_file);
-		  frame_size = INTVAL (op1);
 		}
 	      else
 		fprintf (asm_out_file, "\t.restore sp\n");
 	    }
-	  else if (op0 == dest && GET_CODE (op1) == REG)
-	    {
-	      /* ia64_expand_prologue uses r2 for stack pointer decrements,
-		 ia64_expand_epilogue uses r3 for stack pointer increments.  */
-	      if (REGNO (op1) == GR_REG (2))
-		{
-		  fprintf (asm_out_file, "\t.vframe r%d\n", REGNO (op1));
-		  frame_size = 0;
-		}
-	      else if (REGNO (op1) == GR_REG (3))
-		fprintf (asm_out_file, "\t.restore sp\n");
-	      else
-		abort ();
-	    }
 	  else
 	    abort ();
 	}
-      else if (GET_CODE (src) == REG && REGNO (src) == FRAME_POINTER_REGNUM)
+      else if (GET_CODE (src) == REG
+	       && REGNO (src) == HARD_FRAME_POINTER_REGNUM)
 	fprintf (asm_out_file, "\t.restore sp\n");
       else
 	abort ();
 
       return 1;
     }
-  /* Look for a frame offset.  */
-  if (GET_CODE (dest) == REG)
-    {
-      if (GET_CODE (src) == PLUS)
-        {
-	  rtx op0 = XEXP (src, 0);
-	  rtx op1 = XEXP (src, 1);
-	  if (GET_CODE (op0) == REG && REGNO (op0) == FRAME_POINTER_REGNUM
-	      && GET_CODE (op1) == CONST_INT)
-	    {
-	      sp_offset = -frame_size + INTVAL (op1);
-	      spill_offset = INTVAL (op1);
-	      spill_offset_emitted = 0;
-	      frame_reg = dest;
-	      /* We delay issuing the spill offset since we might
-		 be saving non-spill things off this register,
-		 thus adjusting its offset before a spill is seen.  */
-	      return 1;
-	    }
-	}
-    }
 
   /* Register move we need to look at.  */
   if (GET_CODE (dest) == REG && GET_CODE (src) == REG)
     {
-      int regno = REGNO (src);
-      if (BR_REGNO_P (regno))
-        {
+      src_regno = REGNO (src);
+      dest_regno = REGNO (dest);
+
+      switch (src_regno)
+	{
+	case BR_REG (0):
 	  /* Saving return address pointer.  */
-	  if (regno == BR_REG (0))
-	    {
-	      fprintf (asm_out_file, "\t.save rp, r%d\n",
-		       REGNO (dest) + ia64_input_regs);
-	      return 1;
-	    }
-	  /* If its br1 to br5, we copy them to temp regs, then save the
-	     temp reg to memory next.  */
-	  if (regno >= BR_REG (1) && regno <= BR_REG (5))
-	    {
-	      tmp_reg = dest;
-	      tmp_saved = regno;
-	      return 1;
-	    }
+	  if (dest_regno != current_frame_info.reg_save_b0)
+	    abort ();
+	  fprintf (asm_out_file, "\t.save rp, r%d\n",
+		   ia64_dbx_register_number (dest_regno));
+	  return 1;
+
+	case PR_REG (0):
+	  if (dest_regno != current_frame_info.reg_save_pr)
+	    abort ();
+	  fprintf (asm_out_file, "\t.save pr, r%d\n",
+		   ia64_dbx_register_number (dest_regno));
+	  return 1;
+
+	case AR_UNAT_REGNUM:
+	  if (dest_regno != current_frame_info.reg_save_ar_unat)
+	    abort ();
+	  fprintf (asm_out_file, "\t.save ar.unat, r%d\n",
+		   ia64_dbx_register_number (dest_regno));
+	  return 1;
+
+	case AR_LC_REGNUM:
+	  if (dest_regno != current_frame_info.reg_save_ar_lc)
+	    abort ();
+	  fprintf (asm_out_file, "\t.save ar.lc, r%d\n",
+		   ia64_dbx_register_number (dest_regno));
+	  return 1;
+
+	case STACK_POINTER_REGNUM:
+	  if (dest_regno != HARD_FRAME_POINTER_REGNUM
+	      || ! frame_pointer_needed)
+	    abort ();
+	  fprintf (asm_out_file, "\t.vframe r%d\n",
+		   ia64_dbx_register_number (dest_regno));
+	  return 1;
+
+	default:
+	  /* Everything else should indicate being stored to memory.  */
+	  abort ();
 	}
     }
-  /* Search for special reg moves.  */
-  if (GET_CODE (dest) == REG && GET_CODE (src) == UNSPEC)
+
+  /* Memory store we need to look at.  */
+  if (GET_CODE (dest) == MEM && GET_CODE (src) == REG)
     {
-      int unspec_code = XINT (src, 1);
-      /* Copied to a temp register, save it until we see the temp
-	 register stored.  */
-      if (unspec_code == 5 || unspec_code == 9)
+      long off;
+      rtx base;
+      const char *saveop;
+
+      if (GET_CODE (XEXP (dest, 0)) == REG)
 	{
-	  tmp_reg = dest;
-	  tmp_saved = unspec_code;
-	  return 1;
+	  base = XEXP (dest, 0);
+	  off = 0;
 	}
-    }
-  if (GET_CODE (dest) == MEM && GET_CODE (XEXP (dest, 0)) == POST_INC
-      && GET_CODE (XEXP (XEXP (dest, 0), 0)) == REG)
-    {
-      int spill_unspec = 0;
-      /* We adjust the spill_offset early, so we dont miss it later.  */
-      spill_offset += 8;
-      sp_offset += 8;
-      if (GET_CODE (src) == UNSPEC)
-	{
-	  spill_unspec = XINT (src, 1);
-	  /* 1 and 3 are unspecs for the GR and FR spills.  */
-	  if (spill_unspec != 1 && spill_unspec != 3)
-	    spill_unspec = 0;
+      else if (GET_CODE (XEXP (dest, 0)) == PLUS
+	       && GET_CODE (XEXP (XEXP (dest, 0), 1)) == CONST_INT)
+	{
+	  base = XEXP (XEXP (dest, 0), 0);
+	  off = INTVAL (XEXP (XEXP (dest, 0), 1));
 	}
-      /* ST8 or st8.spill insn.  */
-      if ((GET_CODE (src) == REG) || spill_unspec != 0)
-        {
-	  int regno;
-	  if (spill_unspec != 0)
-	    {
-	      regno = REGNO (XVECEXP (src, 0, 0));
-	      if (!spill_offset_emitted)
-	        {
-		  fprintf (asm_out_file, "\t.spill %d\n",
-			   (-(spill_offset - 8) + 16));
-		  spill_offset_emitted = 1;
-		}
-	    }
-	  else
-	    regno = REGNO (src);
+      else
+	abort ();
 
-          if (GR_REGNO_P (regno))
-	    {
-	      if (regno >= GR_REG (4) && regno <= GR_REG (7))
-		fprintf (asm_out_file, "\t.save.g 0x%x\n",
-			 1 << (regno - GR_REG (4)));
-	      else if (tmp_reg != NULL_RTX && regno == REGNO (tmp_reg))
-	        {
-		  /* We saved a special reg to a temp reg, and now we're
-		     dumping it to memory.  */
-		  tmp_reg = NULL_RTX;
-		  /* register 9 is ar.unat.  */
-		  if (tmp_saved == 9)
-		    fprintf (asm_out_file, "\t.savesp ar.unat, %d\n",
-			     (sp_offset - 8));
-		  else if (tmp_saved == 5)
-		    fprintf (asm_out_file, "\t.savesp pr, %d\n",
-			     (sp_offset - 8));
-		  else if (tmp_saved >= BR_REG (1) && tmp_saved <= BR_REG (5))
-		    {
-		      /* BR regs are saved this way too.  */
-		      fprintf (asm_out_file, "\t.save.b 0x%x\n",
-			       1 << (tmp_saved - BR_REG (1)));
-		    }
-		}
-	      else
-	        return 0;
-	    }
-	  if (FR_REGNO_P (regno))
-	    {
-	      if (regno >= FR_REG (2) && regno <= FR_REG (5))
-		fprintf (asm_out_file, "\t.save.f 0x%x\n",
-			 1 << (regno - FR_REG (2)));
-	      else
-		if (regno >= FR_REG (16) && regno <= FR_REG (31))
-		  fprintf (asm_out_file, "\t.save.gf 0x0, 0x%x\n",
-			   1 << (regno - FR_REG (12)));
-		else
-		  return 0;
-	    }
+      if (base == hard_frame_pointer_rtx)
+	{
+	  saveop = ".savepsp";
+	  off = - off;
+	}
+      else if (base == stack_pointer_rtx)
+	saveop = ".savesp";
+      else
+	abort ();
+
+      src_regno = REGNO (src);
+      switch (src_regno)
+	{
+	case BR_REG (0):
+	  if (current_frame_info.reg_save_b0 != 0)
+	    abort ();
+	  fprintf (asm_out_file, "\t%s rp, %ld\n", saveop, off);
+	  return 1;
+
+	case PR_REG (0):
+	  if (current_frame_info.reg_save_pr != 0)
+	    abort ();
+	  fprintf (asm_out_file, "\t%s pr, %ld\n", saveop, off);
+	  return 1;
+
+	case AR_LC_REGNUM:
+	  if (current_frame_info.reg_save_ar_lc != 0)
+	    abort ();
+	  fprintf (asm_out_file, "\t%s ar.lc, %ld\n", saveop, off);
+	  return 1;
+
+	case AR_PFS_REGNUM:
+	  if (current_frame_info.reg_save_ar_pfs != 0)
+	    abort ();
+	  fprintf (asm_out_file, "\t%s ar.pfs, %ld\n", saveop, off);
+	  return 1;
+
+	case AR_UNAT_REGNUM:
+	  if (current_frame_info.reg_save_ar_unat != 0)
+	    abort ();
+	  fprintf (asm_out_file, "\t%s ar.unat, %ld\n", saveop, off);
+	  return 1;
+
+	case GR_REG (4):
+	case GR_REG (5):
+	case GR_REG (6):
+	case GR_REG (7):
+	  fprintf (asm_out_file, "\t.save.g 0x%x\n",
+		   1 << (src_regno - GR_REG (4)));
+	  return 1;
+
+	case BR_REG (1):
+	case BR_REG (2):
+	case BR_REG (3):
+	case BR_REG (4):
+	case BR_REG (5):
+	  fprintf (asm_out_file, "\t.save.b 0x%x\n",
+		   1 << (src_regno - BR_REG (1)));
+	  return 1;
+
+	case FR_REG (2):
+	case FR_REG (3):
+	case FR_REG (4):
+	case FR_REG (5):
+	  fprintf (asm_out_file, "\t.save.f 0x%x\n",
+		   1 << (src_regno - FR_REG (2)));
+	  return 1;
+
+	case FR_REG (16): case FR_REG (17): case FR_REG (18): case FR_REG (19):
+	case FR_REG (20): case FR_REG (21): case FR_REG (22): case FR_REG (23):
+	case FR_REG (24): case FR_REG (25): case FR_REG (26): case FR_REG (27):
+	case FR_REG (28): case FR_REG (29): case FR_REG (30): case FR_REG (31):
+	  fprintf (asm_out_file, "\t.save.gf 0x0, 0x%x\n",
+		   1 << (src_regno - FR_REG (12)));
 	  return 1;
+
+	default:
+	  return 0;
 	}
     }
+
   return 0;
 }
 
@@ -3598,7 +4867,13 @@ process_for_unwind_directive (asm_out_fi
        || (flag_exceptions && !exceptions_via_longjmp))
       && RTX_FRAME_RELATED_P (insn))
     {
-      rtx pat = PATTERN (insn);
+      rtx pat;
+
+      pat = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);
+      if (pat)
+	pat = XEXP (pat, 0);
+      else
+	pat = PATTERN (insn);
 
       switch (GET_CODE (pat))
         {
@@ -3625,81 +4900,10 @@ process_for_unwind_directive (asm_out_fi
     }
 }
 
-#define def_builtin(name, type, code) \
-  builtin_function ((name), (type), (code), BUILT_IN_MD, NULL_PTR)
-
-struct builtin_description
-{
-  enum insn_code icode;
-  const char *name;
-  enum ia64_builtins code;
-  enum rtx_code comparison;
-  unsigned int flag;
-};
-
-/* All 32 bit intrinsics that take 2 arguments. */
-static struct builtin_description bdesc_2argsi[] =
-{
-  { CODE_FOR_fetch_and_add_si, "__sync_fetch_and_add_si",
-    IA64_BUILTIN_FETCH_AND_ADD_SI, 0, 0 },
-  { CODE_FOR_fetch_and_sub_si, "__sync_fetch_and_sub_si",
-    IA64_BUILTIN_FETCH_AND_SUB_SI, 0, 0 },
-  { CODE_FOR_fetch_and_or_si, "__sync_fetch_and_or_si",
-    IA64_BUILTIN_FETCH_AND_OR_SI, 0, 0 },
-  { CODE_FOR_fetch_and_and_si, "__sync_fetch_and_and_si",
-    IA64_BUILTIN_FETCH_AND_AND_SI, 0, 0 },
-  { CODE_FOR_fetch_and_xor_si, "__sync_fetch_and_xor_si",
-    IA64_BUILTIN_FETCH_AND_XOR_SI, 0, 0 },
-  { CODE_FOR_fetch_and_nand_si, "__sync_fetch_and_nand_si",
-    IA64_BUILTIN_FETCH_AND_NAND_SI, 0, 0 },
-  { CODE_FOR_add_and_fetch_si, "__sync_add_and_fetch_si",
-    IA64_BUILTIN_ADD_AND_FETCH_SI, 0, 0 },
-  { CODE_FOR_sub_and_fetch_si, "__sync_sub_and_fetch_si",
-    IA64_BUILTIN_SUB_AND_FETCH_SI, 0, 0 },
-  { CODE_FOR_or_and_fetch_si, "__sync_or_and_fetch_si",
-    IA64_BUILTIN_OR_AND_FETCH_SI, 0, 0 },
-  { CODE_FOR_and_and_fetch_si, "__sync_and_and_fetch_si",
-    IA64_BUILTIN_AND_AND_FETCH_SI, 0, 0 },
-  { CODE_FOR_xor_and_fetch_si, "__sync_xor_and_fetch_si",
-    IA64_BUILTIN_XOR_AND_FETCH_SI, 0, 0 },
-  { CODE_FOR_nand_and_fetch_si, "__sync_nand_and_fetch_si",
-    IA64_BUILTIN_NAND_AND_FETCH_SI, 0, 0 }
-};
-
-/* All 64 bit intrinsics that take 2 arguments. */
-static struct builtin_description bdesc_2argdi[] =
-{
-  { CODE_FOR_fetch_and_add_di, "__sync_fetch_and_add_di",
-    IA64_BUILTIN_FETCH_AND_ADD_DI, 0, 0 },
-  { CODE_FOR_fetch_and_sub_di, "__sync_fetch_and_sub_di",
-    IA64_BUILTIN_FETCH_AND_SUB_DI, 0, 0 },
-  { CODE_FOR_fetch_and_or_di, "__sync_fetch_and_or_di",
-    IA64_BUILTIN_FETCH_AND_OR_DI, 0, 0 },
-  { CODE_FOR_fetch_and_and_di, "__sync_fetch_and_and_di",
-    IA64_BUILTIN_FETCH_AND_AND_DI, 0, 0 },
-  { CODE_FOR_fetch_and_xor_di, "__sync_fetch_and_xor_di",
-    IA64_BUILTIN_FETCH_AND_XOR_DI, 0, 0 },
-  { CODE_FOR_fetch_and_nand_di, "__sync_fetch_and_nand_di",
-    IA64_BUILTIN_FETCH_AND_NAND_DI, 0, 0 },
-  { CODE_FOR_add_and_fetch_di, "__sync_add_and_fetch_di",
-    IA64_BUILTIN_ADD_AND_FETCH_DI, 0, 0 },
-  { CODE_FOR_sub_and_fetch_di, "__sync_sub_and_fetch_di",
-    IA64_BUILTIN_SUB_AND_FETCH_DI, 0, 0 },
-  { CODE_FOR_or_and_fetch_di, "__sync_or_and_fetch_di",
-    IA64_BUILTIN_OR_AND_FETCH_DI, 0, 0 },
-  { CODE_FOR_and_and_fetch_di, "__sync_and_and_fetch_di",
-    IA64_BUILTIN_AND_AND_FETCH_DI, 0, 0 },
-  { CODE_FOR_xor_and_fetch_di, "__sync_xor_and_fetch_di",
-    IA64_BUILTIN_XOR_AND_FETCH_DI, 0, 0 },
-  { CODE_FOR_nand_and_fetch_di, "__sync_nand_and_fetch_di",
-    IA64_BUILTIN_NAND_AND_FETCH_DI, 0, 0 }
-};
-
+
 void
 ia64_init_builtins ()
 {
-  size_t i;
-
   tree psi_type_node = build_pointer_type (integer_type_node);
   tree pdi_type_node = build_pointer_type (long_integer_type_node);
   tree endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);
@@ -3720,8 +4924,8 @@ ia64_init_builtins ()
                                       tree_cons (NULL_TREE,
 						 long_integer_type_node,
                                                  tree_cons (NULL_TREE,
-							    long_integer_type_node,
-                                                            endlink))));
+							long_integer_type_node,
+							endlink))));
   /* __sync_synchronize */
   tree void_ftype_void
     = build_function_type (void_type_node, endlink);
@@ -3749,15 +4953,15 @@ ia64_init_builtins ()
     = build_function_type (void_type_node, tree_cons (NULL_TREE, pdi_type_node,
 						      endlink));
 
+#define def_builtin(name, type, code) \
+  builtin_function ((name), (type), (code), BUILT_IN_MD, NULL_PTR)
+
   def_builtin ("__sync_val_compare_and_swap_si", si_ftype_psi_si_si,
 	       IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI);
-
   def_builtin ("__sync_val_compare_and_swap_di", di_ftype_pdi_di_di,
 	       IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI);
-
   def_builtin ("__sync_bool_compare_and_swap_si", si_ftype_psi_si_si,
 	       IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI);
-
   def_builtin ("__sync_bool_compare_and_swap_di", di_ftype_pdi_di_di,
 	       IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI);
 
@@ -3766,13 +4970,10 @@ ia64_init_builtins ()
 
   def_builtin ("__sync_lock_test_and_set_si", si_ftype_psi_si,
 	       IA64_BUILTIN_LOCK_TEST_AND_SET_SI);
-
   def_builtin ("__sync_lock_test_and_set_di", di_ftype_pdi_di,
 	       IA64_BUILTIN_LOCK_TEST_AND_SET_DI);
-
   def_builtin ("__sync_lock_release_si", void_ftype_psi,
 	       IA64_BUILTIN_LOCK_RELEASE_SI);
-
   def_builtin ("__sync_lock_release_di", void_ftype_pdi,
 	       IA64_BUILTIN_LOCK_RELEASE_DI);
 
@@ -3784,218 +4985,201 @@ ia64_init_builtins ()
 	       build_function_type (void_type_node, endlink), 
 	       IA64_BUILTIN_FLUSHRS);
 
-  /* Add all builtins that are operations on two args. */
-  for (i = 0; i < sizeof(bdesc_2argsi) / sizeof *bdesc_2argsi; i++)
-    def_builtin (bdesc_2argsi[i].name, si_ftype_psi_si, bdesc_2argsi[i].code);
-  for (i = 0; i < sizeof(bdesc_2argdi) / sizeof *bdesc_2argdi; i++)
-    def_builtin (bdesc_2argdi[i].name, si_ftype_psi_si, bdesc_2argdi[i].code);
+  def_builtin ("__sync_fetch_and_add_si", si_ftype_psi_si,
+	       IA64_BUILTIN_FETCH_AND_ADD_SI);
+  def_builtin ("__sync_fetch_and_sub_si", si_ftype_psi_si,
+	       IA64_BUILTIN_FETCH_AND_SUB_SI);
+  def_builtin ("__sync_fetch_and_or_si", si_ftype_psi_si,
+	       IA64_BUILTIN_FETCH_AND_OR_SI);
+  def_builtin ("__sync_fetch_and_and_si", si_ftype_psi_si,
+	       IA64_BUILTIN_FETCH_AND_AND_SI);
+  def_builtin ("__sync_fetch_and_xor_si", si_ftype_psi_si,
+	       IA64_BUILTIN_FETCH_AND_XOR_SI);
+  def_builtin ("__sync_fetch_and_nand_si", si_ftype_psi_si,
+	       IA64_BUILTIN_FETCH_AND_NAND_SI);
+
+  def_builtin ("__sync_add_and_fetch_si", si_ftype_psi_si,
+	       IA64_BUILTIN_ADD_AND_FETCH_SI);
+  def_builtin ("__sync_sub_and_fetch_si", si_ftype_psi_si,
+	       IA64_BUILTIN_SUB_AND_FETCH_SI);
+  def_builtin ("__sync_or_and_fetch_si", si_ftype_psi_si,
+	       IA64_BUILTIN_OR_AND_FETCH_SI);
+  def_builtin ("__sync_and_and_fetch_si", si_ftype_psi_si,
+	       IA64_BUILTIN_AND_AND_FETCH_SI);
+  def_builtin ("__sync_xor_and_fetch_si", si_ftype_psi_si,
+	       IA64_BUILTIN_XOR_AND_FETCH_SI);
+  def_builtin ("__sync_nand_and_fetch_si", si_ftype_psi_si,
+	       IA64_BUILTIN_NAND_AND_FETCH_SI);
+
+  def_builtin ("__sync_fetch_and_add_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_FETCH_AND_ADD_DI);
+  def_builtin ("__sync_fetch_and_sub_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_FETCH_AND_SUB_DI);
+  def_builtin ("__sync_fetch_and_or_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_FETCH_AND_OR_DI);
+  def_builtin ("__sync_fetch_and_and_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_FETCH_AND_AND_DI);
+  def_builtin ("__sync_fetch_and_xor_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_FETCH_AND_XOR_DI);
+  def_builtin ("__sync_fetch_and_nand_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_FETCH_AND_NAND_DI);
+
+  def_builtin ("__sync_add_and_fetch_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_ADD_AND_FETCH_DI);
+  def_builtin ("__sync_sub_and_fetch_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_SUB_AND_FETCH_DI);
+  def_builtin ("__sync_or_and_fetch_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_OR_AND_FETCH_DI);
+  def_builtin ("__sync_and_and_fetch_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_AND_AND_FETCH_DI);
+  def_builtin ("__sync_xor_and_fetch_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_XOR_AND_FETCH_DI);
+  def_builtin ("__sync_nand_and_fetch_di", di_ftype_pdi_di,
+	       IA64_BUILTIN_NAND_AND_FETCH_DI);
+
+#undef def_builtin
 }
 
 /* Expand fetch_and_op intrinsics.  The basic code sequence is:
 
      mf
-     ldsz return = [ptr];
-     tmp = return;
+     tmp = [ptr];
      do {
-       oldval = tmp;
+       ret = tmp;
        ar.ccv = tmp;
        tmp <op>= value;
        cmpxchgsz.acq tmp = [ptr], tmp
-       cmpxchgsz.acq tmp = [ptr], tmp
-     } while (tmp != oldval)
+     } while (tmp != ret)
 */
-void
-ia64_expand_fetch_and_op (code, mode, operands)
-     enum fetchop_code code;
+
+static rtx
+ia64_expand_fetch_and_op (binoptab, mode, arglist, target)
+     optab binoptab;
      enum machine_mode mode;
-     rtx operands[];
+     tree arglist;
+     rtx target;
 {
-  rtx oldval, newlabel;
-  rtx tmp_reg = gen_rtx_REG (mode, GR_REG(0));
-  rtx mfreg = gen_rtx_MEM (BLKmode, tmp_reg);
-  RTX_UNCHANGING_P (mfreg) = 1;
-  emit_insn (gen_mf (mfreg));
-  tmp_reg = gen_reg_rtx (mode);
-  oldval = gen_reg_rtx (mode);
+  rtx ret, label, tmp, ccv, insn, mem, value;
+  tree arg0, arg1;
 
-  if (mode == SImode)
-    {
-      emit_insn (gen_movsi (operands[0], operands[1]));
-      emit_insn (gen_movsi (tmp_reg, operands[0]));
-    }
-  else
-    {
-      emit_insn (gen_movdi (operands[0], operands[1]));
-      emit_insn (gen_movdi (tmp_reg, operands[0]));
-    }
+  arg0 = TREE_VALUE (arglist);
+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));
+  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);
+  value = expand_expr (arg1, NULL_RTX, mode, 0);
 
-  newlabel = gen_label_rtx ();
-  emit_label (newlabel);
-  if (mode == SImode)
-    {
-      emit_insn (gen_movsi (oldval, tmp_reg));
-      emit_insn (gen_ccv_restore_si (tmp_reg));
-    }
+  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));
+  MEM_VOLATILE_P (mem) = 1;
+
+  if (target && register_operand (target, mode))
+    ret = target;
   else
-    {
-      emit_insn (gen_movdi (oldval, tmp_reg));
-      emit_insn (gen_ccv_restore_di (tmp_reg));
-    }
+    ret = gen_reg_rtx (mode);
 
-  /* Perform the specific operation. */
-  switch (code)
-  {
-  case IA64_ADD_OP:
+  emit_insn (gen_mf ());
+
+  /* Special case for fetchadd instructions.  */
+  if (binoptab == add_optab && fetchadd_operand (value, VOIDmode))
     {
-      rtx reg;
-      if (GET_CODE (operands[2]) == CONST_INT)
-	reg = gen_reg_rtx (mode);
-      else
-        reg = operands[2];
       if (mode == SImode)
-	{
-	  if (reg != operands[2])
-	    emit_insn (gen_movsi (reg, operands[2]));
-	  emit_insn (gen_addsi3 (tmp_reg, tmp_reg, reg));
-	}
+        insn = gen_fetchadd_acq_si (ret, mem, value);
       else
-        {
-	  if (reg != operands[2])
-	    emit_insn (gen_movdi (reg, operands[2]));
-	  emit_insn (gen_adddi3 (tmp_reg, tmp_reg, reg));
-	}
-      break;
+        insn = gen_fetchadd_acq_di (ret, mem, value);
+      emit_insn (insn);
+      return ret;
     }
 
-  case IA64_SUB_OP:
-    if (mode == SImode)
-      emit_insn (gen_subsi3 (tmp_reg, tmp_reg, operands[2]));
-    else
-      emit_insn (gen_subdi3 (tmp_reg, tmp_reg, operands[2]));
-    break;
-
-  case IA64_OR_OP:
-    emit_insn (gen_iordi3 (tmp_reg, tmp_reg, operands[2]));
-    break;
-
-  case IA64_AND_OP:
-    emit_insn (gen_anddi3 (tmp_reg, tmp_reg, operands[2]));
-    break;
-
-  case IA64_XOR_OP:
-    emit_insn (gen_xordi3 (tmp_reg, tmp_reg, operands[2]));
-    break;
-
-  case IA64_NAND_OP:
-    emit_insn (gen_anddi3 (tmp_reg, tmp_reg, operands[2]));
-    if (mode == SImode)
-      emit_insn (gen_one_cmplsi2 (tmp_reg, operands[0]));
-    else
-      emit_insn (gen_one_cmpldi2 (tmp_reg, operands[0]));
-    break;
-
-  default:
-    break;
-  }
+  tmp = gen_reg_rtx (mode);
+  ccv = gen_rtx_REG (mode, AR_CCV_REGNUM);
+  emit_move_insn (tmp, mem);
+
+  label = gen_label_rtx ();
+  emit_label (label);
+  emit_move_insn (ret, tmp);
+  emit_move_insn (ccv, tmp);
+
+  /* Perform the specific operation.  Special case NAND by noticing
+     one_cmpl_optab instead.  */
+  if (binoptab == one_cmpl_optab)
+    {
+      tmp = expand_unop (mode, binoptab, tmp, NULL, OPTAB_WIDEN);
+      binoptab = and_optab;
+    }
+  tmp = expand_binop (mode, binoptab, tmp, value, tmp, 1, OPTAB_WIDEN);
 
   if (mode == SImode)
-    emit_insn (gen_cmpxchg_acq_si (tmp_reg, operands[1], tmp_reg));
+    insn = gen_cmpxchg_acq_si (tmp, mem, tmp, ccv);
   else
-    emit_insn (gen_cmpxchg_acq_di (tmp_reg, operands[1], tmp_reg));
+    insn = gen_cmpxchg_acq_di (tmp, mem, tmp, ccv);
+  emit_insn (insn);
+
+  emit_cmp_and_jump_insns (tmp, ret, NE, 0, mode, 1, 0, label);
 
-  emit_cmp_and_jump_insns (tmp_reg, oldval, NE, 0, mode, 1, 0, newlabel);
+  return ret;
 }
 
 /* Expand op_and_fetch intrinsics.  The basic code sequence is:
 
      mf
-     ldsz return = [ptr];
+     tmp = [ptr];
      do {
-       oldval = tmp;
+       old = tmp;
        ar.ccv = tmp;
-       return = tmp + value;
-       cmpxchgsz.acq tmp = [ptr], return
-     } while (tmp != oldval)
+       ret = tmp + value;
+       cmpxchgsz.acq tmp = [ptr], ret
+     } while (tmp != old)
 */
-void
-ia64_expand_op_and_fetch (code, mode, operands)
-     enum fetchop_code code;
+
+static rtx
+ia64_expand_op_and_fetch (binoptab, mode, arglist, target)
+     optab binoptab;
      enum machine_mode mode;
-     rtx operands[];
+     tree arglist;
+     rtx target;
 {
-  rtx oldval, newlabel;
-  rtx tmp_reg, tmp2_reg = gen_rtx_REG (mode, GR_REG(0));
-  rtx mfreg = gen_rtx_MEM (BLKmode, tmp2_reg);
-  RTX_UNCHANGING_P (mfreg) = 1;
+  rtx old, label, tmp, ret, ccv, insn, mem, value;
+  tree arg0, arg1;
 
-  emit_insn (gen_mf (mfreg));
-  tmp_reg = gen_reg_rtx (mode);
-  if (mode == SImode)
-    emit_insn (gen_movsi (tmp_reg, operands[1]));
-  else
-    emit_insn (gen_movdi (tmp_reg, operands[1]));
+  arg0 = TREE_VALUE (arglist);
+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));
+  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);
+  value = expand_expr (arg1, NULL_RTX, mode, 0);
 
-  newlabel = gen_label_rtx ();
-  emit_label (newlabel);
-  oldval = gen_reg_rtx (mode);
-  if (mode == SImode)
-    {
-      emit_insn (gen_movsi (oldval, tmp_reg));
-      emit_insn (gen_ccv_restore_si (tmp_reg));
-    }
-  else
+  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));
+  MEM_VOLATILE_P (mem) = 1;
+
+  if (target && ! register_operand (target, mode))
+    target = NULL_RTX;
+
+  emit_insn (gen_mf ());
+  tmp = gen_reg_rtx (mode);
+  old = gen_reg_rtx (mode);
+  ccv = gen_rtx_REG (mode, AR_CCV_REGNUM);
+
+  emit_move_insn (tmp, mem);
+
+  label = gen_label_rtx ();
+  emit_label (label);
+  emit_move_insn (old, tmp);
+  emit_move_insn (ccv, tmp);
+
+  /* Perform the specific operation.  Special case NAND by noticing
+     one_cmpl_optab instead.  */
+  if (binoptab == one_cmpl_optab)
     {
-      emit_insn (gen_movdi (oldval, tmp_reg));
-      emit_insn (gen_ccv_restore_di (tmp_reg));
+      tmp = expand_unop (mode, binoptab, tmp, NULL, OPTAB_WIDEN);
+      binoptab = and_optab;
     }
-
-  /* Perform the specific operation. */
-  switch (code)
-  {
-  case IA64_ADD_OP:
-    if (mode == SImode)
-      emit_insn (gen_addsi3 (operands[0], tmp_reg, operands[2]));
-    else
-      emit_insn (gen_adddi3 (operands[0], tmp_reg, operands[2]));
-    break;
-
-  case IA64_SUB_OP:
-    if (mode == SImode)
-      emit_insn (gen_subsi3 (operands[0], tmp_reg, operands[2]));
-    else
-      emit_insn (gen_subdi3 (operands[0], tmp_reg, operands[2]));
-    break;
-
-  case IA64_OR_OP:
-    emit_insn (gen_iordi3 (operands[0], tmp_reg, operands[2]));
-    break;
-
-  case IA64_AND_OP:
-    emit_insn (gen_anddi3 (operands[0], tmp_reg, operands[2]));
-    break;
-
-  case IA64_XOR_OP:
-    emit_insn (gen_xordi3 (operands[0], tmp_reg, operands[2]));
-    break;
-
-  case IA64_NAND_OP:
-    emit_insn (gen_anddi3 (operands[0], tmp_reg, operands[2]));
-    if (mode == SImode)
-      emit_insn (gen_one_cmplsi2 (operands[0], operands[0]));
-    else
-      emit_insn (gen_one_cmpldi2 (operands[0], operands[0]));
-    break;
-
-  default:
-    break;
-  }
+  ret = expand_binop (mode, binoptab, tmp, value, target, 1, OPTAB_WIDEN);
 
   if (mode == SImode)
-    emit_insn (gen_cmpxchg_acq_si (tmp_reg, operands[1], operands[0]));
+    insn = gen_cmpxchg_acq_si (tmp, mem, ret, ccv);
   else
-    emit_insn (gen_cmpxchg_acq_di (tmp_reg, operands[1], operands[0]));
+    insn = gen_cmpxchg_acq_di (tmp, mem, ret, ccv);
+  emit_insn (insn);
+
+  emit_cmp_and_jump_insns (tmp, old, NE, 0, mode, 1, 0, label);
 
-  emit_cmp_and_jump_insns (tmp_reg, oldval, NE, 0, mode, 1, 0, newlabel);
+  return ret;
 }
 
 /* Expand val_ and bool_compare_and_swap.  For val_ we want:
@@ -4007,89 +5191,111 @@ ia64_expand_op_and_fetch (code, mode, op
 
    For bool_ it's the same except return ret == oldval.
 */
+
 static rtx
-ia64_expand_compare_and_swap (icode, arglist, target, boolcode)
-     enum insn_code icode;
+ia64_expand_compare_and_swap (mode, boolp, arglist, target)
+     enum machine_mode mode;
+     int boolp;
      tree arglist;
      rtx target;
-     int boolcode;
 {
   tree arg0, arg1, arg2;
-  rtx op0, op1, op2, pat;
-  enum machine_mode tmode, mode0, mode1, mode2;
+  rtx mem, old, new, ccv, tmp, insn;
 
   arg0 = TREE_VALUE (arglist);
   arg1 = TREE_VALUE (TREE_CHAIN (arglist));
   arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));
-  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
-  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
-  op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);
-  tmode = insn_data[icode].operand[0].mode;
-  mode0 = insn_data[icode].operand[1].mode;
-  mode1 = insn_data[icode].operand[2].mode;
-  mode2 = insn_data[icode].operand[3].mode;
-
-  op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));
-  RTX_UNCHANGING_P (op0) = 1;
-  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))
-    op1 = copy_to_mode_reg (mode1, op1);
-  if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))
-    op2 = copy_to_mode_reg (mode2, op2);
-  if (target == 0
-      || GET_MODE (target) != tmode
-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))
-    target = gen_reg_rtx (tmode);
+  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);
+  old = expand_expr (arg1, NULL_RTX, mode, 0);
+  new = expand_expr (arg2, NULL_RTX, mode, 0);
+
+  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));
+  MEM_VOLATILE_P (mem) = 1;
+
+  if (! register_operand (old, mode))
+    old = copy_to_mode_reg (mode, old);
+  if (! register_operand (new, mode))
+    new = copy_to_mode_reg (mode, new);
 
-  pat = GEN_FCN (icode) (target, op0, op1, op2);
-  if (! pat)
-    return 0;
-  emit_insn (pat);
-  if (boolcode)
+  if (! boolp && target && register_operand (target, mode))
+    tmp = target;
+  else
+    tmp = gen_reg_rtx (mode);
+
+  ccv = gen_rtx_REG (mode, AR_CCV_REGNUM);
+  emit_move_insn (ccv, old);
+  emit_insn (gen_mf ());
+  if (mode == SImode)
+    insn = gen_cmpxchg_acq_si (tmp, mem, new, ccv);
+  else
+    insn = gen_cmpxchg_acq_di (tmp, mem, new, ccv);
+  emit_insn (insn);
+
+  if (boolp)
     {
-      if (tmode == SImode)
-        {
-          emit_insn (gen_cmpsi (target, op1));
-          emit_insn (gen_seq (gen_lowpart (DImode, target)));
-        }
-      else
-        {
-          emit_insn (gen_cmpdi (target, op1));
-          emit_insn (gen_seq (target));
-        }
+      if (! target)
+	target = gen_reg_rtx (mode);
+      return emit_store_flag_force (target, EQ, tmp, old, mode, 1, 1);
     }
-  return target;
+  else
+    return tmp;
 }
 
-/* Expand all intrinsics that take 2 arguments. */
+/* Expand lock_test_and_set.  I.e. `xchgsz ret = [ptr], new'.  */
+
 static rtx
-ia64_expand_binop_builtin (icode, arglist, target)
-     enum insn_code icode;
+ia64_expand_lock_test_and_set (mode, arglist, target)
+     enum machine_mode mode;
      tree arglist;
      rtx target;
 {
-  rtx pat;
-  tree arg0 = TREE_VALUE (arglist);
-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));
-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
-  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
-  enum machine_mode tmode = insn_data[icode].operand[0].mode;
-  enum machine_mode mode0 = insn_data[icode].operand[1].mode;
-  enum machine_mode mode1 = insn_data[icode].operand[2].mode;
-
-  if (! target
-      || GET_MODE (target) != tmode
-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))
-    target = gen_reg_rtx (tmode);
-
-  op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));
-  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))
-    op1 = copy_to_mode_reg (mode1, op1);
+  tree arg0, arg1;
+  rtx mem, new, ret, insn;
 
-  pat = GEN_FCN (icode) (target, op0, op1);
-  if (! pat)
-    return 0;
-  emit_insn (pat);
-  return target;
+  arg0 = TREE_VALUE (arglist);
+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));
+  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);
+  new = expand_expr (arg1, NULL_RTX, mode, 0);
+
+  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));
+  MEM_VOLATILE_P (mem) = 1;
+  if (! register_operand (new, mode))
+    new = copy_to_mode_reg (mode, new);
+
+  if (target && register_operand (target, mode))
+    ret = target;
+  else
+    ret = gen_reg_rtx (mode);
+
+  if (mode == SImode)
+    insn = gen_xchgsi (ret, mem, new);
+  else
+    insn = gen_xchgdi (ret, mem, new);
+  emit_insn (insn);
+
+  return ret;
+}
+
+/* Expand lock_release.  I.e. `stsz.rel [ptr] = r0'.  */
+
+static rtx
+ia64_expand_lock_release (mode, arglist, target)
+     enum machine_mode mode;
+     tree arglist;
+     rtx target ATTRIBUTE_UNUSED;
+{
+  tree arg0;
+  rtx mem;
+
+  arg0 = TREE_VALUE (arglist);
+  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);
+
+  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));
+  MEM_VOLATILE_P (mem) = 1;
+
+  emit_move_insn (mem, const0_rtx);
+
+  return const0_rtx;
 }
 
 rtx
@@ -4100,128 +5306,137 @@ ia64_expand_builtin (exp, target, subtar
      enum machine_mode mode ATTRIBUTE_UNUSED;
      int ignore ATTRIBUTE_UNUSED;
 {
-  rtx op0, op1, pat;
-  rtx tmp_reg;
-  tree arg0, arg1;
-  tree arglist = TREE_OPERAND (exp, 1);
   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);
-  int fcode = DECL_FUNCTION_CODE (fndecl);
-  enum machine_mode tmode, mode0, mode1;
-  enum insn_code icode;
-  size_t i;
-  struct builtin_description *d;
+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);
+  tree arglist = TREE_OPERAND (exp, 1);
 
   switch (fcode)
     {
     case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI:
-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_si,
-					   arglist, target, 1);
-
     case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI:
-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_si,
-					   arglist, target, 0);
+    case IA64_BUILTIN_LOCK_TEST_AND_SET_SI:
+    case IA64_BUILTIN_LOCK_RELEASE_SI:
+    case IA64_BUILTIN_FETCH_AND_ADD_SI:
+    case IA64_BUILTIN_FETCH_AND_SUB_SI:
+    case IA64_BUILTIN_FETCH_AND_OR_SI:
+    case IA64_BUILTIN_FETCH_AND_AND_SI:
+    case IA64_BUILTIN_FETCH_AND_XOR_SI:
+    case IA64_BUILTIN_FETCH_AND_NAND_SI:
+    case IA64_BUILTIN_ADD_AND_FETCH_SI:
+    case IA64_BUILTIN_SUB_AND_FETCH_SI:
+    case IA64_BUILTIN_OR_AND_FETCH_SI:
+    case IA64_BUILTIN_AND_AND_FETCH_SI:
+    case IA64_BUILTIN_XOR_AND_FETCH_SI:
+    case IA64_BUILTIN_NAND_AND_FETCH_SI:
+      mode = SImode;
+      break;
+
+    case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI:
+    case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI:
+    case IA64_BUILTIN_LOCK_TEST_AND_SET_DI:
+    case IA64_BUILTIN_LOCK_RELEASE_DI:
+    case IA64_BUILTIN_FETCH_AND_ADD_DI:
+    case IA64_BUILTIN_FETCH_AND_SUB_DI:
+    case IA64_BUILTIN_FETCH_AND_OR_DI:
+    case IA64_BUILTIN_FETCH_AND_AND_DI:
+    case IA64_BUILTIN_FETCH_AND_XOR_DI:
+    case IA64_BUILTIN_FETCH_AND_NAND_DI:
+    case IA64_BUILTIN_ADD_AND_FETCH_DI:
+    case IA64_BUILTIN_SUB_AND_FETCH_DI:
+    case IA64_BUILTIN_OR_AND_FETCH_DI:
+    case IA64_BUILTIN_AND_AND_FETCH_DI:
+    case IA64_BUILTIN_XOR_AND_FETCH_DI:
+    case IA64_BUILTIN_NAND_AND_FETCH_DI:
+      mode = DImode;
+      break;
+
+    default:
+      break;
+    }
 
+  switch (fcode)
+    {
+    case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI:
     case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI:
-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_di,
-					   arglist, target, 1);
+      return ia64_expand_compare_and_swap (mode, 1, arglist, target);
 
+    case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI:
     case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI:
-      return ia64_expand_compare_and_swap (CODE_FOR_val_compare_and_swap_di,
-					   arglist, target, 0);
+      return ia64_expand_compare_and_swap (mode, 0, arglist, target);
 
     case IA64_BUILTIN_SYNCHRONIZE:
-      /* Pass a volatile memory operand. */
-      tmp_reg = gen_rtx_REG (DImode, GR_REG(0));
-      target = gen_rtx_MEM (BLKmode, tmp_reg);
-      emit_insn (gen_mf (target));
+      emit_insn (gen_mf ());
       return const0_rtx;
 
     case IA64_BUILTIN_LOCK_TEST_AND_SET_SI:
-      icode = CODE_FOR_lock_test_and_set_si;
-      arg0 = TREE_VALUE (arglist);
-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));
-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
-      tmode = insn_data[icode].operand[0].mode;
-      mode0 = insn_data[icode].operand[1].mode;
-      mode1 = insn_data[icode].operand[2].mode;
-      op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));
-      RTX_UNCHANGING_P (op0) = 1;
-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))
-        op1 = copy_to_mode_reg (mode1, op1);
-      if (target == 0
-          || GET_MODE (target) != tmode
-          || ! (*insn_data[icode].operand[0].predicate) (target, tmode))
-        target = gen_reg_rtx (tmode);
-      pat = GEN_FCN (icode) (target, op0, op1);
-      if (! pat)
-        return 0;
-      emit_insn (pat);
-      return target;
-
     case IA64_BUILTIN_LOCK_TEST_AND_SET_DI:
-      icode = CODE_FOR_lock_test_and_set_di;
-      arg0 = TREE_VALUE (arglist);
-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));
-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
-      tmode = insn_data[icode].operand[0].mode;
-      mode0 = insn_data[icode].operand[1].mode;
-      mode1 = insn_data[icode].operand[2].mode;
-      op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));
-      RTX_UNCHANGING_P (op0) = 1;
-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))
-        op1 = copy_to_mode_reg (mode1, op1);
-      if (target == 0
-          || GET_MODE (target) != tmode
-          || ! (*insn_data[icode].operand[0].predicate) (target, tmode))
-        target = gen_reg_rtx (tmode);
-      pat = GEN_FCN (icode) (target, op0, op1);
-      if (! pat)
-        return 0;
-      emit_insn (pat);
-      return target;
+      return ia64_expand_lock_test_and_set (mode, arglist, target);
 
     case IA64_BUILTIN_LOCK_RELEASE_SI:
-      arg0 = TREE_VALUE (arglist);
-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
-      op0 = gen_rtx_MEM (SImode, copy_to_mode_reg (Pmode, op0));
-      MEM_VOLATILE_P (op0) = 1;
-      emit_insn (gen_movsi (op0, GEN_INT(0)));
-      return const0_rtx;
-
     case IA64_BUILTIN_LOCK_RELEASE_DI:
-      arg0 = TREE_VALUE (arglist);
-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
-      op0 = gen_rtx_MEM (DImode, copy_to_mode_reg (Pmode, op0));
-      MEM_VOLATILE_P (op0) = 1;
-      emit_insn (gen_movdi (op0, GEN_INT(0)));
-      return const0_rtx;
+      return ia64_expand_lock_release (mode, arglist, target);
 
     case IA64_BUILTIN_BSP:
-      {
-	rtx reg = gen_reg_rtx (DImode);
-	emit_insn (gen_bsp_value (reg));
-	return reg;
-      }
+      if (! target || ! register_operand (target, DImode))
+	target = gen_reg_rtx (DImode);
+      emit_insn (gen_bsp_value (target));
+      return target;
 
     case IA64_BUILTIN_FLUSHRS:
       emit_insn (gen_flushrs ());
       return const0_rtx;
 
+    case IA64_BUILTIN_FETCH_AND_ADD_SI:
+    case IA64_BUILTIN_FETCH_AND_ADD_DI:
+      return ia64_expand_fetch_and_op (add_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_FETCH_AND_SUB_SI:
+    case IA64_BUILTIN_FETCH_AND_SUB_DI:
+      return ia64_expand_fetch_and_op (sub_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_FETCH_AND_OR_SI:
+    case IA64_BUILTIN_FETCH_AND_OR_DI:
+      return ia64_expand_fetch_and_op (ior_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_FETCH_AND_AND_SI:
+    case IA64_BUILTIN_FETCH_AND_AND_DI:
+      return ia64_expand_fetch_and_op (and_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_FETCH_AND_XOR_SI:
+    case IA64_BUILTIN_FETCH_AND_XOR_DI:
+      return ia64_expand_fetch_and_op (xor_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_FETCH_AND_NAND_SI:
+    case IA64_BUILTIN_FETCH_AND_NAND_DI:
+      return ia64_expand_fetch_and_op (one_cmpl_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_ADD_AND_FETCH_SI:
+    case IA64_BUILTIN_ADD_AND_FETCH_DI:
+      return ia64_expand_op_and_fetch (add_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_SUB_AND_FETCH_SI:
+    case IA64_BUILTIN_SUB_AND_FETCH_DI:
+      return ia64_expand_op_and_fetch (sub_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_OR_AND_FETCH_SI:
+    case IA64_BUILTIN_OR_AND_FETCH_DI:
+      return ia64_expand_op_and_fetch (ior_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_AND_AND_FETCH_SI:
+    case IA64_BUILTIN_AND_AND_FETCH_DI:
+      return ia64_expand_op_and_fetch (and_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_XOR_AND_FETCH_SI:
+    case IA64_BUILTIN_XOR_AND_FETCH_DI:
+      return ia64_expand_op_and_fetch (xor_optab, mode, arglist, target);
+
+    case IA64_BUILTIN_NAND_AND_FETCH_SI:
+    case IA64_BUILTIN_NAND_AND_FETCH_DI:
+      return ia64_expand_op_and_fetch (one_cmpl_optab, mode, arglist, target);
+
     default:
       break;
     }
 
-  /* Expand all 32 bit intrinsics that take 2 arguments. */
-  for (i=0, d = bdesc_2argsi; i < sizeof (bdesc_2argsi) / sizeof *d; i++, d++)
-    if (d->code == fcode)
-      return ia64_expand_binop_builtin (d->icode, arglist, target);
-
-  /* Expand all 64 bit intrinsics that take 2 arguments. */
-  for (i=0, d = bdesc_2argdi; i < sizeof (bdesc_2argdi) / sizeof *d; i++, d++)
-    if (d->code == fcode)
-      return ia64_expand_binop_builtin (d->icode, arglist, target);
-
-  return 0;
+  return NULL_RTX;
 }
--- gcc/config/ia64/ia64.h.jj	Mon Jul 31 20:02:16 2000
+++ gcc/config/ia64/ia64.h	Thu Nov 16 22:03:18 2000
@@ -20,19 +20,12 @@ along with GNU CC; see the file COPYING.
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-/* ??? Use of the upper 32 FP registers for integer values will make context
-   switching slower, because the kernel only saves any registers past f32 if
-   it has to.  */
-
 /* ??? Look at ABI group documents for list of preprocessor macros and
    other features required for ABI compliance.  */
 
 /* ??? Functions containing a non-local goto target save many registers.  Why?
    See for instance execute/920428-2.c.  */
 
-/* ??? Get CAN_DEBUG_WITHOUT_FP working so that -fomit-frame-pointer is not
-   needed.  */
-
 /* ??? Add support for short data/bss sections.  */
 
 
@@ -62,13 +55,15 @@ extern int target_flags;
 
 #define MASK_A_STEP	0x00000020	/* Emit code for Itanium A step.  */
 
-#define MASK_REG_NAMES	0x00000040	/* Use in/loc/out register names.  */
+#define MASK_B_STEP	0x00000040	/* Emit code for Itanium B step.  */
+
+#define MASK_REG_NAMES	0x00000080	/* Use in/loc/out register names.  */
 
-#define MASK_NO_SDATA   0x00000080	/* Disable sdata/scommon/sbss.  */
+#define MASK_NO_SDATA   0x00000100	/* Disable sdata/scommon/sbss.  */
 
-#define MASK_CONST_GP	0x00000100	/* treat gp as program-wide constant */
+#define MASK_CONST_GP	0x00000200	/* treat gp as program-wide constant */
 
-#define MASK_AUTO_PIC	0x00000200	/* generate automatically PIC */
+#define MASK_AUTO_PIC	0x00000400	/* generate automatically PIC */
 
 #define MASK_DWARF2_ASM 0x40000000	/* test dwarf2 line info via gas.  */
 
@@ -84,6 +79,8 @@ extern int target_flags;
 
 #define TARGET_A_STEP		(target_flags & MASK_A_STEP)
 
+#define TARGET_B_STEP		(target_flags & MASK_B_STEP)
+
 #define TARGET_REG_NAMES	(target_flags & MASK_REG_NAMES)
 
 #define TARGET_NO_SDATA		(target_flags & MASK_NO_SDATA)
@@ -120,6 +117,8 @@ extern int target_flags;
       N_("Don't emit stop bits before and after volatile extended asms") }, \
   { "a-step",		MASK_A_STEP,					\
       N_("Emit code for Itanium (TM) processor A step")},		\
+  { "b-step",		MASK_B_STEP,					\
+      N_("Emit code for Itanium (TM) processor B step")},		\
   { "register-names",	MASK_REG_NAMES,					\
       N_("Use in/loc/out register names")},				\
   { "no-sdata",		MASK_NO_SDATA,					\
@@ -178,13 +177,6 @@ extern const char *ia64_fixed_range_stri
    default values for the other command line options.  */
 
 /* #define OPTIMIZATION_OPTIONS(LEVEL,SIZE) */
-
-/* Define this macro if debugging can be performed even without a frame
-   pointer.  If this macro is defined, GNU CC will turn on the
-   `-fomit-frame-pointer' option whenever `-O' is specified.  */
-/* ??? Need to define this.  */
-/* #define CAN_DEBUG_WITHOUT_FP */
-
 
 /* Driver configuration */
 
@@ -238,10 +230,13 @@ extern const char *ia64_fixed_range_stri
 
 #if ((TARGET_CPU_DEFAULT | TARGET_DEFAULT) & MASK_GNU_AS) != 0
 /* GNU AS.  */
-#define ASM_SPEC "%{mno-gnu-as:-N so}%{!mno-gnu-as: -x}"
+#define ASM_SPEC \
+  "%{mno-gnu-as:-N so} %{!mno-gnu-as:-x} %{mconstant-gp} %{mauto-pic}"
 #else
 /* Intel ias.  */
-#define ASM_SPEC "%{!mgnu-as:-N so}%{mgnu-as: -x}"
+#define ASM_SPEC \
+  "%{!mgnu-as:-N so} %{mgnu-as:-x} %{mconstant-gp:-M const_gp}\
+   %{mauto-pic:-M no_plabel}"
 #endif
 
 /* A C string constant that tells the GNU CC driver program options to pass to
@@ -257,7 +252,6 @@ extern const char *ia64_fixed_range_stri
 /* Intel ild.  */
 #define LINK_SPEC "%{!mgnu-ld:-dn -N so}"
 #endif
-
 
 /* Storage Layout */
 
@@ -314,15 +308,12 @@ extern const char *ia64_fixed_range_stri
 /* A macro to update MODE and UNSIGNEDP when an object whose type is TYPE and
    which has the specified mode and signedness is to be stored in a register.
    This macro is only called when TYPE is a scalar type.  */
-
-/* ??? Maybe sign-extend 32 bit values like the alpha?  Or maybe zero-extend
-   because we only have zero-extending loads? */
 #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)				\
 do									\
   {									\
     if (GET_MODE_CLASS (MODE) == MODE_INT				\
-	&& GET_MODE_SIZE (MODE) < UNITS_PER_WORD)			\
-      (MODE) = DImode;							\
+	&& GET_MODE_SIZE (MODE) < 4)					\
+      (MODE) = SImode;							\
   }									\
 while (0)
 
@@ -380,8 +371,8 @@ while (0)
    used instead of that alignment to align the object.  */
 
 #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \
-  (TREE_CODE (EXP) == STRING_CST	\
-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))
+  (TREE_CODE (EXP) == STRING_CST && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD \
+   : (ALIGN))
 
 /* Define this macro to be the value 1 if instructions will fail to work if
    given data not on the nominal alignment.  If instructions will merely go
@@ -397,23 +388,6 @@ while (0)
    a field, not crossing a boundary for it.  */
 #define PCC_BITFIELD_TYPE_MATTERS 1
 
-/* Define this macro as an expression for the overall size of a structure
-   (given by STRUCT as a tree node) when the size computed from the fields is
-   SIZE and the alignment is ALIGN.
-
-   The default is to round SIZE up to a multiple of ALIGN.  */
-/* ??? Might need this for 80-bit double-extended floats.  */
-/* #define ROUND_TYPE_SIZE(STRUCT, SIZE, ALIGN) */
-
-/* Define this macro as an expression for the alignment of a structure (given
-   by STRUCT as a tree node) if the alignment computed in the usual way is
-   COMPUTED and the alignment explicitly specified was SPECIFIED.
-
-   The default is to use SPECIFIED if it is larger; otherwise, use the smaller
-   of COMPUTED and `BIGGEST_ALIGNMENT' */
-/* ??? Might need this for 80-bit double-extended floats.  */
-/* #define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED) */
-
 /* An integer expression for the size in bits of the largest integer machine
    mode that should actually be used.  */
 
@@ -479,8 +453,11 @@ while (0)
 
 /* A C expression for the size in bits of the type `long double' on the target
    machine.  If you don't define this, the default is two words.  */
-/* ??? We have an 80 bit extended double format.  */
-#define LONG_DOUBLE_TYPE_SIZE 64
+#define LONG_DOUBLE_TYPE_SIZE 128
+
+/* Tell real.c that this is the 80-bit Intel extended float format
+   packaged in a 128-bit entity.  */
+#define INTEL_EXTENDED_IEEE_FORMAT
 
 /* An expression whose value is 1 or 0, according to whether the type `char'
    should be signed or unsigned by default.  The user can always override this
@@ -539,7 +516,7 @@ while (0)
    64 predicate registers, 8 branch registers, one frame pointer,
    and several "application" registers.  */
 
-#define FIRST_PSEUDO_REGISTER 334
+#define FIRST_PSEUDO_REGISTER 335
 
 /* Ranges for the various kinds of registers.  */
 #define ADDL_REGNO_P(REGNO) ((unsigned HOST_WIDE_INT) (REGNO) <= 3)
@@ -561,22 +538,23 @@ while (0)
 #define LOC_REG(REGNO) ((REGNO) + 32)
 
 #define AR_CCV_REGNUM	330
-#define AR_LC_REGNUM	331
-#define AR_EC_REGNUM	332
-#define AR_PFS_REGNUM	333
+#define AR_UNAT_REGNUM  331
+#define AR_PFS_REGNUM	332
+#define AR_LC_REGNUM	333
+#define AR_EC_REGNUM	334
 
 #define IN_REGNO_P(REGNO) ((REGNO) >= IN_REG (0) && (REGNO) <= IN_REG (7))
 #define LOC_REGNO_P(REGNO) ((REGNO) >= LOC_REG (0) && (REGNO) <= LOC_REG (79))
 #define OUT_REGNO_P(REGNO) ((REGNO) >= OUT_REG (0) && (REGNO) <= OUT_REG (7))
 
-#define AR_M_REGNO_P(REGNO) ((REGNO) == AR_CCV_REGNUM)
-#define AR_I_REGNO_P(REGNO) ((REGNO) >= AR_LC_REGNUM \
+#define AR_M_REGNO_P(REGNO) ((REGNO) == AR_CCV_REGNUM \
+			     || (REGNO) == AR_UNAT_REGNUM)
+#define AR_I_REGNO_P(REGNO) ((REGNO) >= AR_PFS_REGNUM \
 			     && (REGNO) < FIRST_PSEUDO_REGISTER)
 #define AR_REGNO_P(REGNO) ((REGNO) >= AR_CCV_REGNUM \
 			   && (REGNO) < FIRST_PSEUDO_REGISTER)
 
 
-
 /* ??? Don't really need two sets of macros.  I like this one better because
    it is less typing.  */
 #define R_GR(REGNO) GR_REG (REGNO)
@@ -600,11 +578,6 @@ while (0)
 /* The last 16 stacked regs are reserved for the 8 input and 8 output
    registers.  */
 
-/* ??? Must mark the next 3 stacked regs as fixed, because ia64_expand_prologue
-   assumes that three locals are available for fp, b0, and ar.pfs.  */
-
-/* ??? Should mark b0 as fixed?  */
-
 #define FIXED_REGISTERS \
 { /* General registers.  */				\
   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,	\
@@ -613,7 +586,7 @@ while (0)
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,	\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   /* Floating-point registers.  */			\
   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
@@ -631,8 +604,8 @@ while (0)
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   /* Branch registers.  */				\
   0, 0, 0, 0, 0, 0, 0, 0,				\
-  /*FP RA CCV LC EC PFS */				\
-     1, 1,  1, 1, 1,  1					\
+  /*FP RA CCV UNAT PFS LC EC */				\
+     1, 1,  1,   1,  1, 0, 1				\
  }
 
 /* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered
@@ -648,7 +621,7 @@ while (0)
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,	\
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,	\
   /* Floating-point registers.  */			\
   1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	\
@@ -666,8 +639,8 @@ while (0)
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	\
   /* Branch registers.  */				\
   1, 0, 0, 0, 0, 0, 1, 1,				\
-  /*FP RA CCV LC EC PFS */				\
-     1, 1,  1, 1, 1,  1					\
+  /*FP RA CCV UNAT PFS LC EC */				\
+     1, 1,  1,   1,  1, 0, 1				\
 }
 
 /* Define this macro if the target machine has register windows.  This C
@@ -686,6 +659,26 @@ while (0)
 #define OUTGOING_REGNO(IN) \
   ((unsigned) ((IN) - IN_REG (0)) < 8 ? OUT_REG ((IN) - IN_REG (0)) : (IN))
 
+/* Define this macro if the target machine has register windows.  This
+   C expression returns true if the register is call-saved but is in the
+   register window.  */
+
+#define LOCAL_REGNO(REGNO) \
+  (IN_REGNO_P (REGNO) || LOC_REGNO_P (REGNO))
+
+/* Add any extra modes needed to represent the condition code.
+
+   CCImode is used to mark a single predicate register instead
+   of a register pair.  This is currently only used in reg_raw_mode
+   so that flow doesn't do something stupid.  */
+
+#define EXTRA_CC_MODES		CC(CCImode, "CCI")
+
+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,
+   return the mode to be used for the comparison.  Must be defined if
+   EXTRA_CC_MODES is defined.  */
+
+#define SELECT_CC_MODE(OP,X,Y)  CCmode
 
 /* Order of allocation of registers */
 
@@ -705,72 +698,72 @@ while (0)
 /* ??? Should the GR return value registers come before or after the rest
    of the caller-save GRs?  */
 
-#define REG_ALLOC_ORDER \
+#define REG_ALLOC_ORDER							   \
 {									   \
   /* Caller-saved general registers.  */				   \
-  R_GR (14), R_GR (15), R_GR (16), R_GR (17), 				   \
-  R_GR (18), R_GR (19), R_GR (20), R_GR (21), R_GR (22), R_GR (23), 	   \
-  R_GR (24), R_GR (25), R_GR (26), R_GR (27), R_GR (28), R_GR (29), 	   \
+  R_GR (14), R_GR (15), R_GR (16), R_GR (17),				   \
+  R_GR (18), R_GR (19), R_GR (20), R_GR (21), R_GR (22), R_GR (23),	   \
+  R_GR (24), R_GR (25), R_GR (26), R_GR (27), R_GR (28), R_GR (29),	   \
   R_GR (30), R_GR (31),							   \
   /* Output registers.  */						   \
   R_GR (120), R_GR (121), R_GR (122), R_GR (123), R_GR (124), R_GR (125),  \
-  R_GR (126), R_GR (127), 						   \
+  R_GR (126), R_GR (127),						   \
   /* Caller-saved general registers, also used for return values.  */	   \
-  R_GR (8), R_GR (9), R_GR (10), R_GR (11), 				   \
+  R_GR (8), R_GR (9), R_GR (10), R_GR (11),				   \
   /* addl caller-saved general registers.  */				   \
   R_GR (2), R_GR (3),							   \
   /* Caller-saved FP registers.  */					   \
   R_FR (6), R_FR (7),							   \
   /* Caller-saved FP registers, used for parameters and return values.  */ \
-  R_FR (8), R_FR (9), R_FR (10), R_FR (11), 				   \
-  R_FR (12), R_FR (13), R_FR (14), R_FR (15), 				   \
+  R_FR (8), R_FR (9), R_FR (10), R_FR (11),				   \
+  R_FR (12), R_FR (13), R_FR (14), R_FR (15),				   \
   /* Rotating caller-saved FP registers.  */				   \
-  R_FR (32), R_FR (33), R_FR (34), R_FR (35), 				   \
-  R_FR (36), R_FR (37), R_FR (38), R_FR (39), R_FR (40), R_FR (41), 	   \
-  R_FR (42), R_FR (43), R_FR (44), R_FR (45), R_FR (46), R_FR (47), 	   \
-  R_FR (48), R_FR (49), R_FR (50), R_FR (51), R_FR (52), R_FR (53), 	   \
-  R_FR (54), R_FR (55), R_FR (56), R_FR (57), R_FR (58), R_FR (59), 	   \
-  R_FR (60), R_FR (61), R_FR (62), R_FR (63), R_FR (64), R_FR (65), 	   \
-  R_FR (66), R_FR (67), R_FR (68), R_FR (69), R_FR (70), R_FR (71), 	   \
-  R_FR (72), R_FR (73), R_FR (74), R_FR (75), R_FR (76), R_FR (77), 	   \
-  R_FR (78), R_FR (79), R_FR (80), R_FR (81), R_FR (82), R_FR (83), 	   \
-  R_FR (84), R_FR (85), R_FR (86), R_FR (87), R_FR (88), R_FR (89), 	   \
-  R_FR (90), R_FR (91), R_FR (92), R_FR (93), R_FR (94), R_FR (95), 	   \
-  R_FR (96), R_FR (97), R_FR (98), R_FR (99), R_FR (100), R_FR (101), 	   \
+  R_FR (32), R_FR (33), R_FR (34), R_FR (35),				   \
+  R_FR (36), R_FR (37), R_FR (38), R_FR (39), R_FR (40), R_FR (41),	   \
+  R_FR (42), R_FR (43), R_FR (44), R_FR (45), R_FR (46), R_FR (47),	   \
+  R_FR (48), R_FR (49), R_FR (50), R_FR (51), R_FR (52), R_FR (53),	   \
+  R_FR (54), R_FR (55), R_FR (56), R_FR (57), R_FR (58), R_FR (59),	   \
+  R_FR (60), R_FR (61), R_FR (62), R_FR (63), R_FR (64), R_FR (65),	   \
+  R_FR (66), R_FR (67), R_FR (68), R_FR (69), R_FR (70), R_FR (71),	   \
+  R_FR (72), R_FR (73), R_FR (74), R_FR (75), R_FR (76), R_FR (77),	   \
+  R_FR (78), R_FR (79), R_FR (80), R_FR (81), R_FR (82), R_FR (83),	   \
+  R_FR (84), R_FR (85), R_FR (86), R_FR (87), R_FR (88), R_FR (89),	   \
+  R_FR (90), R_FR (91), R_FR (92), R_FR (93), R_FR (94), R_FR (95),	   \
+  R_FR (96), R_FR (97), R_FR (98), R_FR (99), R_FR (100), R_FR (101),	   \
   R_FR (102), R_FR (103), R_FR (104), R_FR (105), R_FR (106), R_FR (107),  \
   R_FR (108), R_FR (109), R_FR (110), R_FR (111), R_FR (112), R_FR (113),  \
   R_FR (114), R_FR (115), R_FR (116), R_FR (117), R_FR (118), R_FR (119),  \
   R_FR (120), R_FR (121), R_FR (122), R_FR (123), R_FR (124), R_FR (125),  \
-  R_FR (126), R_FR (127), 						   \
+  R_FR (126), R_FR (127),						   \
   /* Caller-saved predicate registers.  */				   \
-  R_PR (6), R_PR (7), R_PR (8), R_PR (9), R_PR (10), R_PR (11), 	   \
+  R_PR (6), R_PR (7), R_PR (8), R_PR (9), R_PR (10), R_PR (11),		   \
   R_PR (12), R_PR (13), R_PR (14), R_PR (15),				   \
   /* Rotating caller-saved predicate registers.  */			   \
-  R_PR (16), R_PR (17), 						   \
-  R_PR (18), R_PR (19), R_PR (20), R_PR (21), R_PR (22), R_PR (23), 	   \
-  R_PR (24), R_PR (25), R_PR (26), R_PR (27), R_PR (28), R_PR (29), 	   \
-  R_PR (30), R_PR (31), R_PR (32), R_PR (33), R_PR (34), R_PR (35), 	   \
-  R_PR (36), R_PR (37), R_PR (38), R_PR (39), R_PR (40), R_PR (41), 	   \
-  R_PR (42), R_PR (43), R_PR (44), R_PR (45), R_PR (46), R_PR (47), 	   \
-  R_PR (48), R_PR (49), R_PR (50), R_PR (51), R_PR (52), R_PR (53), 	   \
-  R_PR (54), R_PR (55), R_PR (56), R_PR (57), R_PR (58), R_PR (59), 	   \
-  R_PR (60), R_PR (61), R_PR (62), R_PR (63), 				   \
+  R_PR (16), R_PR (17),							   \
+  R_PR (18), R_PR (19), R_PR (20), R_PR (21), R_PR (22), R_PR (23),	   \
+  R_PR (24), R_PR (25), R_PR (26), R_PR (27), R_PR (28), R_PR (29),	   \
+  R_PR (30), R_PR (31), R_PR (32), R_PR (33), R_PR (34), R_PR (35),	   \
+  R_PR (36), R_PR (37), R_PR (38), R_PR (39), R_PR (40), R_PR (41),	   \
+  R_PR (42), R_PR (43), R_PR (44), R_PR (45), R_PR (46), R_PR (47),	   \
+  R_PR (48), R_PR (49), R_PR (50), R_PR (51), R_PR (52), R_PR (53),	   \
+  R_PR (54), R_PR (55), R_PR (56), R_PR (57), R_PR (58), R_PR (59),	   \
+  R_PR (60), R_PR (61), R_PR (62), R_PR (63),				   \
   /* Caller-saved branch registers.  */					   \
   R_BR (6), R_BR (7),							   \
 									   \
   /* Stacked callee-saved general registers.  */			   \
-  R_GR (32), R_GR (33), R_GR (34), R_GR (35), 				   \
-  R_GR (36), R_GR (37), R_GR (38), R_GR (39), R_GR (40), R_GR (41), 	   \
-  R_GR (42), R_GR (43), R_GR (44), R_GR (45), R_GR (46), R_GR (47), 	   \
-  R_GR (48), R_GR (49), R_GR (50), R_GR (51), R_GR (52), R_GR (53), 	   \
-  R_GR (54), R_GR (55), R_GR (56), R_GR (57), R_GR (58), R_GR (59), 	   \
-  R_GR (60), R_GR (61), R_GR (62), R_GR (63), R_GR (64), R_GR (65), 	   \
-  R_GR (66), R_GR (67), R_GR (68), R_GR (69), R_GR (70), R_GR (71), 	   \
-  R_GR (72), R_GR (73), R_GR (74), R_GR (75), R_GR (76), R_GR (77), 	   \
-  R_GR (78), R_GR (79), R_GR (80), R_GR (81), R_GR (82), R_GR (83), 	   \
-  R_GR (84), R_GR (85), R_GR (86), R_GR (87), R_GR (88), R_GR (89), 	   \
-  R_GR (90), R_GR (91), R_GR (92), R_GR (93), R_GR (94), R_GR (95), 	   \
-  R_GR (96), R_GR (97), R_GR (98), R_GR (99), R_GR (100), R_GR (101), 	   \
+  R_GR (32), R_GR (33), R_GR (34), R_GR (35),				   \
+  R_GR (36), R_GR (37), R_GR (38), R_GR (39), R_GR (40), R_GR (41),	   \
+  R_GR (42), R_GR (43), R_GR (44), R_GR (45), R_GR (46), R_GR (47),	   \
+  R_GR (48), R_GR (49), R_GR (50), R_GR (51), R_GR (52), R_GR (53),	   \
+  R_GR (54), R_GR (55), R_GR (56), R_GR (57), R_GR (58), R_GR (59),	   \
+  R_GR (60), R_GR (61), R_GR (62), R_GR (63), R_GR (64), R_GR (65),	   \
+  R_GR (66), R_GR (67), R_GR (68), R_GR (69), R_GR (70), R_GR (71),	   \
+  R_GR (72), R_GR (73), R_GR (74), R_GR (75), R_GR (76), R_GR (77),	   \
+  R_GR (78), R_GR (79), R_GR (80), R_GR (81), R_GR (82), R_GR (83),	   \
+  R_GR (84), R_GR (85), R_GR (86), R_GR (87), R_GR (88), R_GR (89),	   \
+  R_GR (90), R_GR (91), R_GR (92), R_GR (93), R_GR (94), R_GR (95),	   \
+  R_GR (96), R_GR (97), R_GR (98), R_GR (99), R_GR (100), R_GR (101),	   \
   R_GR (102), R_GR (103), R_GR (104), R_GR (105), R_GR (106), R_GR (107),  \
   R_GR (108),								   \
   /* Input registers.  */						   \
@@ -779,12 +772,12 @@ while (0)
   /* Callee-saved general registers.  */				   \
   R_GR (4), R_GR (5), R_GR (6), R_GR (7),				   \
   /* Callee-saved FP registers.  */					   \
-  R_FR (2), R_FR (3), R_FR (4), R_FR (5), R_FR (16), R_FR (17), 	   \
-  R_FR (18), R_FR (19), R_FR (20), R_FR (21), R_FR (22), R_FR (23), 	   \
-  R_FR (24), R_FR (25), R_FR (26), R_FR (27), R_FR (28), R_FR (29), 	   \
+  R_FR (2), R_FR (3), R_FR (4), R_FR (5), R_FR (16), R_FR (17),		   \
+  R_FR (18), R_FR (19), R_FR (20), R_FR (21), R_FR (22), R_FR (23),	   \
+  R_FR (24), R_FR (25), R_FR (26), R_FR (27), R_FR (28), R_FR (29),	   \
   R_FR (30), R_FR (31),							   \
   /* Callee-saved predicate registers.  */				   \
-  R_PR (1), R_PR (2), R_PR (3), R_PR (4), R_PR (5), 			   \
+  R_PR (1), R_PR (2), R_PR (3), R_PR (4), R_PR (5),			   \
   /* Callee-saved branch registers.  */					   \
   R_BR (1), R_BR (2), R_BR (3), R_BR (4), R_BR (5),			   \
 									   \
@@ -792,7 +785,7 @@ while (0)
   R_GR (109), R_GR (110), R_GR (111),					   \
 									   \
   /* Special general registers.  */					   \
-  R_GR (0), R_GR (1), R_GR (12), R_GR (13), 				   \
+  R_GR (0), R_GR (1), R_GR (12), R_GR (13),				   \
   /* Special FP registers.  */						   \
   R_FR (0), R_FR (1),							   \
   /* Special predicate registers.  */					   \
@@ -801,7 +794,8 @@ while (0)
   R_BR (0),								   \
   /* Other fixed registers.  */						   \
   FRAME_POINTER_REGNUM, RETURN_ADDRESS_POINTER_REGNUM,			   \
-  AR_CCV_REGNUM, AR_LC_REGNUM, AR_EC_REGNUM, AR_PFS_REGNUM		   \
+  AR_CCV_REGNUM, AR_UNAT_REGNUM, AR_PFS_REGNUM, AR_LC_REGNUM,		   \
+  AR_EC_REGNUM		  						   \
 }
 
 /* How Values Fit in Registers */
@@ -809,26 +803,28 @@ while (0)
 /* A C expression for the number of consecutive hard registers, starting at
    register number REGNO, required to hold a value of mode MODE.  */
 
-/* ??? x86 80-bit FP values only require 1 register.  */
 /* ??? We say that CCmode values require two registers.  This allows us to
-   easily store the normal and inverted values.  If we want single register
-   predicates, we can use EXTRA_CC_MODES to give them a different mode.  */
+   easily store the normal and inverted values.  We use CCImode to indicate
+   a single predicate register.  */
 
-#define HARD_REGNO_NREGS(REGNO, MODE) \
-  ((MODE) == CCmode && PR_REGNO_P (REGNO) ? 2				\
-   : FR_REGNO_P (REGNO) && (MODE) == XFmode ? 1				\
+#define HARD_REGNO_NREGS(REGNO, MODE)					\
+  ((REGNO) == PR_REG (0) && (MODE) == DImode ? 64			\
+   : PR_REGNO_P (REGNO) && (MODE) == CCmode ? 2				\
+   : PR_REGNO_P (REGNO) && (MODE) == CCImode ? 1			\
+   : FR_REGNO_P (REGNO) && (MODE) == TFmode ? 1				\
    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
 
 /* A C expression that is nonzero if it is permissible to store a value of mode
    MODE in hard register number REGNO (or in several registers starting with
    that one).  */
 
-#define HARD_REGNO_MODE_OK(REGNO, MODE) \
-  (FR_REGNO_P (REGNO) ? (MODE) != CCmode				\
-   : PR_REGNO_P (REGNO) ? (MODE) == CCmode				\
-   : GR_REGNO_P (REGNO) ? (MODE) != XFmode				\
+#define HARD_REGNO_MODE_OK(REGNO, MODE)					\
+  (FR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) != MODE_CC && (MODE) != TImode \
+   : PR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC		\
+   : GR_REGNO_P (REGNO) ? (MODE) != CCImode && (MODE) != TFmode		\
    : AR_REGNO_P (REGNO) ? (MODE) == DImode				\
-   : 1)
+   : BR_REGNO_P (REGNO) ? (MODE) == DImode				\
+   : 0)
 
 /* A C expression that is nonzero if it is desirable to choose register
    allocation so as to avoid move instructions between a value of mode MODE1
@@ -841,11 +837,11 @@ while (0)
    INTEGRAL_MODE_P or FLOAT_MODE_P and the other is not.  Otherwise, it is
    true.  */
 /* Don't tie integer and FP modes, as that causes us to get integer registers
-   allocated for FP instructions.  XFmode only supported in FP registers at
-   the moment, so we can't tie it with any other modes.  */
+   allocated for FP instructions.  TFmode only supported in FP registers so
+   we can't tie it with any other modes.  */
 #define MODES_TIEABLE_P(MODE1, MODE2) \
   ((GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2)) \
-   && (((MODE1) == XFmode) == ((MODE2) == XFmode)))
+   && (((MODE1) == TFmode) == ((MODE2) == TFmode)))
 
 /* Define this macro if the compiler should avoid copies to/from CCmode
    registers.  You should only define this macro if support fo copying to/from
@@ -945,15 +941,15 @@ enum reg_class
   /* AR_M_REGS.  */					\
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,	\
     0x00000000, 0x00000000, 0x00000000, 0x00000000,	\
-    0x00000000, 0x00000000, 0x0400 },			\
+    0x00000000, 0x00000000, 0x0C00 },			\
   /* AR_I_REGS.  */					\
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,	\
     0x00000000, 0x00000000, 0x00000000, 0x00000000,	\
-    0x00000000, 0x00000000, 0x3800 },			\
+    0x00000000, 0x00000000, 0x7000 },			\
   /* ALL_REGS.  */					\
   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,	\
     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,	\
-    0xFFFFFFFF, 0xFFFFFFFF, 0x3FFF },			\
+    0xFFFFFFFF, 0xFFFFFFFF, 0x7FFF },			\
 }
 
 /* A C expression whose value is a register class containing hard register
@@ -968,8 +964,8 @@ enum reg_class
  : FR_REGNO_P (REGNO) ? FR_REGS		\
  : PR_REGNO_P (REGNO) ? PR_REGS		\
  : BR_REGNO_P (REGNO) ? BR_REGS		\
- : AR_M_REGNO_P (REGNO) ? AR_I_REGS	\
- : AR_I_REGNO_P (REGNO) ? AR_M_REGS	\
+ : AR_M_REGNO_P (REGNO) ? AR_M_REGS	\
+ : AR_I_REGNO_P (REGNO) ? AR_I_REGS	\
  : NO_REGS)
 
 /* A macro whose definition is the name of the class to which a valid base
@@ -980,8 +976,8 @@ enum reg_class
 /* A macro whose definition is the name of the class to which a valid index
    register must belong.  An index register is one used in an address where its
    value is either multiplied by a scale factor or added to another register
-   (as well as added to a displacement).  */
-#define INDEX_REG_CLASS NO_REGS
+   (as well as added to a displacement).  This is needed for POST_MODIFY.  */
+#define INDEX_REG_CLASS GENERAL_REGS
 
 /* A C expression which defines the machine-dependent operand constraint
    letters for register classes.  If CHAR is such a letter, the value should be
@@ -1006,8 +1002,9 @@ enum reg_class
 
 /* A C expression which is nonzero if register number NUM is suitable for use
    as an index register in operand addresses.  It may be either a suitable hard
-   register or a pseudo register that has been allocated such a hard reg.  */
-#define REGNO_OK_FOR_INDEX_P(NUM) 0
+   register or a pseudo register that has been allocated such a hard reg.
+   This is needed for POST_MODIFY.  */
+#define REGNO_OK_FOR_INDEX_P(NUM) REGNO_OK_FOR_BASE_P (NUM)
 
 /* A C expression that places additional restrictions on the register class to
    use when it is necessary to copy value X into a register in class CLASS.
@@ -1039,10 +1036,16 @@ enum reg_class
    registers of CLASS1 can only be copied to registers of class CLASS2 by
    storing a register of CLASS1 into memory and loading that memory location
    into a register of CLASS2.  */
-/* ??? We may need this for XFmode moves between FR and GR regs.  Using
-   getf.sig/getf.exp almost works, but the result in the GR regs is not
-   properly formatted and has two extra bits.  */
-/* #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, M) */
+
+#if 0
+/* ??? May need this, but since we've disallowed TFmode in GR_REGS,
+   I'm not quite sure how it could be invoked.  The normal problems
+   with unions should be solved with the addressof fiddling done by
+   movtf and friends.  */
+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)			\
+  ((MODE) == TFmode && (((CLASS1) == GR_REGS && (CLASS2) == FR_REGS)	\
+			|| ((CLASS1) == FR_REGS && (CLASS2) == GR_REGS)))
+#endif
 
 /* A C expression for the maximum number of consecutive registers of
    class CLASS needed to hold a value of mode MODE.
@@ -1050,7 +1053,7 @@ enum reg_class
 
 #define CLASS_MAX_NREGS(CLASS, MODE) \
   ((MODE) == CCmode && (CLASS) == PR_REGS ? 2			\
-   : ((CLASS) == FR_REGS && (MODE) == XFmode) ? 1		\
+   : ((CLASS) == FR_REGS && (MODE) == TFmode) ? 1		\
    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
 
 /* If defined, gives a class of registers that cannot be used as the
@@ -1058,12 +1061,16 @@ enum reg_class
 
 #define CLASS_CANNOT_CHANGE_MODE        FR_REGS
 
-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */
-
-#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) 1
-
-/* A C expression that defines the machine-dependent operand constraint letters
-   (`I', `J', `K', .. 'P') that specify particular ranges of integer values.  */
+/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.
+   In FP regs, we can't change FP values to integer values and vice
+   versa, but we can change e.g. DImode to SImode.  */
+
+#define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \
+  (GET_MODE_CLASS (FROM) != GET_MODE_CLASS (TO))
+
+/* A C expression that defines the machine-dependent operand constraint
+   letters (`I', `J', `K', .. 'P') that specify particular ranges of
+   integer values.  */
 
 /* 14 bit signed immediate for arithmetic instructions.  */
 #define CONST_OK_FOR_I(VALUE) \
@@ -1078,7 +1085,6 @@ enum reg_class
 /* 6 bit unsigned immediate for shift counts.  */
 #define CONST_OK_FOR_M(VALUE) ((unsigned HOST_WIDE_INT)(VALUE) < 0x40)
 /* 9 bit signed immediate for load/store post-increments.  */
-/* ??? N is currently not used.  */
 #define CONST_OK_FOR_N(VALUE) ((unsigned HOST_WIDE_INT)(VALUE) + 0x100 < 0x200)
 /* 0 for r0.  Used by Linux kernel, do not change.  */
 #define CONST_OK_FOR_O(VALUE) ((VALUE) == 0)
@@ -1111,11 +1117,23 @@ enum reg_class
    letters (`Q', `R', `S', `T', `U') that can be used to segregate specific
    types of operands, usually memory references, for the target machine.  */
 
+/* Non-volatile memory for FP_REG loads/stores.  */
 #define CONSTRAINT_OK_FOR_Q(VALUE) \
   (memory_operand((VALUE), VOIDmode) && ! MEM_VOLATILE_P (VALUE))
+/* 1..4 for shladd arguments.  */
+#define CONSTRAINT_OK_FOR_R(VALUE) \
+  (GET_CODE (VALUE) == CONST_INT && INTVAL (VALUE) >= 1 && INTVAL (VALUE) <= 4)
+/* Non-post-inc memory for asms and other unsavory creatures.  */
+#define CONSTRAINT_OK_FOR_S(VALUE)				\
+  (GET_CODE (VALUE) == MEM					\
+   && GET_RTX_CLASS (GET_CODE (XEXP ((VALUE), 0))) != 'a'	\
+   && (reload_in_progress || memory_operand ((VALUE), VOIDmode)))
 
 #define EXTRA_CONSTRAINT(VALUE, C) \
-  ((C) == 'Q' ? CONSTRAINT_OK_FOR_Q (VALUE) : 0)
+  ((C) == 'Q' ? CONSTRAINT_OK_FOR_Q (VALUE)	\
+   : (C) == 'R' ? CONSTRAINT_OK_FOR_R (VALUE)	\
+   : (C) == 'S' ? CONSTRAINT_OK_FOR_S (VALUE)	\
+   : 0)
 
 /* Basic Stack Layout */
 
@@ -1125,18 +1143,11 @@ enum reg_class
 
 /* Define this macro if the addresses of local variable slots are at negative
    offsets from the frame pointer.  */
-#define FRAME_GROWS_DOWNWARD
+/* #define FRAME_GROWS_DOWNWARD */
 
-/* Offset from the frame pointer to the first local variable slot to be
-   allocated.  */
-/* ??? This leaves 16 bytes unused normally, but it looks funny to store locals
-   into the 16-byte reserved area.  */
-/* ??? This isn't very efficient use of the frame pointer.  Better would be
-   to move it down a ways, so that we have positive and negative offsets.  */
-#define STARTING_FRAME_OFFSET \
-  (current_function_pretend_args_size					\
-   ? 16 - current_function_pretend_args_size				\
-   : 0)
+/* Offset from the frame pointer to the first local variable slot to
+   be allocated.  */
+#define STARTING_FRAME_OFFSET 0
 
 /* Offset from the stack pointer register to the first location at which
    outgoing arguments are placed.  If not specified, the default value of zero
@@ -1201,16 +1212,8 @@ enum reg_class
 
 #define FRAME_POINTER_REGNUM 328
 
-/* Register number where frame pointer was saved in the prologue, or zero
-   if it was not saved.  */
-
-extern int ia64_fp_regno;
-
-/* Number of input and local registers used.  This is needed for the .regstk
-   directive, and also for debugging info.  */
-
-extern int ia64_input_regs;
-extern int ia64_local_regs;
+/* Base register for access to local variables of the function.  */
+#define HARD_FRAME_POINTER_REGNUM  LOC_REG (79)
 
 /* The register number of the arg pointer register, which is used to access the
    function's argument list.  */
@@ -1218,76 +1221,52 @@ extern int ia64_local_regs;
    in it.  */
 #define ARG_POINTER_REGNUM R_GR(0)
 
-/* The register number for the return address register.  This is not actually
-   a pointer as the name suggests, but that's a name that gen_rtx_REG 
-   already takes care to keep unique.  We modify return_address_pointer_rtx
-   in ia64_expand_prologue to reference the final output regnum.  */
-
+/* The register number for the return address register.  For IA-64, this
+   is not actually a pointer as the name suggests, but that's a name that
+   gen_rtx_REG already takes care to keep unique.  We modify
+   return_address_pointer_rtx in ia64_expand_prologue to reference the
+   final output regnum.  */
 #define RETURN_ADDRESS_POINTER_REGNUM 329
 
 /* Register numbers used for passing a function's static chain pointer.  */
-
+/* ??? The ABI sez the static chain should be passed as a normal parameter.  */
 #define STATIC_CHAIN_REGNUM 15
-
 
 /* Eliminating the Frame Pointer and the Arg Pointer */
 
 /* A C expression which is nonzero if a function must have and use a frame
    pointer.  This expression is evaluated in the reload pass.  If its value is
    nonzero the function will have a frame pointer.  */
-
 #define FRAME_POINTER_REQUIRED 0
 
+/* Show we can debug even without a frame pointer.  */
+#define CAN_DEBUG_WITHOUT_FP
+
 /* If defined, this macro specifies a table of register pairs used to eliminate
    unneeded registers that point into the stack frame.  */
 
 #define ELIMINABLE_REGS							\
 {									\
   {ARG_POINTER_REGNUM,	 STACK_POINTER_REGNUM},				\
-  {ARG_POINTER_REGNUM,	 FRAME_POINTER_REGNUM},				\
+  {ARG_POINTER_REGNUM,	 HARD_FRAME_POINTER_REGNUM},			\
   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},				\
-  {RETURN_ADDRESS_POINTER_REGNUM, BR_REG (0)}				\
+  {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},			\
+  {RETURN_ADDRESS_POINTER_REGNUM, BR_REG (0)},				\
 }
 
 /* A C expression that returns non-zero if the compiler is allowed to try to
-   replace register number FROM with register number TO.  */
+   replace register number FROM with register number TO.  The frame pointer
+   is automatically handled.  */
 
 #define CAN_ELIMINATE(FROM, TO) \
   (TO == BR_REG (0) ? current_function_is_leaf : 1)
 
-/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It specifies the
-   initial difference between the specified pair of registers.  This macro must
-   be defined if `ELIMINABLE_REGS' is defined.  */
-/* ??? I need to decide whether the frame pointer is the old frame SP
-   or the new frame SP before dynamic allocs.  */
-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
-{									\
-  unsigned int size = ia64_compute_frame_size (get_frame_size ());	\
-									\
-  if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)	\
-    (OFFSET) = size;							\
-  else if ((FROM) == ARG_POINTER_REGNUM)				\
-    {									\
-      switch (TO)							\
-	{								\
-	case FRAME_POINTER_REGNUM:					\
-	  /* Arguments start above the 16 byte save area, unless stdarg	\
-	     in which case we store through the 16 byte save area.  */	\
-	  (OFFSET) = 16 - current_function_pretend_args_size;		\
-	  break;							\
-	case STACK_POINTER_REGNUM:					\
-	  (OFFSET) = size + 16 - current_function_pretend_args_size;	\
-	  break;							\
-	default:							\
-	  abort ();							\
-	}								\
-    }									\
-  else if ((TO) == BR_REG (0))						\
-    (OFFSET) = 0;							\
-  else									\
-    abort ();								\
-}
-
+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It
+   specifies the initial difference between the specified pair of
+   registers.  This macro must be defined if `ELIMINABLE_REGS' is
+   defined.  */
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  ((OFFSET) = ia64_initial_elimination_offset ((FROM), (TO)))
 
 /* Passing Function Arguments on the Stack */
 
@@ -1509,7 +1488,7 @@ do {									\
 /* Output at beginning of assembler file.  */
 
 #define ASM_FILE_START(FILE) \
-  ia64_file_start (FILE)
+  emit_safe_across_calls (FILE)
 
 /* A C compound statement that outputs the assembler code for a thunk function,
    used to implement C++ virtual function calls with multiple inheritance.  */
@@ -1682,108 +1661,39 @@ do {									\
    a trampoline, leaving space for the variable parts.
 
    The trampoline should set the static chain pointer to value placed
-   into the trampoline and should branch to the specified routine.  The
-   gp doesn't have to be set since that is already done by the caller
-   of the trampoline.  To make the normal indirect-subroutine calling
-   convention work, the trampoline must look like a function descriptor.
-   That is, the first word must be the target address, the second
-   word must be the target's global pointer.  The complete trampoline
+   into the trampoline and should branch to the specified routine.
+   To make the normal indirect-subroutine calling convention work,
+   the trampoline must look like a function descriptor; the first
+   word being the target address and the second being the target's
+   global pointer.
+
+   We abuse the concept of a global pointer by arranging for it
+   to point to the data we need to load.  The complete trampoline
    has the following form:
 
-		+----------------+ \
-	TRAMP:	| TRAMP+32     	 | |
-		+----------------+  > fake function descriptor
-		|    gp		 | |
-		+----------------+ /
-		| target addr	 |
-		+----------------+
-		| static link	 |
-		+----------------+
-		| mov r2=ip	 |
-		+		 +
-		| ;;		 |
-		+----------------+
-		| adds r4=-16,r2 |
-		+ adds r15=-8,r2 +
-		| ;;		 |
-		+----------------+
-		| ld8 r4=[r4];;	 |
-		+ ld8 r15=[r15]	 +
-		| mov b6=r4;;	 |
-		+----------------+
-		| br b6		 |
-		+----------------+
+		+-------------------+ \
+	TRAMP:	| __ia64_trampoline | |
+		+-------------------+  > fake function descriptor
+		| TRAMP+16          | |
+		+-------------------+ /
+		| target descriptor |
+		+-------------------+
+		| static link	    |
+		+-------------------+
 */
 
-/* ??? Need a version of this and INITIALIZE_TRAMPOLINE for -mno-pic.  */
-
-#define TRAMPOLINE_TEMPLATE(FILE)					\
-{									\
-  fprintf (FILE,							\
-	   "\tdata8 0,0,0,0\n"						\
-	   "\t{ mov r2=ip }\n"						\
-	   "\t;;\n"							\
-	   "\t{ adds r4=-16,r2; adds r%d=-8,r2 }\n"			\
-	   "\t;;\n"							\
-	   "\t{ ld8 r4=[r4];; ld8 r%d=[r%d]; mov b6=r4 }\n"		\
-	   "\t;;\n"							\
-	   "\t{ br b6 }\n"						\
-	   "\t;;\n",							\
-	   STATIC_CHAIN_REGNUM, STATIC_CHAIN_REGNUM,			\
-	   STATIC_CHAIN_REGNUM);					\
-}
-
-/* The name of a subroutine to switch to the section in which the trampoline
-   template is to be placed.
-
-   On ia64, instructions may only be placed in a text segment.  */
-
-#define TRAMPOLINE_SECTION	text_section
-
 /* A C expression for the size in bytes of the trampoline, as an integer.  */
 
-#define TRAMPOLINE_SIZE		96
+#define TRAMPOLINE_SIZE		32
 
 /* Alignment required for trampolines, in bits.  */
 
-#define TRAMPOLINE_ALIGNMENT	256
+#define TRAMPOLINE_ALIGNMENT	64
 
 /* A C statement to initialize the variable parts of a trampoline.  */
 
 #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \
-{									\
-  rtx addr, addr2, addr_reg, fdesc_addr;				\
-									\
-  /* Load function descriptor address into a pseudo.  */		\
-  fdesc_addr = gen_reg_rtx (DImode);					\
-  emit_move_insn (fdesc_addr, FNADDR);				     	\
-									\
-  /* Read target address from function descriptor and store in		\
-     trampoline.  */							\
-  addr = memory_address (Pmode, plus_constant (ADDR, 16));		\
-  emit_move_insn (gen_rtx_MEM (Pmode, addr),				\
-		  gen_rtx_MEM (Pmode, fdesc_addr));			\
-  /* Store static chain in trampoline.  */				\
-  addr = memory_address (Pmode, plus_constant (ADDR, 24));		\
-  emit_move_insn (gen_rtx_MEM (Pmode, addr), STATIC_CHAIN);		\
-									\
-  /* Load GP value from function descriptor and store in trampoline.  */\
-  addr = memory_address (Pmode, plus_constant (ADDR, 8));		\
-  addr2 = memory_address (Pmode, plus_constant (fdesc_addr, 8));	\
-  emit_move_insn (gen_rtx_MEM (Pmode, addr),				\
-		  gen_rtx_MEM (Pmode, addr2));				\
-									\
-  /* Store trampoline entry address in trampoline.  */			\
-  addr = memory_address (Pmode, ADDR);					\
-  addr2 = memory_address (Pmode, plus_constant (ADDR, 32));		\
-  emit_move_insn (gen_rtx_MEM (Pmode, addr), addr2);			\
-									\
-  /* Flush the relevant 64 bytes from the i-cache.  */			\
-  addr_reg = force_reg (DImode, plus_constant (ADDR, 0));		\
-  emit_insn (gen_rtx_UNSPEC_VOLATILE (VOIDmode,				\
-				      gen_rtvec (1, addr_reg), 3));	\
-}
-
+  ia64_initialize_trampoline((ADDR), (FNADDR), (STATIC_CHAIN))
 
 /* Implicit Calls to Library Routines */
 
@@ -1842,7 +1752,7 @@ do {									\
 #define LEGITIMATE_ADDRESS_DISP(R, X)					\
   (GET_CODE (X) == PLUS							\
    && rtx_equal_p (R, XEXP (X, 0))					\
-   && (GET_CODE (XEXP (X, 1)) == REG					\
+   && (LEGITIMATE_ADDRESS_REG (XEXP (X, 1))				\
        || (GET_CODE (XEXP (X, 1)) == CONST_INT				\
 	   && INTVAL (XEXP (X, 1)) >= -256				\
 	   && INTVAL (XEXP (X, 1)) < 256)))
@@ -1873,9 +1783,9 @@ do {									\
 #endif
 
 /* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for
-   use as an index register.  */
+   use as an index register.  This is needed for POST_MODIFY.  */
 
-#define REG_OK_FOR_INDEX_P(X) 0
+#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)
 
 /* A C compound statement that attempts to replace X with a valid memory
    address for an operand of mode MODE.
@@ -1889,11 +1799,7 @@ do {									\
    on the machine mode of the memory reference it is used for or if the address
    is valid for some modes but not others.  */
 
-/* ??? Strictly speaking this isn't true, because we can use any increment with
-   any mode.  Unfortunately, the RTL implies that the increment depends on the
-   mode, so we need this for now.  */
-
-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)			\
   if (GET_CODE (ADDR) == POST_DEC || GET_CODE (ADDR) == POST_INC)	\
     goto LABEL;
 
@@ -2099,20 +2005,17 @@ do {									\
 /* Output of Data.  */
 
 /* A C statement to output to the stdio stream STREAM an assembler instruction
-   to assemble a floating-point constant of `XFmode', `DFmode', `SFmode',
+   to assemble a floating-point constant of `TFmode', `DFmode', `SFmode',
    respectively, whose value is VALUE.  */
 
-/* ??? This has not been tested.  Long doubles are really 10 bytes not 12
-   bytes on ia64.  */
-
 /* ??? Must reverse the word order for big-endian code?  */
 
 #define ASM_OUTPUT_LONG_DOUBLE(FILE, VALUE) \
 do {									\
   long t[3];								\
   REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, t);				\
-  fprintf (FILE, "\tdata8 0x%08lx, 0x%08lx, 0x%08lx\n",			\
-	   t[0] & 0xffffffff, t[1] & 0xffffffff, t[2] & 0xffffffff);	\
+  fprintf (FILE, "\tdata4 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx\n",	\
+	   t[0] & 0xffffffff, t[1] & 0xffffffff, t[2] & 0xffffffff, 0);	\
 } while (0)
 
 /* ??? Must reverse the word order for big-endian code?  */
@@ -2388,7 +2291,7 @@ do {									\
   /* Branch registers.  */						\
   "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7",			\
   /* Frame pointer.  Return address.  */				\
-  "sfp", "retaddr", "ar.ccv", "ar.lc", "ar.ec", "ar.pfs"		\
+  "sfp", "retaddr", "ar.ccv", "ar.unat", "ar.pfs", "ar.lc", "ar.ec",	\
 }
 
 /* If defined, a C initializer for an array of structures containing a name and
@@ -2714,6 +2617,18 @@ do {									\
 
 #define DWARF2_ASM_LINE_DEBUG_INFO (TARGET_DWARF2_ASM)
 
+/* Use tags for debug info labels, so that they don't break instruction
+   bundles.  This also avoids getting spurious DV warnings from the
+   assembler.  This is similar to ASM_OUTPUT_INTERNAL_LABEL, except that we
+   add brackets around the label.  */
+
+#define ASM_OUTPUT_DEBUG_LABEL(FILE, PREFIX, NUM) \
+  do							\
+    {							\
+      fprintf (FILE, "[.%s%d:]\n", PREFIX, NUM);	\
+    }							\
+  while (0)
+
 
 /* Cross Compilation and Floating Point.  */
 
@@ -2754,28 +2669,40 @@ do {									\
 { "function_operand", {SYMBOL_REF}},					\
 { "setjmp_operand", {SYMBOL_REF}},					\
 { "destination_operand", {SUBREG, REG, MEM}},				\
+{ "not_postinc_memory_operand", {MEM}},					\
 { "move_operand", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,		\
 		     CONSTANT_P_RTX, SYMBOL_REF, CONST, LABEL_REF}},	\
-{ "reg_or_0_operand", {SUBREG, REG, CONST_INT}},			\
-{ "reg_or_6bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
-{ "reg_or_8bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
-{ "reg_or_8bit_adjusted_operand", {SUBREG, REG, CONST_INT,		\
+{ "gr_register_operand", {SUBREG, REG}},				\
+{ "fr_register_operand", {SUBREG, REG}},				\
+{ "grfr_register_operand", {SUBREG, REG}},				\
+{ "gr_nonimmediate_operand", {SUBREG, REG, MEM}},			\
+{ "grfr_nonimmediate_operand", {SUBREG, REG, MEM}},			\
+{ "gr_reg_or_0_operand", {SUBREG, REG, CONST_INT}},			\
+{ "gr_reg_or_5bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
+{ "gr_reg_or_6bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
+{ "gr_reg_or_8bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
+{ "grfr_reg_or_8bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \
+{ "gr_reg_or_8bit_adjusted_operand", {SUBREG, REG, CONST_INT,		\
 				     CONSTANT_P_RTX}},			\
-{ "reg_or_8bit_and_adjusted_operand", {SUBREG, REG, CONST_INT,		\
+{ "gr_reg_or_8bit_and_adjusted_operand", {SUBREG, REG, CONST_INT,	\
 					 CONSTANT_P_RTX}},		\
-{ "reg_or_14bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
-{ "reg_or_22bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
+{ "gr_reg_or_14bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \
+{ "gr_reg_or_22bit_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \
 { "shift_count_operand", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},	\
 { "shift_32bit_count_operand", {SUBREG, REG, CONST_INT,			\
 				  CONSTANT_P_RTX}},			\
 { "shladd_operand", {CONST_INT}},					\
 { "fetchadd_operand", {CONST_INT}},					\
-{ "reg_or_fp01_operand", {SUBREG, REG, CONST_DOUBLE, CONSTANT_P_RTX}},	\
+{ "fr_reg_or_fp01_operand", {SUBREG, REG, CONST_DOUBLE}},		\
 { "normal_comparison_operator", {EQ, NE, GT, LE, GTU, LEU}},		\
 { "adjusted_comparison_operator", {LT, GE, LTU, GEU}},			\
 { "call_multiple_values_operation", {PARALLEL}},			\
 { "predicate_operator", {NE, EQ}},					\
-{ "ar_lc_reg_operand", {REG}},
+{ "ar_lc_reg_operand", {REG}},						\
+{ "ar_ccv_reg_operand", {REG}},						\
+{ "general_tfmode_operand", {SUBREG, REG, CONST_DOUBLE, MEM}},		\
+{ "destination_tfmode_operand", {SUBREG, REG, MEM}},			\
+{ "tfreg_or_fp01_operand", {REG, CONST_DOUBLE}},
 
 /* An alias for a machine mode name.  This is the machine mode that elements of
    a jump-table should have.  */
@@ -2886,6 +2813,12 @@ struct machine_function
 
   /* The new bsp value when unwinding from EH. */
   struct rtx_def* ia64_eh_epilogue_bsp;
+
+  /* The GP value save register.  */
+  struct rtx_def* ia64_gp_save;
+
+  /* The number of varargs registers to save.  */
+  int n_varargs;
 };
 
 
--- gcc/config/ia64/ia64.md.jj	Mon Jul 31 20:02:16 2000
+++ gcc/config/ia64/ia64.md	Fri Oct 20 04:14:58 2000
@@ -22,8 +22,6 @@
 
 ;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
 
-;; ??? Add support for long double XFmode patterns.
-
 ;; ??? register_operand accepts (subreg:DI (mem:SI X)) which forces later
 ;; reload.  This will be fixed once scheduling support is turned on.
 
@@ -59,15 +57,9 @@
 ;;	2	gr_restore
 ;;	3	fr_spill
 ;;	4	fr_restore
-;;	5	pr_spill
 ;;	8	popcnt
-;;	9	unat_spill
-;;	10	unat_restore
+;;	12	mf
 ;;	13	cmpxchg_acq
-;;	14	val_compare_and_swap
-;;	16	lock_test_and_set
-;;	17	op_and_fetch
-;;	18	fetch_and_op
 ;;	19	fetchadd_acq
 ;;	20	bsp_value
 ;;	21	flushrs
@@ -76,11 +68,10 @@
 ;;	0	alloc
 ;;	1	blockage
 ;;	2	insn_group_barrier
-;;	3	flush_cache
-;;	4	pfs_restore
 ;;	5	set_bsp
-;;	6	pr_restore
 ;;	7	pred.rel.mutex
+;;	8	pred.safe_across_calls all
+;;	9	pred.safe_across_calls normal
 
 ;; ::::::::::::::::::::
 ;; ::
@@ -302,10 +293,10 @@
 (define_insn "*movsicc_astep"
   [(cond_exec
      (match_operator 2 "predicate_operator"
-       [(match_operand:CC 3 "register_operand" "c,c,c,c,c,c")
+       [(match_operand:CC 3 "register_operand" "c,c,c,c,c,c,c,c")
         (const_int 0)])
-     (set (match_operand:SI 0 "register_operand"  "=r,r,r, r,*f,*f")
-	  (match_operand:SI 1 "nonmemory_operand" "rO,J,i,*f,rO,*f")))]
+     (set (match_operand:SI 0 "register_operand"  "=r,r,r, r,*f,*f, r,*d")
+	  (match_operand:SI 1 "nonmemory_operand" "rO,J,i,*f,rO,*f,*d,rO")))]
   "TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "@
    (%J2) mov %0 = %r1
@@ -313,13 +304,15 @@
    (%J2) movl %0 = %1
    (%J2) getf.sig %0 = %1
    (%J2) setf.sig %0 = %r1
-   (%J2) mov %0 = %1"
-  [(set_attr "type" "A,A,L,M,M,F")
+   (%J2) mov %0 = %1
+   (%J2) mov %0 = %1
+   (%J2) mov %0 = %r1"
+  [(set_attr "type" "A,A,L,M,M,F,M,M")
    (set_attr "predicable" "no")])
 
 (define_insn "*movsi_internal_astep"
-  [(set (match_operand:SI 0 "destination_operand" "=r,r,r,r, m, r,*f,*f")
-	(match_operand:SI 1 "move_operand"        "rO,J,i,m,rO,*f,rO,*f"))]
+  [(set (match_operand:SI 0 "destination_operand" "=r,r,r,r, m, r,*f,*f, r,*d")
+	(match_operand:SI 1 "move_operand"        "rO,J,i,m,rO,*f,rO,*f,*d,rO"))]
   "TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "@
   mov %0 = %r1
@@ -329,13 +322,15 @@
   st4%Q0 %0 = %r1%P0
   getf.sig %0 = %1
   setf.sig %0 = %r1
-  mov %0 = %1"
-  [(set_attr "type" "A,A,L,M,M,M,M,F")
+  mov %0 = %1
+  mov %0 = %1
+  mov %0 = %r1"
+  [(set_attr "type" "A,A,L,M,M,M,M,F,M,M")
    (set_attr "predicable" "no")])
 
 (define_insn "*movsi_internal"
-  [(set (match_operand:SI 0 "destination_operand" "=r,r,r,r, m, r,*f,*f")
-	(match_operand:SI 1 "move_operand"        "rO,J,i,m,rO,*f,rO,*f"))]
+  [(set (match_operand:SI 0 "destination_operand" "=r,r,r,r, m, r,*f,*f, r,*d")
+	(match_operand:SI 1 "move_operand"        "rO,J,i,m,rO,*f,rO,*f,*d,rO"))]
   "! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "@
   mov %0 = %r1
@@ -345,8 +340,10 @@
   st4%Q0 %0 = %r1%P0
   getf.sig %0 = %1
   setf.sig %0 = %r1
-  mov %0 = %1"
-  [(set_attr "type" "A,A,L,M,M,M,M,F")])
+  mov %0 = %1
+  mov %0 = %1
+  mov %0 = %r1"
+  [(set_attr "type" "A,A,L,M,M,M,M,F,M,M")])
 
 (define_expand "movdi"
   [(set (match_operand:DI 0 "general_operand" "")
@@ -354,14 +351,29 @@
   ""
   "
 {
+  if (! reload_in_progress && ! reload_completed
+      && ! ia64_move_ok (operands[0], operands[1]))
+    operands[1] = force_reg (DImode, operands[1]);
   if (! TARGET_NO_PIC && symbolic_operand (operands[1], DImode))
     {
-      ia64_expand_load_address (operands[0], operands[1]);
+      /* Before optimization starts, delay committing to any particular
+	 type of PIC address load.  If this function gets deferred, we
+	 may acquire information that changes the value of the
+	 sdata_symbolic_operand predicate.  */
+      /* But don't delay for function pointers.  Loading a function address
+	 actually loads the address of the descriptor not the function.
+	 If we represent these as SYMBOL_REFs, then they get cse'd with
+	 calls, and we end up with calls to the descriptor address instead of
+	 calls to the function address.  Functions are not candidates for
+	 sdata anyways.  */
+      if (rtx_equal_function_value_matters
+	  && ! (GET_CODE (operands[1]) == SYMBOL_REF
+		&& SYMBOL_REF_FLAG (operands[1])))
+	emit_insn (gen_movdi_symbolic (operands[0], operands[1]));
+      else
+        ia64_expand_load_address (operands[0], operands[1]);
       DONE;
     }
-  if (! reload_in_progress && ! reload_completed
-      && ! ia64_move_ok (operands[0], operands[1]))
-    operands[1] = force_reg (DImode, operands[1]);
 }")
 
 ;; Errata 72 workaround.
@@ -410,11 +422,30 @@
   [(set_attr "type" "A,A,L,M,M,F,I,I,M,M")
    (set_attr "predicable" "no")])
 
+;; This is used during early compilation to delay the decision on
+;; how to refer to a variable as long as possible.  This is especially
+;; important between initial rtl generation and optimization for
+;; deferred functions, since we may acquire additional information
+;; on the variables used in the meantime.
+
+;; ??? This causes us to lose REG_LABEL notes, because the insn splitter
+;; does not attempt to preserve any REG_NOTES on the input instruction.
+
+(define_insn_and_split "movdi_symbolic"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(match_operand:DI 1 "symbolic_operand" "s"))
+   (use (reg:DI 1))]
+  ""
+  "* abort ();"
+  ""
+  [(const_int 0)]
+  "ia64_expand_load_address (operands[0], operands[1]); DONE;")
+
 (define_insn "*movdi_internal_astep"
   [(set (match_operand:DI 0 "destination_operand"
-			    "=r,r,r,r, m, r,*f,*f,*f, Q,   r,*b*e, r,*d")
+		    "=r,r,r,r, m, r,*f,*f,*f, Q,   r,*b*e, r,*d, r,*c")
 	(match_operand:DI 1 "move_operand"
-			    "rO,J,i,m,rO,*f,rO,*f, Q,*f,*b*e,  rO,*d,rO"))]
+		    "rO,J,i,m,rO,*f,rO,*f, Q,*f,*b*e,  rO,*d,rO,*c,rO"))]
   "TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "*
 {
@@ -432,7 +463,9 @@
     \"mov %0 = %1\",
     \"mov %0 = %r1\",
     \"mov %0 = %1\",
-    \"mov %0 = %r1\"
+    \"mov %0 = %r1\",
+    \"mov %0 = pr\",
+    \"mov pr = %1, -1\"
   };
 
   if (which_alternative == 2 && ! TARGET_NO_PIC
@@ -441,14 +474,14 @@
 
   return alt[which_alternative];
 }"
-  [(set_attr "type" "A,A,L,M,M,M,M,F,M,M,I,I,M,M")
+  [(set_attr "type" "A,A,L,M,M,M,M,F,M,M,I,I,M,M,I,I")
    (set_attr "predicable" "no")])
 
 (define_insn "*movdi_internal"
   [(set (match_operand:DI 0 "destination_operand"
-			    "=r,r,r,r, m, r,*f,*f,*f, Q,   r,*b*e, r,*d")
+		    "=r,r,r,r, m, r,*f,*f,*f, Q,   r,*b*e, r,*d, r,*c")
 	(match_operand:DI 1 "move_operand"
-			    "rO,J,i,m,rO,*f,rO,*f, Q,*f,*b*e,  rO,*d,rO"))]
+		    "rO,J,i,m,rO,*f,rO,*f, Q,*f,*b*e,  rO,*d,rO,*c,rO"))]
   "! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "*
 {
@@ -466,7 +499,9 @@
     \"%,mov %0 = %1\",
     \"%,mov %0 = %r1\",
     \"%,mov %0 = %1\",
-    \"%,mov %0 = %r1\"
+    \"%,mov %0 = %r1\",
+    \"mov %0 = pr\",
+    \"mov pr = %1, -1\"
   };
 
   if (which_alternative == 2 && ! TARGET_NO_PIC
@@ -475,7 +510,7 @@
 
   return alt[which_alternative];
 }"
-  [(set_attr "type" "A,A,L,M,M,M,M,F,M,M,I,I,M,M")])
+  [(set_attr "type" "A,A,L,M,M,M,M,F,M,M,I,I,M,M,I,I")])
 
 (define_split
   [(set (match_operand:DI 0 "register_operand" "")
@@ -551,6 +586,116 @@
   "addl %0 = @ltoff(%1), gp"
   [(set_attr "type" "A")])
 
+;; With no offsettable memory references, we've got to have a scratch
+;; around to play with the second word.
+(define_expand "movti"
+  [(parallel [(set (match_operand:TI 0 "general_operand" "")
+		   (match_operand:TI 1 "general_operand" ""))
+	      (clobber (match_scratch:DI 2 ""))])]
+  ""
+  "
+{
+  if (! reload_in_progress && ! reload_completed
+      && ! ia64_move_ok (operands[0], operands[1]))
+    operands[1] = force_reg (TImode, operands[1]);
+}")
+
+(define_insn_and_split "*movti_internal"
+  [(set (match_operand:TI 0 "nonimmediate_operand" "=r,r,m")
+	(match_operand:TI 1 "general_operand"      "ri,m,r"))
+   (clobber (match_scratch:DI 2 "=X,&r,&r"))]
+  "ia64_move_ok (operands[0], operands[1])"
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "
+{
+  rtx adj1, adj2, in[2], out[2];
+  int first;
+
+  adj1 = ia64_split_timode (in, operands[1], operands[2]);
+  adj2 = ia64_split_timode (out, operands[0], operands[2]);
+
+  first = 0;
+  if (reg_overlap_mentioned_p (out[0], in[1]))
+    {
+      if (reg_overlap_mentioned_p (out[1], in[0]))
+	abort ();
+      first = 1;
+    }
+
+  if (adj1 && adj2)
+    abort ();
+  if (adj1)
+    emit_insn (adj1);
+  if (adj2)
+    emit_insn (adj2);
+  emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));
+  emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));
+  DONE;
+}"
+  [(set_attr "type" "unknown")
+   (set_attr "predicable" "no")])
+
+;; ??? SSA creates these.  Can't allow memories since we don't have
+;; the scratch register.  Fortunately combine will know how to add
+;; the clobber and scratch.
+(define_insn_and_split "*movti_internal_reg"
+  [(set (match_operand:TI 0 "register_operand"  "=r")
+	(match_operand:TI 1 "nonmemory_operand" "ri"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "
+{
+  rtx in[2], out[2];
+  int first;
+
+  ia64_split_timode (in, operands[1], NULL_RTX);
+  ia64_split_timode (out, operands[0], NULL_RTX);
+
+  first = 0;
+  if (reg_overlap_mentioned_p (out[0], in[1]))
+    {
+      if (reg_overlap_mentioned_p (out[1], in[0]))
+	abort ();
+      first = 1;
+    }
+
+  emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));
+  emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));
+  DONE;
+}"
+  [(set_attr "type" "unknown")
+   (set_attr "predicable" "no")])
+
+(define_expand "reload_inti"
+  [(parallel [(set (match_operand:TI 0 "register_operand" "=r")
+		   (match_operand:TI 1 "" "m"))
+	      (clobber (match_operand:DI 2 "register_operand" "=&r"))])]
+  ""
+  "
+{
+  /* ??? Should now be enforced by tweeks to push_secondary_reload.  */
+  if (reg_overlap_mentioned_p (operands[2], operands[0])
+      || reg_overlap_mentioned_p (operands[2], operands[1]))
+    abort ();
+}")
+
+(define_expand "reload_outti"
+  [(parallel [(set (match_operand:TI 0 "" "=m")
+		   (match_operand:TI 1 "register_operand" "r"))
+	      (clobber (match_operand:DI 2 "register_operand" "=&r"))])]
+  ""
+  "
+{
+  /* ??? Should now be enforced by tweeks to push_secondary_reload.  */
+  if (reg_overlap_mentioned_p (operands[2], operands[0])
+      || reg_overlap_mentioned_p (operands[2], operands[1]))
+    abort ();
+}")
+
 ;; Floating Point Moves
 ;;
 ;; Note - Patterns for SF mode moves are compulsory, but
@@ -577,10 +722,10 @@
 	  (match_operand:SF 1 "nonmemory_operand" "fG,fG,*r,*r")))]
   "TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "@
-  mov %0 = %F1
-  getf.s %0 = %F1
-  setf.s %0 = %1
-  mov %0 = %1"
+  (%J2) mov %0 = %F1
+  (%J2) getf.s %0 = %F1
+  (%J2) setf.s %0 = %1
+  (%J2) mov %0 = %1"
   [(set_attr "type" "F,M,M,A")
    (set_attr "predicable" "no")])
 
@@ -636,10 +781,10 @@
 	  (match_operand:DF 1 "nonmemory_operand" "fG,fG,*r,*r")))]
   "TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "@
-  mov %0 = %F1
-  getf.d %0 = %F1
-  setf.d %0 = %1
-  mov %0 = %1"
+  (%J2) mov %0 = %F1
+  (%J2) getf.d %0 = %F1
+  (%J2) setf.d %0 = %1
+  (%J2) mov %0 = %1"
   [(set_attr "type" "F,M,M,A")
    (set_attr "predicable" "no")])
 
@@ -674,35 +819,96 @@
   st8%Q0 %0 = %1%P0"
   [(set_attr "type" "F,M,M,M,M,A,M,M")])
 
-(define_expand "movxf"
-  [(set (match_operand:XF 0 "general_operand" "")
-	(match_operand:XF 1 "general_operand" ""))]
+;; With no offsettable memory references, we've got to have a scratch
+;; around to play with the second word if the variable winds up in GRs.
+(define_expand "movtf"
+  [(set (match_operand:TF 0 "general_operand" "")
+	(match_operand:TF 1 "general_operand" ""))]
   ""
   "
 {
-  if (! reload_in_progress && ! reload_completed
-      && ! ia64_move_ok (operands[0], operands[1]))
-    operands[1] = force_reg (XFmode, operands[1]);
+  /* We must support TFmode loads into general registers for stdarg/vararg
+     and unprototyped calls.  We split them into DImode loads for convenience.
+     We don't need TFmode stores from general regs, because a stdarg/vararg
+     routine does a block store to memory of unnamed arguments.  */
+  if (GET_CODE (operands[0]) == REG
+      && GR_REGNO_P (REGNO (operands[0])))
+    {
+      /* We're hoping to transform everything that deals with TFmode
+	 quantities and GR registers early in the compiler.  */
+      if (no_new_pseudos)
+	abort ();
+
+      /* Struct to register can just use TImode instead.  */
+      if ((GET_CODE (operands[1]) == SUBREG
+	   && GET_MODE (SUBREG_REG (operands[1])) == TImode)
+	  || (GET_CODE (operands[1]) == REG
+	      && GR_REGNO_P (REGNO (operands[1]))))
+	{
+	  emit_move_insn (gen_rtx_REG (TImode, REGNO (operands[0])),
+			  SUBREG_REG (operands[1]));
+	  DONE;
+	}
+
+      if (GET_CODE (operands[1]) == CONST_DOUBLE)
+	{
+	  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0])),
+			  operand_subword (operands[1], 0, 0, DImode));
+	  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0]) + 1),
+			  operand_subword (operands[1], 1, 0, DImode));
+	  DONE;
+	}
+
+      /* If the quantity is in a register not known to be GR, spill it.  */
+      if (register_operand (operands[1], TFmode))
+	operands[1] = spill_tfmode_operand (operands[1], 1);
+
+      if (GET_CODE (operands[1]) == MEM)
+	{
+	  rtx out[2];
+
+	  out[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0]));
+	  out[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0])+1);
+
+	  emit_move_insn (out[0], change_address (operands[1], DImode, NULL));
+	  emit_move_insn (out[1],
+			  change_address (operands[1], DImode,
+					  plus_constant (XEXP (operands[1], 0),
+							 8)));
+	  DONE;
+	}
+
+      abort ();
+    }
+
+  if (! reload_in_progress && ! reload_completed)
+    {
+      operands[0] = spill_tfmode_operand (operands[0], 0);
+      operands[1] = spill_tfmode_operand (operands[1], 0);
+
+      if (! ia64_move_ok (operands[0], operands[1]))
+	operands[1] = force_reg (TFmode, operands[1]);
+    }
 }")
 
 ;; ??? There's no easy way to mind volatile acquire/release semantics.
 
 ;; Errata 72 workaround.
-(define_insn "*movxfcc_astep"
+(define_insn "*movtfcc_astep"
   [(cond_exec
      (match_operator 2 "predicate_operator"
        [(match_operand:CC 3 "register_operand" "c")
         (const_int 0)])
-     (set (match_operand:XF 0 "register_operand"  "=f")
-	  (match_operand:XF 1 "nonmemory_operand" "fG")))]
+     (set (match_operand:TF 0 "register_operand"  "=f")
+	  (match_operand:TF 1 "nonmemory_operand" "fG")))]
   "TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
-  "mov %0 = %F1"
+  "(%J2) mov %0 = %F1"
   [(set_attr "type" "F")
    (set_attr "predicable" "no")])
 
-(define_insn "*movxf_internal_astep"
-  [(set (match_operand:XF 0 "destination_operand" "=f,f, m")
-	(match_operand:XF 1 "general_operand"     "fG,m,fG"))]
+(define_insn "*movtf_internal_astep"
+  [(set (match_operand:TF 0 "destination_tfmode_operand" "=f,f, m")
+	(match_operand:TF 1 "general_tfmode_operand"     "fG,m,fG"))]
   "TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "@
   mov %0 = %F1
@@ -711,9 +917,9 @@
   [(set_attr "type" "F,M,M")
    (set_attr "predicable" "no")])
 
-(define_insn "*movxf_internal"
-  [(set (match_operand:XF 0 "destination_operand" "=f,f, m")
-	(match_operand:XF 1 "general_operand"     "fG,m,fG"))]
+(define_insn "*movtf_internal"
+  [(set (match_operand:TF 0 "destination_tfmode_operand" "=f,f, m")
+	(match_operand:TF 1 "general_tfmode_operand"     "fG,m,fG"))]
   "! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])"
   "@
   mov %0 = %F1
@@ -730,22 +936,22 @@
 ;; Signed conversions from a smaller integer to a larger integer
 
 (define_insn "extendqidi2"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(sign_extend:DI (match_operand:QI 1 "register_operand" "r")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(sign_extend:DI (match_operand:QI 1 "gr_register_operand" "r")))]
   ""
   "sxt1 %0 = %1"
   [(set_attr "type" "I")])
 
 (define_insn "extendhidi2"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(sign_extend:DI (match_operand:HI 1 "register_operand" "r")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(sign_extend:DI (match_operand:HI 1 "gr_register_operand" "r")))]
   ""
   "sxt2 %0 = %1"
   [(set_attr "type" "I")])
 
 (define_insn "extendsidi2"
-  [(set (match_operand:DI 0 "register_operand" "=r,*f")
-	(sign_extend:DI (match_operand:SI 1 "register_operand" "r,*f")))]
+  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
+	(sign_extend:DI (match_operand:SI 1 "grfr_register_operand" "r,*f")))]
   ""
   "@
    sxt4 %0 = %1
@@ -755,8 +961,8 @@
 ;; Unsigned conversions from a smaller integer to a larger integer
 
 (define_insn "zero_extendqidi2"
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(zero_extend:DI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
+	(zero_extend:DI (match_operand:QI 1 "gr_nonimmediate_operand" "r,m")))]
   ""
   "@
    zxt1 %0 = %1
@@ -764,8 +970,8 @@
   [(set_attr "type" "I,M")])
 
 (define_insn "zero_extendhidi2"
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(zero_extend:DI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
+	(zero_extend:DI (match_operand:HI 1 "gr_nonimmediate_operand" "r,m")))]
   ""
   "@
    zxt2 %0 = %1
@@ -773,8 +979,9 @@
   [(set_attr "type" "I,M")])
 
 (define_insn "zero_extendsidi2"
-  [(set (match_operand:DI 0 "register_operand" "=r,r,*f")
-	(zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "r,m,*f")))]
+  [(set (match_operand:DI 0 "grfr_register_operand" "=r,r,*f")
+	(zero_extend:DI
+	  (match_operand:SI 1 "grfr_nonimmediate_operand" "r,m,*f")))]
   ""
   "@
    zxt4 %0 = %1
@@ -790,8 +997,8 @@
 ;; would let combine merge the thing into adjacent insns.
 
 (define_insn_and_split "extendsfdf2"
-  [(set (match_operand:DF 0 "register_operand" "=f,f")
-	(float_extend:DF (match_operand:SF 1 "register_operand" "0,f")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f,f")
+	(float_extend:DF (match_operand:SF 1 "fr_register_operand" "0,f")))]
   ""
   "mov %0 = %1"
   "reload_completed"
@@ -799,46 +1006,73 @@
   "if (true_regnum (operands[0]) == true_regnum (operands[1])) DONE;"
   [(set_attr "type" "F")])
 
+(define_insn_and_split "extendsftf2"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f,f")
+	(float_extend:TF (match_operand:SF 1 "fr_register_operand" "0,f")))]
+  ""
+  "mov %0 = %1"
+  "reload_completed"
+  [(set (match_dup 0) (float_extend:TF (match_dup 1)))]
+  "if (true_regnum (operands[0]) == true_regnum (operands[1])) DONE;"
+  [(set_attr "type" "F")])
+
+(define_insn_and_split "extenddftf2"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f,f")
+	(float_extend:TF (match_operand:DF 1 "fr_register_operand" "0,f")))]
+  ""
+  "mov %0 = %1"
+  "reload_completed"
+  [(set (match_dup 0) (float_extend:TF (match_dup 1)))]
+  "if (true_regnum (operands[0]) == true_regnum (operands[1])) DONE;"
+  [(set_attr "type" "F")])
+
 (define_insn "truncdfsf2"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(float_truncate:SF (match_operand:DF 1 "register_operand" "f")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(float_truncate:SF (match_operand:DF 1 "fr_register_operand" "f")))]
   ""
   "fnorm.s %0 = %1%B0"
   [(set_attr "type" "F")])
 
-(define_insn "truncxfsf2"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(float_truncate:SF (match_operand:XF 1 "register_operand" "f")))]
+(define_insn "trunctfsf2"
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(float_truncate:SF (match_operand:TF 1 "fr_register_operand" "f")))]
   ""
   "fnorm.s %0 = %1%B0"
   [(set_attr "type" "F")])
 
-(define_insn "truncxfdf2"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(float_truncate:DF (match_operand:XF 1 "register_operand" "f")))]
+(define_insn "trunctfdf2"
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(float_truncate:DF (match_operand:TF 1 "fr_register_operand" "f")))]
   ""
   "fnorm.d %0 = %1%B0"
   [(set_attr "type" "F")])
 
 ;; Convert between signed integer types and floating point.
 
-(define_insn "floatdixf2"
-  [(set (match_operand:XF 0 "register_operand" "=f")
-	(float:XF (match_operand:DI 1 "register_operand" "f")))]
+(define_insn "floatditf2"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(float:TF (match_operand:DI 1 "fr_register_operand" "f")))]
   ""
   "fcvt.xf %0 = %1"
   [(set_attr "type" "F")])
 
 (define_insn "fix_truncsfdi2"
-  [(set (match_operand:DI 0 "register_operand" "=f")
-	(fix:DI (match_operand:SF 1 "register_operand" "f")))]
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(fix:DI (match_operand:SF 1 "fr_register_operand" "f")))]
   ""
   "fcvt.fx.trunc %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "fix_truncdfdi2"
-  [(set (match_operand:DI 0 "register_operand" "=f")
-	(fix:DI (match_operand:DF 1 "register_operand" "f")))]
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(fix:DI (match_operand:DF 1 "fr_register_operand" "f")))]
+  ""
+  "fcvt.fx.trunc %0 = %1%B0"
+  [(set_attr "type" "F")])
+
+(define_insn "fix_trunctfdi2"
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(fix:DI (match_operand:TF 1 "fr_register_operand" "f")))]
   ""
   "fcvt.fx.trunc %0 = %1%B0"
   [(set_attr "type" "F")])
@@ -846,33 +1080,46 @@
 ;; Convert between unsigned integer types and floating point.
 
 (define_insn "floatunsdisf2"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(unsigned_float:SF (match_operand:DI 1 "register_operand" "f")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(unsigned_float:SF (match_operand:DI 1 "fr_register_operand" "f")))]
   ""
   "fcvt.xuf.s %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "floatunsdidf2"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(unsigned_float:DF (match_operand:DI 1 "register_operand" "f")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(unsigned_float:DF (match_operand:DI 1 "fr_register_operand" "f")))]
   ""
   "fcvt.xuf.d %0 = %1%B0"
   [(set_attr "type" "F")])
 
+(define_insn "floatunsditf2"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(unsigned_float:TF (match_operand:DI 1 "fr_register_operand" "f")))]
+  ""
+  "fcvt.xuf %0 = %1%B0"
+  [(set_attr "type" "F")])
+
 (define_insn "fixuns_truncsfdi2"
-  [(set (match_operand:DI 0 "register_operand" "=f")
-	(unsigned_fix:DI (match_operand:SF 1 "register_operand" "f")))]
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(unsigned_fix:DI (match_operand:SF 1 "fr_register_operand" "f")))]
   ""
   "fcvt.fxu.trunc %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "fixuns_truncdfdi2"
-  [(set (match_operand:DI 0 "register_operand" "=f")
-	(unsigned_fix:DI (match_operand:DF 1 "register_operand" "f")))]
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(unsigned_fix:DI (match_operand:DF 1 "fr_register_operand" "f")))]
   ""
   "fcvt.fxu.trunc %0 = %1%B0"
   [(set_attr "type" "F")])
 
+(define_insn "fixuns_trunctfdi2"
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(unsigned_fix:DI (match_operand:TF 1 "fr_register_operand" "f")))]
+  ""
+  "fcvt.fxu.trunc %0 = %1%B0"
+  [(set_attr "type" "F")])
 
 ;; ::::::::::::::::::::
 ;; ::
@@ -880,12 +1127,9 @@
 ;; ::
 ;; ::::::::::::::::::::
 
-;; ??? It would be useful to have SImode versions of the extract and insert
-;; patterns.
-
 (define_insn "extv"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(sign_extract:DI (match_operand:DI 1 "register_operand" "r")
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(sign_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
 			 (match_operand:DI 2 "const_int_operand" "n")
 			 (match_operand:DI 3 "const_int_operand" "n")))]
   ""
@@ -893,8 +1137,8 @@
   [(set_attr "type" "I")])
 
 (define_insn "extzv"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(zero_extract:DI (match_operand:DI 1 "register_operand" "r")
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(zero_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
 			 (match_operand:DI 2 "const_int_operand" "n")
 			 (match_operand:DI 3 "const_int_operand" "n")))]
   ""
@@ -911,7 +1155,7 @@
 ;; where source2 != dest.
 
 (define_expand "insv"
-  [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "")
+  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "")
 			 (match_operand:DI 1 "const_int_operand" "")
 			 (match_operand:DI 2 "const_int_operand" ""))
 	(match_operand:DI 3 "nonmemory_operand" ""))]
@@ -987,27 +1231,39 @@
 }")
 
 (define_insn "*insv_internal"
-  [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "+r")
+  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
 			 (match_operand:DI 1 "const_int_operand" "n")
 			 (match_operand:DI 2 "const_int_operand" "n"))
 	(match_operand:DI 3 "nonmemory_operand" "rP"))]
-  "(register_operand (operands[3], DImode) && INTVAL (operands[1]) <= 16)
+  "(gr_register_operand (operands[3], DImode) && INTVAL (operands[1]) <= 16)
    || operands[3] == const0_rtx || operands[3] == constm1_rtx"
   "dep %0 = %3, %0, %2, %1"
   [(set_attr "type" "I")])
 
+;; Combine doesn't like to create bitfield insertions into zero.
+(define_insn "*depz_internal"
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(and:DI (ashift:DI (match_operand:DI 1 "gr_register_operand" "r")
+			   (match_operand:DI 2 "const_int_operand" "n"))
+		(match_operand:DI 3 "const_int_operand" "n")))]
+  "CONST_OK_FOR_M (INTVAL (operands[2]))
+   && ia64_depz_field_mask (operands[3], operands[2]) > 0"
+  "*
+{
+  operands[3] = GEN_INT (ia64_depz_field_mask (operands[3], operands[2]));
+  return \"%,dep.z %0 = %1, %2, %3\";
+}"
+  [(set_attr "type" "I")])
+
 (define_insn "shift_mix4left"
-  [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "+r")
+  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
 			 (const_int 32) (const_int 0))
-	(match_operand:DI 1 "register_operand" "r"))
-   (clobber (match_operand:DI 2 "register_operand" "=r"))]
+	(match_operand:DI 1 "gr_register_operand" "r"))
+   (clobber (match_operand:DI 2 "gr_register_operand" "=r"))]
   ""
   "#"
   [(set_attr "type" "unknown")])
 
-;; ??? Need to emit an instruction group barrier here because this gets split
-;; after md_reorg.
-
 (define_split
   [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "")
 			 (const_int 32) (const_int 0))
@@ -1032,18 +1288,18 @@
   "operands[3] = operands[2];")
 
 (define_insn "*mix4left"
-  [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "+r")
+  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
 			 (const_int 32) (const_int 0))
-	(lshiftrt:DI (match_operand:DI 1 "register_operand" "r")
+	(lshiftrt:DI (match_operand:DI 1 "gr_register_operand" "r")
 		     (const_int 32)))]
   ""
   "mix4.l %0 = %0, %r1"
   [(set_attr "type" "I")])
 
 (define_insn "mix4right"
-  [(set (zero_extract:DI (match_operand:DI 0 "register_operand" "+r")
+  [(set (zero_extract:DI (match_operand:DI 0 "gr_register_operand" "+r")
 			 (const_int 32) (const_int 32))
-	(match_operand:DI 1 "reg_or_0_operand" "rO"))]
+	(match_operand:DI 1 "gr_reg_or_0_operand" "rO"))]
   ""
   "mix4.r %0 = %r1, %0"
   [(set_attr "type" "I")])
@@ -1051,9 +1307,10 @@
 ;; This is used by the rotrsi3 pattern.
 
 (define_insn "*mix4right_3op"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(ior:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "r"))
-		(ashift:DI (zero_extend:DI (match_operand:SI 2 "register_operand" "r"))
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(ior:DI (zero_extend:DI (match_operand:SI 1 "gr_register_operand" "r"))
+		(ashift:DI (zero_extend:DI
+			     (match_operand:SI 2 "gr_register_operand" "r"))
 			   (const_int 32))))]
   ""
   "mix4.r %0 = %2, %1"
@@ -1066,36 +1323,10 @@
 ;; ::
 ;; ::::::::::::::::::::
 
-;; We handle 32-bit arithmetic just like the alpha port does.
-
-(define_expand "addsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (match_operand:SI 1 "register_operand" "")
-		 (match_operand:SI 2 "reg_or_22bit_operand" "")))]
-  ""
-  "
-{
-  if (optimize)
-    {
-      rtx op1 = gen_lowpart (DImode, operands[1]);
-      rtx op2 = gen_lowpart (DImode, operands[2]);
-
-      if (! cse_not_expected)
-	{
-	  rtx tmp = gen_reg_rtx (DImode);
-	  emit_insn (gen_adddi3 (tmp, op1, op2));
-	  emit_move_insn (operands[0], gen_lowpart (SImode, tmp));
-	}
-      else
-	emit_insn (gen_adddi3 (gen_lowpart (DImode, operands[0]), op1, op2));
-      DONE;
-    }
-}")
-
-(define_insn "*addsi3_internal"
-  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
-	(plus:SI (match_operand:SI 1 "register_operand" "%r,r,a")
-		 (match_operand:SI 2 "reg_or_22bit_operand" "r,I,J")))]
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "gr_register_operand" "=r,r,r")
+	(plus:SI (match_operand:SI 1 "gr_register_operand" "%r,r,a")
+		 (match_operand:SI 2 "gr_reg_or_22bit_operand" "r,I,J")))]
   ""
   "@
   add %0 = %1, %2
@@ -1104,130 +1335,76 @@
   [(set_attr "type" "A")])
 
 (define_insn "*addsi3_plus1"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (plus:SI (match_operand:SI 1 "register_operand" "r")
-			  (match_operand:SI 2 "register_operand" "r"))
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(plus:SI (plus:SI (match_operand:SI 1 "gr_register_operand" "r")
+			  (match_operand:SI 2 "gr_register_operand" "r"))
 		 (const_int 1)))]
   ""
   "add %0 = %1, %2, 1"
   [(set_attr "type" "A")])
 
 (define_insn "*addsi3_plus1_alt"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "r")
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(plus:SI (mult:SI (match_operand:SI 1 "gr_register_operand" "r")
 			  (const_int 2))
 		 (const_int 1)))]
   ""
   "add %0 = %1, %1, 1"
   [(set_attr "type" "A")])
 
-(define_expand "subsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(minus:SI (match_operand:SI 1 "reg_or_8bit_operand" "")
-		  (match_operand:SI 2 "register_operand" "")))]
+(define_insn "*addsi3_shladd"
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(plus:SI (mult:SI (match_operand:SI 1 "gr_register_operand" "r")
+			  (match_operand:SI 2 "shladd_operand" "n"))
+		 (match_operand:SI 3 "gr_register_operand" "r")))]
   ""
-  "
-{
-  if (optimize)
-    {
-      rtx op1 = gen_lowpart (DImode, operands[1]);
-      rtx op2 = gen_lowpart (DImode, operands[2]);
-
-      if (! cse_not_expected)
-	{
-	  rtx tmp = gen_reg_rtx (DImode);
-	  emit_insn (gen_subdi3 (tmp, op1, op2));
-	  emit_move_insn (operands[0], gen_lowpart (SImode, tmp));
-	}
-      else
-	emit_insn (gen_subdi3 (gen_lowpart (DImode, operands[0]), op1, op2));
-      DONE;
-    }
-}")
+  "shladd %0 = %1, %S2, %3"
+  [(set_attr "type" "A")])
 
-(define_insn "*subsi3_internal"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(minus:SI (match_operand:SI 1 "reg_or_8bit_operand" "rK")
-		  (match_operand:SI 2 "register_operand" "r")))]
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(minus:SI (match_operand:SI 1 "gr_reg_or_8bit_operand" "rK")
+		  (match_operand:SI 2 "gr_register_operand" "r")))]
   ""
   "sub %0 = %1, %2"
   [(set_attr "type" "A")])
 
 (define_insn "*subsi3_minus1"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (not:SI (match_operand:SI 1 "register_operand" "r"))
-		 (match_operand:SI 2 "register_operand" "r")))]
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(plus:SI (not:SI (match_operand:SI 1 "gr_register_operand" "r"))
+		 (match_operand:SI 2 "gr_register_operand" "r")))]
   ""
   "sub %0 = %2, %1, 1"
   [(set_attr "type" "A")])
 
-(define_expand "mulsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mult:SI (match_operand:SI 1 "register_operand" "")
-		 (match_operand:SI 2 "register_operand" "")))]
-  ""
-  "
-{
-  if (optimize)
-    {
-      rtx op1 = gen_lowpart (DImode, operands[1]);
-      rtx op2 = gen_lowpart (DImode, operands[2]);
-
-      if (! cse_not_expected)
-	{
-	  rtx tmp = gen_reg_rtx (DImode);
-	  emit_insn (gen_muldi3 (tmp, op1, op2));
-	  emit_move_insn (operands[0], gen_lowpart (SImode, tmp));
-	}
-      else
-	emit_insn (gen_muldi3 (gen_lowpart (DImode, operands[0]), op1, op2));
-      DONE;
-    }
-}")
-
-;; ??? Could add maddsi3 patterns patterned after the madddi3 patterns.
-
-(define_insn "*mulsi3_internal"
-  [(set (match_operand:SI 0 "register_operand" "=f")
-	(mult:SI (match_operand:SI 1 "register_operand" "f")
-		 (match_operand:SI 2 "nonmemory_operand" "f")))]
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "fr_register_operand" "=f")
+	(mult:SI (match_operand:SI 1 "grfr_register_operand" "f")
+		 (match_operand:SI 2 "grfr_register_operand" "f")))]
   ""
   "xma.l %0 = %1, %2, f0%B0"
   [(set_attr "type" "F")])
 
-(define_expand "negsi2"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(neg:SI (match_operand:SI 1 "register_operand" "")))]
+(define_insn "*maddsi3"
+  [(set (match_operand:SI 0 "fr_register_operand" "=f")
+	(plus:SI (mult:SI (match_operand:SI 1 "grfr_register_operand" "f")
+			  (match_operand:SI 2 "grfr_register_operand" "f"))
+		 (match_operand:SI 3 "grfr_register_operand" "f")))]
   ""
-  "
-{
-  if (optimize)
-    {
-      rtx op1 = gen_lowpart (DImode, operands[1]);
-
-      if (! cse_not_expected)
-	{
-	  rtx tmp = gen_reg_rtx (DImode);
-	  emit_insn (gen_negdi2 (tmp, op1));
-	  emit_move_insn (operands[0], gen_lowpart (SImode, tmp));
-	}
-      else
-	emit_insn (gen_negdi2 (gen_lowpart (DImode, operands[0]), op1));
-      DONE;
-    }
-}")
+  "xma.l %0 = %1, %2, %3%B0"
+  [(set_attr "type" "F")])
 
-(define_insn "*negsi2_internal"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(neg:SI (match_operand:SI 1 "register_operand" "r")))]
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(neg:SI (match_operand:SI 1 "gr_register_operand" "r")))]
   ""
   "sub %0 = r0, %1"
   [(set_attr "type" "A")])
 
 (define_expand "abssi2"
   [(set (match_dup 2)
-	(ge:CC (match_operand:SI 1 "register_operand" "") (const_int 0)))
-   (set (match_operand:SI 0 "register_operand" "")
+	(ge:CC (match_operand:SI 1 "gr_register_operand" "") (const_int 0)))
+   (set (match_operand:SI 0 "gr_register_operand" "")
 	(if_then_else:SI (eq:CC (match_dup 2) (const_int 0))
 			 (neg:SI (match_dup 1))
 			 (match_dup 1)))]
@@ -1239,9 +1416,9 @@
 
 (define_expand "sminsi3"
   [(set (match_dup 3)
-	(ge:CC (match_operand:SI 1 "register_operand" "")
-	       (match_operand:SI 2 "register_operand" "")))
-   (set (match_operand:SI 0 "register_operand" "")
+	(ge:CC (match_operand:SI 1 "gr_register_operand" "")
+	       (match_operand:SI 2 "gr_register_operand" "")))
+   (set (match_operand:SI 0 "gr_register_operand" "")
 	(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 2) (match_dup 1)))]
   ""
@@ -1252,9 +1429,9 @@
 
 (define_expand "smaxsi3"
   [(set (match_dup 3)
-	(ge:CC (match_operand:SI 1 "register_operand" "")
-	       (match_operand:SI 2 "register_operand" "")))
-   (set (match_operand:SI 0 "register_operand" "")
+	(ge:CC (match_operand:SI 1 "gr_register_operand" "")
+	       (match_operand:SI 2 "gr_register_operand" "")))
+   (set (match_operand:SI 0 "gr_register_operand" "")
 	(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 1) (match_dup 2)))]
   ""
@@ -1265,9 +1442,9 @@
 
 (define_expand "uminsi3"
   [(set (match_dup 3)
-	(geu:CC (match_operand:SI 1 "register_operand" "")
-		(match_operand:SI 2 "register_operand" "")))
-   (set (match_operand:SI 0 "register_operand" "")
+	(geu:CC (match_operand:SI 1 "gr_register_operand" "")
+		(match_operand:SI 2 "gr_register_operand" "")))
+   (set (match_operand:SI 0 "gr_register_operand" "")
 	(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 2) (match_dup 1)))]
   ""
@@ -1278,9 +1455,9 @@
 
 (define_expand "umaxsi3"
   [(set (match_dup 3)
-	(geu:CC (match_operand:SI 1 "register_operand" "")
-		(match_operand:SI 2 "register_operand" "")))
-   (set (match_operand:SI 0 "register_operand" "")
+	(geu:CC (match_operand:SI 1 "gr_register_operand" "")
+		(match_operand:SI 2 "gr_register_operand" "")))
+   (set (match_operand:SI 0 "gr_register_operand" "")
 	(if_then_else:SI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 1) (match_dup 2)))]
   ""
@@ -1297,9 +1474,9 @@
 ;; ::::::::::::::::::::
 
 (define_insn "adddi3"
-  [(set (match_operand:DI 0 "register_operand" "=r,r,r")
-	(plus:DI (match_operand:DI 1 "register_operand" "%r,r,a")
-		 (match_operand:DI 2 "reg_or_22bit_operand" "r,I,J")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r,r,r")
+	(plus:DI (match_operand:DI 1 "gr_register_operand" "%r,r,a")
+		 (match_operand:DI 2 "gr_reg_or_22bit_operand" "r,I,J")))]
   ""
   "@
   add %0 = %1, %2
@@ -1308,9 +1485,9 @@
   [(set_attr "type" "A")])
 
 (define_insn "*adddi3_plus1"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (plus:DI (match_operand:DI 1 "register_operand" "r")
-			  (match_operand:DI 2 "register_operand" "r"))
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(plus:DI (plus:DI (match_operand:DI 1 "gr_register_operand" "r")
+			  (match_operand:DI 2 "gr_register_operand" "r"))
 		 (const_int 1)))]
   ""
   "add %0 = %1, %2, 1"
@@ -1320,8 +1497,8 @@
 ;; eliminator hack handle it, which results in the 1 being forced into
 ;; a register, but not more ugliness here.
 (define_insn "*adddi3_plus1_alt"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (mult:DI (match_operand:DI 1 "register_operand" "r")
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(plus:DI (mult:DI (match_operand:DI 1 "gr_register_operand" "r")
 			  (const_int 2))
 		 (const_int 1)))]
   ""
@@ -1329,25 +1506,27 @@
   [(set_attr "type" "A")])
 
 (define_insn "subdi3"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(minus:DI (match_operand:DI 1 "reg_or_8bit_operand" "rK")
-		  (match_operand:DI 2 "register_operand" "r")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(minus:DI (match_operand:DI 1 "gr_reg_or_8bit_operand" "rK")
+		  (match_operand:DI 2 "gr_register_operand" "r")))]
   ""
   "sub %0 = %1, %2"
   [(set_attr "type" "A")])
 
 (define_insn "*subdi3_minus1"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (not:DI (match_operand:DI 1 "register_operand" "r"))
-		 (match_operand:DI 2 "register_operand" "r")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(plus:DI (not:DI (match_operand:DI 1 "gr_register_operand" "r"))
+		 (match_operand:DI 2 "gr_register_operand" "r")))]
   ""
   "sub %0 = %2, %1, 1"
   [(set_attr "type" "A")])
 
+;; ??? Use grfr instead of fr because of virtual register elimination
+;; and silly test cases multiplying by the frame pointer.
 (define_insn "muldi3"
-  [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (match_operand:DI 1 "register_operand" "f")
-		 (match_operand:DI 2 "register_operand" "f")))]
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(mult:DI (match_operand:DI 1 "grfr_register_operand" "f")
+		 (match_operand:DI 2 "grfr_register_operand" "f")))]
   ""
   "xma.l %0 = %1, %2, f0%B0"
   [(set_attr "type" "F")])
@@ -1364,10 +1543,10 @@
 ;; ??? Maybe we should change how adds are canonicalized.
 
 (define_insn "*madddi3"
-  [(set (match_operand:DI 0 "register_operand" "=f")
-	(plus:DI (mult:DI (match_operand:DI 1 "register_operand" "f")
-			  (match_operand:DI 2 "register_operand" "f"))
-		 (match_operand:DI 3 "register_operand" "f")))
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
+	(plus:DI (mult:DI (match_operand:DI 1 "grfr_register_operand" "f")
+			  (match_operand:DI 2 "grfr_register_operand" "f"))
+		 (match_operand:DI 3 "grfr_register_operand" "f")))
    (clobber (match_scratch:DI 4 "=X"))]
   ""
   "xma.l %0 = %1, %2, %3%B0"
@@ -1400,7 +1579,7 @@
 	(plus:DI (plus:DI (mult:DI (match_operand:DI 1 "register_operand" "")
 				   (match_operand:DI 2 "register_operand" ""))
 			  (match_operand:DI 3 "register_operand" ""))
-		 (match_operand:DI 4 "reg_or_14bit_operand" "")))
+		 (match_operand:DI 4 "gr_reg_or_14bit_operand" "")))
    (clobber (match_scratch:DI 5 ""))]
   "reload_completed"
   [(parallel [(set (match_dup 5) (plus:DI (mult:DI (match_dup 1) (match_dup 2))
@@ -1416,38 +1595,42 @@
 ;; to generate them.
 
 (define_insn "smuldi3_highpart"
-  [(set (match_operand:DI 0 "register_operand" "=f")
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
 	(truncate:DI
 	 (lshiftrt:TI
-	  (mult:TI (sign_extend:TI (match_operand:DI 1 "register_operand" "f"))
-		   (sign_extend:TI (match_operand:DI 2 "register_operand" "f")))
+	  (mult:TI (sign_extend:TI
+		     (match_operand:DI 1 "fr_register_operand" "f"))
+		   (sign_extend:TI
+		     (match_operand:DI 2 "fr_register_operand" "f")))
 	  (const_int 64))))]
   ""
   "xma.h %0 = %1, %2, f0%B0"
   [(set_attr "type" "F")])
 
 (define_insn "umuldi3_highpart"
-  [(set (match_operand:DI 0 "register_operand" "=f")
+  [(set (match_operand:DI 0 "fr_register_operand" "=f")
 	(truncate:DI
 	 (lshiftrt:TI
-	  (mult:TI (zero_extend:TI (match_operand:DI 1 "register_operand" "f"))
-		   (zero_extend:TI (match_operand:DI 2 "register_operand" "f")))
+	  (mult:TI (zero_extend:TI
+		     (match_operand:DI 1 "fr_register_operand" "f"))
+		   (zero_extend:TI
+		     (match_operand:DI 2 "fr_register_operand" "f")))
 	  (const_int 64))))]
   ""
   "xma.hu %0 = %1, %2, f0%B0"
   [(set_attr "type" "F")])
 
 (define_insn "negdi2"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(neg:DI (match_operand:DI 1 "register_operand" "r")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(neg:DI (match_operand:DI 1 "gr_register_operand" "r")))]
   ""
   "sub %0 = r0, %1"
   [(set_attr "type" "A")])
 
 (define_expand "absdi2"
   [(set (match_dup 2)
-	(ge:CC (match_operand:DI 1 "register_operand" "") (const_int 0)))
-   (set (match_operand:DI 0 "register_operand" "")
+	(ge:CC (match_operand:DI 1 "gr_register_operand" "") (const_int 0)))
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(if_then_else:DI (eq:CC (match_dup 2) (const_int 0))
 			 (neg:DI (match_dup 1))
 			 (match_dup 1)))]
@@ -1459,9 +1642,9 @@
 
 (define_expand "smindi3"
   [(set (match_dup 3)
-	(ge:CC (match_operand:DI 1 "register_operand" "")
-	       (match_operand:DI 2 "register_operand" "")))
-   (set (match_operand:DI 0 "register_operand" "")
+	(ge:CC (match_operand:DI 1 "gr_register_operand" "")
+	       (match_operand:DI 2 "gr_register_operand" "")))
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 2) (match_dup 1)))]
   ""
@@ -1472,9 +1655,9 @@
 
 (define_expand "smaxdi3"
   [(set (match_dup 3)
-	(ge:CC (match_operand:DI 1 "register_operand" "")
-	       (match_operand:DI 2 "register_operand" "")))
-   (set (match_operand:DI 0 "register_operand" "")
+	(ge:CC (match_operand:DI 1 "gr_register_operand" "")
+	       (match_operand:DI 2 "gr_register_operand" "")))
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 1) (match_dup 2)))]
   ""
@@ -1485,9 +1668,9 @@
 
 (define_expand "umindi3"
   [(set (match_dup 3)
-	(geu:CC (match_operand:DI 1 "register_operand" "")
-		(match_operand:DI 2 "register_operand" "")))
-   (set (match_operand:DI 0 "register_operand" "")
+	(geu:CC (match_operand:DI 1 "gr_register_operand" "")
+		(match_operand:DI 2 "gr_register_operand" "")))
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 2) (match_dup 1)))]
   ""
@@ -1498,9 +1681,9 @@
 
 (define_expand "umaxdi3"
   [(set (match_dup 3)
-	(geu:CC (match_operand:DI 1 "register_operand" "")
-		(match_operand:DI 2 "register_operand" "")))
-   (set (match_operand:DI 0 "register_operand" "")
+	(geu:CC (match_operand:DI 1 "gr_register_operand" "")
+		(match_operand:DI 2 "gr_register_operand" "")))
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(if_then_else:DI (ne:CC (match_dup 3) (const_int 0))
 			 (match_dup 1) (match_dup 2)))]
   ""
@@ -1511,12 +1694,12 @@
 
 (define_expand "ffsdi2"
   [(set (match_dup 6)
-	(eq:CC (match_operand:DI 1 "register_operand" "") (const_int 0)))
+	(eq:CC (match_operand:DI 1 "gr_register_operand" "") (const_int 0)))
    (set (match_dup 2) (plus:DI (match_dup 1) (const_int -1)))
    (set (match_dup 5) (const_int 0))
    (set (match_dup 3) (xor:DI (match_dup 1) (match_dup 2)))
    (set (match_dup 4) (unspec:DI [(match_dup 3)] 8))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(if_then_else:DI (ne:CC (match_dup 6) (const_int 0))
 			 (match_dup 5) (match_dup 4)))]
   ""
@@ -1530,8 +1713,8 @@
 }")
 
 (define_insn "*popcnt"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec:DI [(match_operand:DI 1 "register_operand" "r")] 8))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(unspec:DI [(match_operand:DI 1 "gr_register_operand" "r")] 8))]
   ""
   "popcnt %0 = %1"
   [(set_attr "type" "I")])
@@ -1544,88 +1727,88 @@
 ;; ::::::::::::::::::::
 
 (define_insn "addsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(plus:SF (match_operand:SF 1 "register_operand" "%f")
-		 (match_operand:SF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(plus:SF (match_operand:SF 1 "fr_register_operand" "%f")
+		 (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fadd.s %0 = %1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "subsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(minus:SF (match_operand:SF 1 "reg_or_fp01_operand" "fG")
-		  (match_operand:SF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(minus:SF (match_operand:SF 1 "fr_reg_or_fp01_operand" "fG")
+		  (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fsub.s %0 = %F1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "mulsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(mult:SF (match_operand:SF 1 "register_operand" "%f")
-		 (match_operand:SF 2 "register_operand" "f")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(mult:SF (match_operand:SF 1 "fr_register_operand" "%f")
+		 (match_operand:SF 2 "fr_register_operand" "f")))]
   ""
   "fmpy.s %0 = %1, %2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "abssf2"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(abs:SF (match_operand:SF 1 "register_operand" "f")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(abs:SF (match_operand:SF 1 "fr_register_operand" "f")))]
   ""
   "fabs %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "negsf2"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(neg:SF (match_operand:SF 1 "register_operand" "f")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(neg:SF (match_operand:SF 1 "fr_register_operand" "f")))]
   ""
   "fneg %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*nabssf2"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(neg:SF (abs:SF (match_operand:SF 1 "register_operand" "f"))))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(neg:SF (abs:SF (match_operand:SF 1 "fr_register_operand" "f"))))]
   ""
   "fnegabs %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "minsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(smin:SF (match_operand:SF 1 "register_operand" "f")
-		 (match_operand:SF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(smin:SF (match_operand:SF 1 "fr_register_operand" "f")
+		 (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fmin %0 = %1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "maxsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(smax:SF (match_operand:SF 1 "register_operand" "f")
-		 (match_operand:SF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(smax:SF (match_operand:SF 1 "fr_register_operand" "f")
+		 (match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fmax %0 = %1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*maddsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(plus:SF (mult:SF (match_operand:SF 1 "register_operand" "f")
-			  (match_operand:SF 2 "register_operand" "f"))
-		 (match_operand:SF 3 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(plus:SF (mult:SF (match_operand:SF 1 "fr_register_operand" "f")
+			  (match_operand:SF 2 "fr_register_operand" "f"))
+		 (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fma.s %0 = %1, %2, %F3%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*msubsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(minus:SF (mult:SF (match_operand:SF 1 "register_operand" "f")
-			   (match_operand:SF 2 "register_operand" "f"))
-		  (match_operand:SF 3 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(minus:SF (mult:SF (match_operand:SF 1 "fr_register_operand" "f")
+			   (match_operand:SF 2 "fr_register_operand" "f"))
+		  (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fms.s %0 = %1, %2, %F3%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*nmulsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(neg:SF (mult:SF (match_operand:SF 1 "register_operand" "f")
-			 (match_operand:SF 2 "register_operand" "f"))))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(neg:SF (mult:SF (match_operand:SF 1 "fr_register_operand" "f")
+			 (match_operand:SF 2 "fr_register_operand" "f"))))]
   ""
   "fnmpy.s %0 = %1, %2%B0"
   [(set_attr "type" "F")])
@@ -1633,10 +1816,10 @@
 ;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?
 
 (define_insn "*nmaddsf3"
-  [(set (match_operand:SF 0 "register_operand" "=f")
-	(plus:SF (neg:SF (mult:SF (match_operand:SF 1 "register_operand" "f")
-				  (match_operand:SF 2 "register_operand" "f")))
-		 (match_operand:SF 3 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:SF 0 "fr_register_operand" "=f")
+	(plus:SF (neg:SF (mult:SF (match_operand:SF 1 "fr_register_operand" "f")
+				  (match_operand:SF 2 "fr_register_operand" "f")))
+		 (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fnma.s %0 = %1, %2, %F3%B0"
   [(set_attr "type" "F")])
@@ -1649,88 +1832,88 @@
 ;; ::::::::::::::::::::
 
 (define_insn "adddf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(plus:DF (match_operand:DF 1 "register_operand" "%f")
-		 (match_operand:DF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(plus:DF (match_operand:DF 1 "fr_register_operand" "%f")
+		 (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fadd.d %0 = %1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "subdf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(minus:DF (match_operand:DF 1 "reg_or_fp01_operand" "fG")
-		  (match_operand:DF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(minus:DF (match_operand:DF 1 "fr_reg_or_fp01_operand" "fG")
+		  (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fsub.d %0 = %F1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "muldf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(mult:DF (match_operand:DF 1 "register_operand" "f")
-		 (match_operand:DF 2 "register_operand" "f")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(mult:DF (match_operand:DF 1 "fr_register_operand" "f")
+		 (match_operand:DF 2 "fr_register_operand" "f")))]
   ""
   "fmpy.d %0 = %1, %2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "absdf2"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(abs:DF (match_operand:DF 1 "register_operand" "f")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(abs:DF (match_operand:DF 1 "fr_register_operand" "f")))]
   ""
   "fabs %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "negdf2"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(neg:DF (match_operand:DF 1 "register_operand" "f")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(neg:DF (match_operand:DF 1 "fr_register_operand" "f")))]
   ""
   "fneg %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*nabsdf2"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(neg:DF (abs:DF (match_operand:DF 1 "register_operand" "f"))))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(neg:DF (abs:DF (match_operand:DF 1 "fr_register_operand" "f"))))]
   ""
   "fnegabs %0 = %1%B0"
   [(set_attr "type" "F")])
 
 (define_insn "mindf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(smin:DF (match_operand:DF 1 "register_operand" "f")
-		 (match_operand:DF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(smin:DF (match_operand:DF 1 "fr_register_operand" "f")
+		 (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fmin %0 = %1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "maxdf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(smax:DF (match_operand:DF 1 "register_operand" "f")
-		 (match_operand:DF 2 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(smax:DF (match_operand:DF 1 "fr_register_operand" "f")
+		 (match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fmax %0 = %1, %F2%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*madddf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(plus:DF (mult:DF (match_operand:DF 1 "register_operand" "f")
-			  (match_operand:DF 2 "register_operand" "f"))
-		 (match_operand:DF 3 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(plus:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
+			  (match_operand:DF 2 "fr_register_operand" "f"))
+		 (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fma.d %0 = %1, %2, %F3%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*msubdf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(minus:DF (mult:DF (match_operand:DF 1 "register_operand" "f")
-			   (match_operand:DF 2 "register_operand" "f"))
-		  (match_operand:DF 3 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(minus:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
+			   (match_operand:DF 2 "fr_register_operand" "f"))
+		  (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fms.d %0 = %1, %2, %F3%B0"
   [(set_attr "type" "F")])
 
 (define_insn "*nmuldf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(neg:DF (mult:DF (match_operand:DF 1 "register_operand" "f")
-			 (match_operand:DF 2 "register_operand" "f"))))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(neg:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
+			 (match_operand:DF 2 "fr_register_operand" "f"))))]
   ""
   "fnmpy.d %0 = %1, %2%B0"
   [(set_attr "type" "F")])
@@ -1738,125 +1921,216 @@
 ;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?
 
 (define_insn "*nmadddf3"
-  [(set (match_operand:DF 0 "register_operand" "=f")
-	(plus:DF (neg:DF (mult:DF (match_operand:DF 1 "register_operand" "f")
-				  (match_operand:DF 2 "register_operand" "f")))
-		 (match_operand:DF 3 "reg_or_fp01_operand" "fG")))]
+  [(set (match_operand:DF 0 "fr_register_operand" "=f")
+	(plus:DF (neg:DF (mult:DF (match_operand:DF 1 "fr_register_operand" "f")
+				  (match_operand:DF 2 "fr_register_operand" "f")))
+		 (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")))]
   ""
   "fnma.d %0 = %1, %2, %F3%B0"
   [(set_attr "type" "F")])
-
 
 ;; ::::::::::::::::::::
 ;; ::
-;; :: 32 bit Integer Shifts and Rotates
+;; :: 80 bit floating point arithmetic
 ;; ::
 ;; ::::::::::::::::::::
 
-;; There is no sign-extend form of dep, so we only get 32 bits of valid result
-;; instead of 64 like the patterns below.
-
-;; Using a predicate that accepts only constants doesn't work, because optabs
-;; will load the operand into a register and call the pattern if the predicate
-;; did not accept it on the first try.  So we use nonmemory_operand and then
-;; verify that we have an appropriate constant in the expander.
+(define_insn "addtf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(plus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
+  ""
+  "fadd %0 = %F1, %F2%B0"
+  [(set_attr "type" "F")])
 
-(define_expand "ashlsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(ashift:SI (match_operand:SI 1 "register_operand" "")
-		   (match_operand:SI 2 "nonmemory_operand" "")))]
+(define_insn "subtf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(minus:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+		  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
   ""
-  "
-{
-  if (! shift_32bit_count_operand (operands[2], SImode))
-    FAIL;
-}")
+  "fsub %0 = %F1, %F2%B0"
+  [(set_attr "type" "F")])
 
-(define_insn "*ashlsi3_internal"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ashift:SI (match_operand:SI 1 "register_operand" "r")
-		   (match_operand:SI 2 "shift_32bit_count_operand" "n")))]
+(define_insn "multf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
   ""
-  "dep.z %0 = %1, %2, %E2"
-  [(set_attr "type" "I")])
+  "fmpy %0 = %F1, %F2%B0"
+  [(set_attr "type" "F")])
 
-;; This is really an extract, but this is how combine canonicalizes the
-;; operation.
+(define_insn "abstf2"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(abs:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")))]
+  ""
+  "fabs %0 = %F1%B0"
+  [(set_attr "type" "F")])
 
-(define_expand "ashrsi3"
-  [(set (match_dup 3)
-	(ashiftrt:DI (sign_extend:DI
-		      (match_operand:SI 1 "register_operand" ""))
-		     (match_operand:DI 2 "nonmemory_operand" "")))
-   (set (match_operand:SI 0 "register_operand" "") (match_dup 4))]
+(define_insn "negtf2"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(neg:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")))]
   ""
-  "
-{
-  if (! shift_32bit_count_operand (operands[2], SImode))
-    FAIL;
+  "fneg %0 = %F1%B0"
+  [(set_attr "type" "F")])
 
-  operands[3] = gen_reg_rtx (DImode);
-  operands[4] = gen_lowpart (SImode, operands[3]);
-}")
+(define_insn "*nabstf2"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(neg:TF (abs:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG"))))]
+  ""
+  "fnegabs %0 = %F1%B0"
+  [(set_attr "type" "F")])
 
-(define_insn "*ashrsi3_internal"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(ashiftrt:DI (sign_extend:DI
-		      (match_operand:SI 1 "register_operand" "r"))
-		     (match_operand:DI 2 "shift_32bit_count_operand" "n")))]
+(define_insn "mintf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(smin:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
   ""
-  "extr %0 = %1, %2, %E2"
-  [(set_attr "type" "I")])
+  "fmin %0 = %F1, %F2%B0"
+  [(set_attr "type" "F")])
 
-;; This is really an extract, but this is how combine canonicalizes the
-;; operation.
+(define_insn "maxtf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(smax:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+		 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))]
+  ""
+  "fmax %0 = %F1, %F2%B0"
+  [(set_attr "type" "F")])
 
-(define_expand "lshrsi3"
-  [(set (match_dup 3)
-	(lshiftrt:DI (zero_extend:DI
-		      (match_operand:SI 1 "register_operand" ""))
-		     (match_operand:DI 2 "nonmemory_operand" "")))
-   (set (match_operand:SI 0 "register_operand" "") (match_dup 4))]
+(define_insn "*maddtf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(plus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+			  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
+		 (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))]
+  ""
+  "fma %0 = %F1, %F2, %F3%B0"
+  [(set_attr "type" "F")])
+
+(define_insn "*msubtf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(minus:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+			   (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))
+		  (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))]
+  ""
+  "fms %0 = %F1, %F2, %F3%B0"
+  [(set_attr "type" "F")])
+
+(define_insn "*nmultf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(neg:TF (mult:TF (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+			 (match_operand:TF 2 "tfreg_or_fp01_operand" "fG"))))]
+  ""
+  "fnmpy %0 = %F1, %F2%B0"
+  [(set_attr "type" "F")])
+
+;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?
+
+(define_insn "*nmaddtf3"
+  [(set (match_operand:TF 0 "fr_register_operand" "=f")
+	(plus:TF (neg:TF (mult:TF
+			  (match_operand:TF 1 "tfreg_or_fp01_operand" "fG")
+			  (match_operand:TF 2 "tfreg_or_fp01_operand" "fG")))
+		 (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")))]
+  ""
+  "fnma %0 = %F1, %F2, %F3%B0"
+  [(set_attr "type" "F")])
+
+;; ::::::::::::::::::::
+;; ::
+;; :: 32 bit Integer Shifts and Rotates
+;; ::
+;; ::::::::::::::::::::
+
+(define_expand "ashlsi3"
+  [(set (match_operand:SI 0 "gr_register_operand" "")
+	(ashift:SI (match_operand:SI 1 "gr_register_operand" "")
+		   (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
   ""
   "
 {
-  if (! shift_32bit_count_operand (operands[2], SImode))
-    FAIL;
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      /* Why oh why didn't Intel arrange for SHIFT_COUNT_TRUNCATED?  Now
+	 we've got to get rid of stray bits outside the SImode register.  */
+      rtx subshift = gen_reg_rtx (DImode);
+      emit_insn (gen_zero_extendsidi2 (subshift, operands[2]));
+      operands[2] = subshift;
+    }
+}")
 
-  operands[3] = gen_reg_rtx (DImode);
-  operands[4] = gen_lowpart (SImode, operands[3]);
+(define_insn "*ashlsi3_internal"
+  [(set (match_operand:SI 0 "gr_register_operand" "=r,r,r")
+	(ashift:SI (match_operand:SI 1 "gr_register_operand" "r,r,r")
+		   (match_operand:DI 2 "gr_reg_or_5bit_operand" "R,n,r")))]
+  ""
+  "@
+   shladd %0 = %1, %2, r0
+   dep.z %0 = %1, %2, %E2
+   shl %0 = %1, %2"
+  [(set_attr "type" "A,I,I")])
+
+(define_expand "ashrsi3"
+  [(set (match_operand:SI 0 "gr_register_operand" "")
+	(ashiftrt:SI (match_operand:SI 1 "gr_register_operand" "")
+		     (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
+  ""
+  "
+{
+  rtx subtarget = gen_reg_rtx (DImode);
+  if (GET_CODE (operands[2]) == CONST_INT)
+    emit_insn (gen_extv (subtarget, gen_lowpart (DImode, operands[1]),
+			 GEN_INT (32 - INTVAL (operands[2])), operands[2]));
+  else
+    {
+      rtx subshift = gen_reg_rtx (DImode);
+      emit_insn (gen_extendsidi2 (subtarget, operands[1]));
+      emit_insn (gen_zero_extendsidi2 (subshift, operands[2]));
+      emit_insn (gen_ashrdi3 (subtarget, subtarget, subshift));
+    }
+  emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);
+  DONE;
 }")
 
-(define_insn "*lshrsi3_internal"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(lshiftrt:DI (zero_extend:DI
-		      (match_operand:SI 1 "register_operand" "r"))
-		     (match_operand:DI 2 "shift_32bit_count_operand" "n")))]
+(define_expand "lshrsi3"
+  [(set (match_operand:SI 0 "gr_register_operand" "")
+	(lshiftrt:SI (match_operand:SI 1 "gr_register_operand" "")
+		     (match_operand:SI 2 "gr_reg_or_5bit_operand" "")))]
   ""
-  "extr.u %0 = %1, %2, %E2"
-  [(set_attr "type" "I")])
+  "
+{
+  rtx subtarget = gen_reg_rtx (DImode);
+  if (GET_CODE (operands[2]) == CONST_INT)
+    emit_insn (gen_extzv (subtarget, gen_lowpart (DImode, operands[1]),
+			  GEN_INT (32 - INTVAL (operands[2])), operands[2]));
+  else
+    {
+      rtx subshift = gen_reg_rtx (DImode);
+      emit_insn (gen_zero_extendsidi2 (subtarget, operands[1]));
+      emit_insn (gen_zero_extendsidi2 (subshift, operands[2]));
+      emit_insn (gen_lshrdi3 (subtarget, subtarget, subshift));
+    }
+  emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);
+  DONE;
+}")
 
 ;; Use mix4.r/shr to implement rotrsi3.  We only get 32 bits of valid result
 ;; here, instead of 64 like the patterns above.
 
 (define_expand "rotrsi3"
   [(set (match_dup 3)
-	(ior:DI (zero_extend:DI (match_operand:SI 1 "register_operand" ""))
+	(ior:DI (zero_extend:DI (match_operand:SI 1 "gr_register_operand" ""))
 		(ashift:DI (zero_extend:DI (match_dup 1)) (const_int 32))))
    (set (match_dup 3)
 	(lshiftrt:DI (match_dup 3)
 		     (match_operand:DI 2 "nonmemory_operand" "")))
-   (set (match_operand:SI 0 "register_operand" "") (match_dup 4))]
+   (set (match_operand:SI 0 "gr_register_operand" "") (match_dup 4))]
   ""
   "
 {
   if (! shift_32bit_count_operand (operands[2], SImode))
     FAIL;
-
   operands[3] = gen_reg_rtx (DImode);
   operands[4] = gen_lowpart (SImode, operands[3]);
 }")
-
 
 ;; ::::::::::::::::::::
 ;; ::
@@ -1865,20 +2139,22 @@
 ;; ::::::::::::::::::::
 
 (define_insn "ashldi3"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(ashift:DI (match_operand:DI 1 "register_operand" "r")
-		   (match_operand:DI 2 "reg_or_6bit_operand" "rM")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
+	(ashift:DI (match_operand:DI 1 "gr_register_operand" "r,r")
+		   (match_operand:DI 2 "gr_reg_or_6bit_operand" "R,rM")))]
   ""
-  "shl %0 = %1, %2"
-  [(set_attr "type" "I")])
+  "@
+   shladd %0 = %1, %2, r0
+   shl %0 = %1, %2"
+  [(set_attr "type" "A,I")])
 
 ;; ??? Maybe combine this with the multiply and add instruction?
 
 (define_insn "*shladd"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (mult:DI (match_operand:DI 1 "register_operand" "r")
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(plus:DI (mult:DI (match_operand:DI 1 "gr_register_operand" "r")
 			  (match_operand:DI 2 "shladd_operand" "n"))
-		 (match_operand:DI 3 "register_operand" "r")))]
+		 (match_operand:DI 3 "gr_register_operand" "r")))]
   ""
   "shladd %0 = %1, %S2, %3"
   [(set_attr "type" "A")])
@@ -1892,8 +2168,8 @@
 ;; incorrectly.
 
 (define_insn_and_split "*shladd_elim"
-  [(set (match_operand:DI 0 "register_operand" "=&r")
-	(plus:DI (plus:DI (mult:DI (match_operand:DI 1 "register_operand" "r")
+  [(set (match_operand:DI 0 "gr_register_operand" "=&r")
+	(plus:DI (plus:DI (mult:DI (match_operand:DI 1 "gr_register_operand" "r")
 				   (match_operand:DI 2 "shladd_operand" "n"))
 			  (match_operand:DI 3 "nonmemory_operand" "r"))
 		 (match_operand:DI 4 "nonmemory_operand" "rI")))]
@@ -1907,17 +2183,17 @@
   [(set_attr "type" "unknown")])
 
 (define_insn "ashrdi3"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(ashiftrt:DI (match_operand:DI 1 "register_operand" "r")
-		     (match_operand:DI 2 "reg_or_6bit_operand" "rM")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(ashiftrt:DI (match_operand:DI 1 "gr_register_operand" "r")
+		     (match_operand:DI 2 "gr_reg_or_6bit_operand" "rM")))]
   ""
   "shr %0 = %1, %2"
   [(set_attr "type" "I")])
 
 (define_insn "lshrdi3"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(lshiftrt:DI (match_operand:DI 1 "register_operand" "r")
-		     (match_operand:DI 2 "reg_or_6bit_operand" "rM")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(lshiftrt:DI (match_operand:DI 1 "gr_register_operand" "r")
+		     (match_operand:DI 2 "gr_reg_or_6bit_operand" "rM")))]
   ""
   "shr.u %0 = %1, %2"
   [(set_attr "type" "I")])
@@ -1928,8 +2204,8 @@
 ;; verify that we have an appropriate constant in the expander.
 
 (define_expand "rotrdi3"
-  [(set (match_operand:DI 0 "register_operand" "")
-	(rotatert:DI (match_operand:DI 1 "register_operand" "")
+  [(set (match_operand:DI 0 "gr_register_operand" "")
+	(rotatert:DI (match_operand:DI 1 "gr_register_operand" "")
 		     (match_operand:DI 2 "nonmemory_operand" "")))]
   ""
   "
@@ -1939,8 +2215,8 @@
 }")
 
 (define_insn "*rotrdi3_internal"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(rotatert:DI (match_operand:DI 1 "register_operand" "r")
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(rotatert:DI (match_operand:DI 1 "gr_register_operand" "r")
 		     (match_operand:DI 2 "shift_count_operand" "M")))]
   ""
   "shrp %0 = %1, %1, %2"
@@ -1949,7 +2225,7 @@
 
 ;; ::::::::::::::::::::
 ;; ::
-;; :: 32 Bit Integer Logical operations
+;; :: 32 bit Integer Logical operations
 ;; ::
 ;; ::::::::::::::::::::
 
@@ -1967,46 +2243,23 @@
 ;; Or maybe fix this by adding andsi3/iorsi3/xorsi3 patterns like the
 ;; one_cmplsi2 pattern.
 
-(define_expand "one_cmplsi2"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(not:SI (match_operand:SI 1 "register_operand" "")))]
-  ""
-  "
-{
-  if (optimize)
-    {
-      rtx op1 = gen_lowpart (DImode, operands[1]);
-
-      if (! cse_not_expected)
-	{
-	  rtx tmp = gen_reg_rtx (DImode);
-	  emit_insn (gen_one_cmpldi2 (tmp, op1));
-	  emit_move_insn (operands[0], gen_lowpart (SImode, tmp));
-	}
-      else
-	emit_insn (gen_one_cmpldi2 (gen_lowpart (DImode, operands[0]), op1));
-      DONE;
-    }
-}")
-
-(define_insn "*one_cmplsi2_internal"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(not:SI (match_operand:SI 1 "register_operand" "r")))]
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(not:SI (match_operand:SI 1 "gr_register_operand" "r")))]
   ""
   "andcm %0 = -1, %1"
   [(set_attr "type" "A")])
-
 
 ;; ::::::::::::::::::::
 ;; ::
-;; :: 64 Bit Integer Logical operations
+;; :: 64 bit Integer Logical operations
 ;; ::
 ;; ::::::::::::::::::::
 
 (define_insn "anddi3"
-  [(set (match_operand:DI 0 "register_operand" "=r,*f")
-	(and:DI (match_operand:DI 1 "register_operand" "%r,*f")
-		(match_operand:DI 2 "reg_or_8bit_operand" "rK,*f")))]
+  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
+	(and:DI (match_operand:DI 1 "grfr_register_operand" "%r,*f")
+		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
   ""
   "@
    and %0 = %2, %1
@@ -2014,9 +2267,9 @@
   [(set_attr "type" "A,F")])
 
 (define_insn "*andnot"
-  [(set (match_operand:DI 0 "register_operand" "=r,*f")
-	(and:DI (not:DI (match_operand:DI 1 "register_operand" "r,*f"))
-		(match_operand:DI 2 "reg_or_8bit_operand" "rK,*f")))]
+  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
+	(and:DI (not:DI (match_operand:DI 1 "grfr_register_operand" "r,*f"))
+		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
   ""
   "@
    andcm %0 = %2, %1
@@ -2024,9 +2277,9 @@
   [(set_attr "type" "A,F")])
 
 (define_insn "iordi3"
-  [(set (match_operand:DI 0 "register_operand" "=r,*f")
-	(ior:DI (match_operand:DI 1 "register_operand" "%r,*f")
-		(match_operand:DI 2 "reg_or_8bit_operand" "rK,*f")))]
+  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
+	(ior:DI (match_operand:DI 1 "grfr_register_operand" "%r,*f")
+		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
   ""
   "@
    or %0 = %2, %1
@@ -2034,9 +2287,9 @@
   [(set_attr "type" "A,F")])
 
 (define_insn "xordi3"
-  [(set (match_operand:DI 0 "register_operand" "=r,*f")
-	(xor:DI (match_operand:DI 1 "register_operand" "%r,*f")
-		(match_operand:DI 2 "reg_or_8bit_operand" "rK,*f")))]
+  [(set (match_operand:DI 0 "grfr_register_operand" "=r,*f")
+	(xor:DI (match_operand:DI 1 "grfr_register_operand" "%r,*f")
+		(match_operand:DI 2 "grfr_reg_or_8bit_operand" "rK,*f")))]
   ""
   "@
    xor %0 = %2, %1
@@ -2044,8 +2297,8 @@
   [(set_attr "type" "A,F")])
 
 (define_insn "one_cmpldi2"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(not:DI (match_operand:DI 1 "register_operand" "r")))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(not:DI (match_operand:DI 1 "gr_register_operand" "r")))]
   ""
   "andcm %0 = -1, %1"
   [(set_attr "type" "A")])
@@ -2058,8 +2311,8 @@
 
 (define_expand "cmpsi"
   [(set (cc0)
-        (compare (match_operand:SI 0 "register_operand" "")
-  		 (match_operand:SI 1 "reg_or_8bit_and_adjusted_operand" "")))]
+        (compare (match_operand:SI 0 "gr_register_operand" "")
+  		 (match_operand:SI 1 "gr_reg_or_8bit_and_adjusted_operand" "")))]
   ""
   "
 {
@@ -2070,8 +2323,8 @@
 
 (define_expand "cmpdi"
   [(set (cc0)
-        (compare (match_operand:DI 0 "register_operand" "")
-  		 (match_operand:DI 1 "reg_or_8bit_and_adjusted_operand" "")))]
+        (compare (match_operand:DI 0 "gr_register_operand" "")
+  		 (match_operand:DI 1 "gr_reg_or_8bit_and_adjusted_operand" "")))]
   ""
   "
 {
@@ -2082,8 +2335,8 @@
 
 (define_expand "cmpsf"
   [(set (cc0)
-        (compare (match_operand:SF 0 "reg_or_fp01_operand" "")
-  		 (match_operand:SF 1 "reg_or_fp01_operand" "")))]
+        (compare (match_operand:SF 0 "fr_reg_or_fp01_operand" "")
+  		 (match_operand:SF 1 "fr_reg_or_fp01_operand" "")))]
   ""
   "
 {
@@ -2094,8 +2347,8 @@
 
 (define_expand "cmpdf"
   [(set (cc0)
-        (compare (match_operand:DF 0 "reg_or_fp01_operand" "")
-  		 (match_operand:DF 1 "reg_or_fp01_operand" "")))]
+        (compare (match_operand:DF 0 "fr_reg_or_fp01_operand" "")
+  		 (match_operand:DF 1 "fr_reg_or_fp01_operand" "")))]
   ""
   "
 {
@@ -2104,13 +2357,11 @@
   DONE;
 }")
 
-;; ??? Enable this for XFmode support.
-
-(define_expand "cmpxf"
+(define_expand "cmptf"
   [(set (cc0)
-        (compare (match_operand:XF 0 "reg_or_fp01_operand" "")
-  		 (match_operand:XF 1 "reg_or_fp01_operand" "")))]
-  "0"
+        (compare (match_operand:TF 0 "tfreg_or_fp01_operand" "")
+  		 (match_operand:TF 1 "tfreg_or_fp01_operand" "")))]
+  ""
   "
 {
   ia64_compare_op0 = operands[0];
@@ -2121,46 +2372,50 @@
 (define_insn "*cmpsi_normal"
   [(set (match_operand:CC 0 "register_operand" "=c")
 	(match_operator:CC 1 "normal_comparison_operator"
-			   [(match_operand:SI 2 "register_operand" "r")
-			    (match_operand:SI 3 "reg_or_8bit_operand" "rK")]))]
+	   [(match_operand:SI 2 "gr_register_operand" "r")
+	    (match_operand:SI 3 "gr_reg_or_8bit_operand" "rK")]))]
   ""
   "cmp4.%C1 %0, %I0 = %3, %2"
   [(set_attr "type" "A")])
 
+;; We use %r3 because it is possible for us to match a 0, and two of the
+;; unsigned comparisons don't accept immediate operands of zero.
+
 (define_insn "*cmpsi_adjusted"
   [(set (match_operand:CC 0 "register_operand" "=c")
 	(match_operator:CC 1 "adjusted_comparison_operator"
-			   [(match_operand:SI 2 "register_operand" "r")
-			    (match_operand:SI 3 "reg_or_8bit_adjusted_operand"
-					      "rL")]))]
+	   [(match_operand:SI 2 "gr_register_operand" "r")
+	    (match_operand:SI 3 "gr_reg_or_8bit_adjusted_operand" "rL")]))]
   ""
-  "cmp4.%C1 %0, %I0 = %3, %2"
+  "cmp4.%C1 %0, %I0 = %r3, %2"
   [(set_attr "type" "A")])
 
 (define_insn "*cmpdi_normal"
   [(set (match_operand:CC 0 "register_operand" "=c")
 	(match_operator:CC 1 "normal_comparison_operator"
-			   [(match_operand:DI 2 "register_operand" "r")
-			    (match_operand:DI 3 "reg_or_8bit_operand" "rK")]))]
+	   [(match_operand:DI 2 "gr_register_operand" "r")
+	    (match_operand:DI 3 "gr_reg_or_8bit_operand" "rK")]))]
   ""
   "cmp.%C1 %0, %I0 = %3, %2"
   [(set_attr "type" "A")])
 
+;; We use %r3 because it is possible for us to match a 0, and two of the
+;; unsigned comparisons don't accept immediate operands of zero.
+
 (define_insn "*cmpdi_adjusted"
   [(set (match_operand:CC 0 "register_operand" "=c")
 	(match_operator:CC 1 "adjusted_comparison_operator"
-			   [(match_operand:DI 2 "register_operand" "r")
-			    (match_operand:DI 3 "reg_or_8bit_adjusted_operand"
-					      "rL")]))]
+	   [(match_operand:DI 2 "gr_register_operand" "r")
+	    (match_operand:DI 3 "gr_reg_or_8bit_adjusted_operand" "rL")]))]
   ""
-  "cmp.%C1 %0, %I0 = %3, %2"
+  "cmp.%C1 %0, %I0 = %r3, %2"
   [(set_attr "type" "A")])
 
 (define_insn "*cmpsf_internal"
   [(set (match_operand:CC 0 "register_operand" "=c")
 	(match_operator:CC 1 "comparison_operator"
-			   [(match_operand:SF 2 "reg_or_fp01_operand" "fG")
-			    (match_operand:SF 3 "reg_or_fp01_operand" "fG")]))]
+	   [(match_operand:SF 2 "fr_reg_or_fp01_operand" "fG")
+	    (match_operand:SF 3 "fr_reg_or_fp01_operand" "fG")]))]
   ""
   "fcmp.%D1 %0, %I0 = %F2, %F3"
   [(set_attr "type" "F")])
@@ -2168,8 +2423,17 @@
 (define_insn "*cmpdf_internal"
   [(set (match_operand:CC 0 "register_operand" "=c")
 	(match_operator:CC 1 "comparison_operator"
-			   [(match_operand:DF 2 "reg_or_fp01_operand" "fG")
-			    (match_operand:DF 3 "reg_or_fp01_operand" "fG")]))]
+	   [(match_operand:DF 2 "fr_reg_or_fp01_operand" "fG")
+	    (match_operand:DF 3 "fr_reg_or_fp01_operand" "fG")]))]
+  ""
+  "fcmp.%D1 %0, %I0 = %F2, %F3"
+  [(set_attr "type" "F")])
+
+(define_insn "*cmptf_internal"
+  [(set (match_operand:CC 0 "register_operand" "=c")
+	(match_operator:CC 1 "comparison_operator"
+		   [(match_operand:TF 2 "tfreg_or_fp01_operand" "fG")
+		    (match_operand:TF 3 "tfreg_or_fp01_operand" "fG")]))]
   ""
   "fcmp.%D1 %0, %I0 = %F2, %F3"
   [(set_attr "type" "F")])
@@ -2178,7 +2442,7 @@
 
 (define_insn "*bit_zero"
   [(set (match_operand:CC 0 "register_operand" "=c")
-	(eq:CC (zero_extract:DI (match_operand:DI 1 "register_operand" "r")
+	(eq:CC (zero_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
 				(const_int 1)
 				(match_operand:DI 2 "immediate_operand" "n"))
 	       (const_int 0)))]
@@ -2188,7 +2452,7 @@
 
 (define_insn "*bit_one"
   [(set (match_operand:CC 0 "register_operand" "=c")
-	(ne:CC (zero_extract:DI (match_operand:DI 1 "register_operand" "r")
+	(ne:CC (zero_extract:DI (match_operand:DI 1 "gr_register_operand" "r")
 				(const_int 1)
 				(match_operand:DI 2 "immediate_operand" "n"))
 	       (const_int 0)))]
@@ -2527,7 +2791,7 @@
   [(set (match_dup 1)
 	(eq:CC (match_dup 2)
 	       (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2541,7 +2805,7 @@
   [(set (match_dup 1)
 	(ne:CC (match_dup 2)
 	       (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2555,7 +2819,7 @@
   [(set (match_dup 1)
 	(lt:CC (match_dup 2)
 	       (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2569,7 +2833,7 @@
   [(set (match_dup 1)
 	(le:CC (match_dup 2)
 	       (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2583,7 +2847,7 @@
   [(set (match_dup 1)
 	(gt:CC (match_dup 2)
 	       (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2597,7 +2861,7 @@
   [(set (match_dup 1)
 	(ge:CC (match_dup 2)
 	       (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2611,7 +2875,7 @@
   [(set (match_dup 1)
 	(ltu:CC (match_dup 2)
 		(match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2625,7 +2889,7 @@
   [(set (match_dup 1)
 	(leu:CC (match_dup 2)
 		(match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2639,7 +2903,7 @@
   [(set (match_dup 1)
 	(gtu:CC (match_dup 2)
 		(match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2653,7 +2917,7 @@
   [(set (match_dup 1)
 	(geu:CC (match_dup 2)
 		(match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2667,7 +2931,7 @@
   [(set (match_dup 1)
 	(unordered:CC (match_dup 2)
 		      (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2681,7 +2945,7 @@
   [(set (match_dup 1)
 	(ordered:CC (match_dup 2)
 		      (match_dup 3)))
-   (set (match_operand:DI 0 "register_operand" "")
+   (set (match_operand:DI 0 "gr_register_operand" "")
 	(ne:DI (match_dup 1) (const_int 0)))]
   ""
   "
@@ -2694,18 +2958,12 @@
 ;; Don't allow memory as destination here, because cmov/cmov/st is more
 ;; efficient than mov/mov/cst/cst.
 
-(define_insn "*sne_internal"
-  [(set (match_operand:DI 0 "register_operand" "=r")
+(define_insn_and_split "*sne_internal"
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
 	(ne:DI (match_operand:CC 1 "register_operand" "c")
 	       (const_int 0)))]
   ""
   "#"
-  [(set_attr "type" "unknown")])
-
-(define_split
-  [(set (match_operand:DI 0 "register_operand" "")
-	(ne:DI (match_operand:CC 1 "register_operand" "")
-	       (const_int 0)))]
   "reload_completed"
   [(set (match_dup 0)
 	(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))
@@ -2715,24 +2973,17 @@
 	(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))
 			 (match_dup 0)
 			 (const_int 0)))]
-  "")
+  ""
+  [(set_attr "type" "unknown")])
 
 ;; ??? Unknown if this can be matched.
 
-(define_insn "*seq_internal"
-  [(set (match_operand:DI 0 "register_operand" "=r")
+(define_insn_and_split "*seq_internal"
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
 	(eq:DI (match_operand:CC 1 "register_operand" "c")
 	       (const_int 0)))]
   ""
   "#"
-  [(set_attr "type" "unknown")])
-
-;; ??? Unknown if this can be matched.
-
-(define_split
-  [(set (match_operand:DI 0 "register_operand" "")
-	(eq:DI (match_operand:CC 1 "register_operand" "")
-	       (const_int 0)))]
   "reload_completed"
   [(set (match_dup 0)
 	(if_then_else:DI (eq:CC (match_dup 1) (const_int 0))
@@ -2742,7 +2993,8 @@
 	(if_then_else:DI (eq:CC (match_dup 1) (const_int 0))
 			 (match_dup 0)
 			 (const_int 0)))]
-  "")
+  ""
+  [(set_attr "type" "unknown")])
 
 
 ;; ::::::::::::::::::::
@@ -2760,16 +3012,16 @@
 ;; Errata 72 workaround.
 (define_insn "*cmovdi_internal_astep"
   [(set (match_operand:DI 0 "nonimmediate_operand"
-		"=r,*f,Q,*b*d*e,r,*f,Q,*b*d*e,r,*f,Q,*b*d*e")
+		"=r,*f,Q,*b,r,*f,Q,*b,r,*f,Q,*b")
 	(if_then_else:DI
 	  (match_operator:CC 4 "predicate_operator"
 	    [(match_operand:CC 1 "register_operand"
 			       "c,c,c,c,c,c,c,c,c,c,c,c")
 	     (const_int 0)])
 	  (match_operand:DI 2 "general_operand"
-		"0,0,0,0,ri*f*b*d*e,rO,*f,r,ri*f*b*d*e,rO,*f,r")
+		"0,0,0,0,ri*f*b,rO,*f,r,ri*f*b,rO,*f,r")
 	  (match_operand:DI 3 "general_operand"
-		"ri*f*b*d*e,rO,*f,r,0,0,0,0,ri*f*b*d*e,rO,*f,r")))]
+		"ri*f*b,rO,*f,r,0,0,0,0,ri*f*b,rO,*f,r")))]
   "TARGET_A_STEP"
   "* abort ();"
   [(set_attr "predicable" "no")])
@@ -2824,13 +3076,13 @@
 ;; Absolute value pattern.
 
 (define_insn "*absdi2_internal"
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
+  [(set (match_operand:DI 0 "gr_register_operand" "=r,r")
 	(if_then_else:DI
 	  (match_operator:CC 4 "predicate_operator"
 	    [(match_operand:CC 1 "register_operand" "c,c")
 	     (const_int 0)])
-	  (neg:DI (match_operand:DI 2 "reg_or_22bit_operand" "rI,rI"))
-	  (match_operand:DI 3 "reg_or_22bit_operand" "0,rI")))]
+	  (neg:DI (match_operand:DI 2 "gr_reg_or_22bit_operand" "rI,rI"))
+	  (match_operand:DI 3 "gr_reg_or_22bit_operand" "0,rI")))]
   ""
   "#"
   [(set_attr "type" "A,unknown")
@@ -2842,8 +3094,8 @@
 	  (match_operator:CC 4 "predicate_operator"
 	    [(match_operand:CC 1 "register_operand" "c,c")
 	     (const_int 0)])
-	  (neg:DI (match_operand:DI 2 "reg_or_22bit_operand" ""))
-	  (match_operand:DI 3 "reg_or_22bit_operand" "")))]
+	  (neg:DI (match_operand:DI 2 "gr_reg_or_22bit_operand" ""))
+	  (match_operand:DI 3 "gr_reg_or_22bit_operand" "")))]
   "reload_completed && rtx_equal_p (operands[0], operands[3])"
   [(cond_exec
      (match_dup 4)
@@ -2857,8 +3109,8 @@
 	  (match_operator:CC 4 "predicate_operator"
 	    [(match_operand:CC 1 "register_operand" "c,c")
 	     (const_int 0)])
-	  (neg:DI (match_operand:DI 2 "reg_or_22bit_operand" ""))
-	  (match_operand:DI 3 "reg_or_22bit_operand" "")))]
+	  (neg:DI (match_operand:DI 2 "gr_reg_or_22bit_operand" ""))
+	  (match_operand:DI 3 "gr_reg_or_22bit_operand" "")))]
   "reload_completed"
   [(cond_exec
      (match_dup 4)
@@ -2905,13 +3157,13 @@
   [(set_attr "predicable" "no")])
 
 (define_insn "*abssi2_internal"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
+  [(set (match_operand:SI 0 "gr_register_operand" "=r,r")
 	(if_then_else:SI
 	  (match_operator:CC 4 "predicate_operator"
 	    [(match_operand:CC 1 "register_operand" "c,c")
 	     (const_int 0)])
-	  (neg:SI (match_operand:SI 3 "reg_or_22bit_operand" "rI,rI"))
-	  (match_operand:SI 2 "reg_or_22bit_operand" "0,rI")))]
+	  (neg:SI (match_operand:SI 3 "gr_reg_or_22bit_operand" "rI,rI"))
+	  (match_operand:SI 2 "gr_reg_or_22bit_operand" "0,rI")))]
   ""
   "#"
   [(set_attr "type" "A,unknown")
@@ -2923,8 +3175,8 @@
 	  (match_operator:CC 4 "predicate_operator"
 	    [(match_operand:CC 1 "register_operand" "c,c")
 	     (const_int 0)])
-	  (neg:SI (match_operand:SI 2 "reg_or_22bit_operand" ""))
-	  (match_operand:SI 3 "reg_or_22bit_operand" "")))]
+	  (neg:SI (match_operand:SI 2 "gr_reg_or_22bit_operand" ""))
+	  (match_operand:SI 3 "gr_reg_or_22bit_operand" "")))]
   "reload_completed && rtx_equal_p (operands[0], operands[3])"
   [(cond_exec
      (match_dup 4)
@@ -2938,8 +3190,8 @@
 	  (match_operator:CC 4 "predicate_operator"
 	    [(match_operand:CC 1 "register_operand" "c,c")
 	     (const_int 0)])
-	  (neg:SI (match_operand:SI 2 "reg_or_22bit_operand" ""))
-	  (match_operand:SI 3 "reg_or_22bit_operand" "")))]
+	  (neg:SI (match_operand:SI 2 "gr_reg_or_22bit_operand" ""))
+	  (match_operand:SI 3 "gr_reg_or_22bit_operand" "")))]
   "reload_completed"
   [(cond_exec
      (match_dup 4)
@@ -2992,9 +3244,6 @@
   else if (TARGET_CONST_GP)
     emit_call_insn (gen_call_internal (addr, operands[1],
 				       gen_rtx_REG (DImode, R_BR (0))));
-  /* ??? This is an unsatisfying solution.  Should rethink.  */
-  else if (setjmp_operand (addr, mode))
-    emit_insn (gen_setjmp_call_pic (addr, operands[1]));
   else
     emit_insn (gen_call_pic (addr, operands[1]));
 
@@ -3013,32 +3262,11 @@
   ""
   "
 {
-  operands[2] = gen_reg_rtx (DImode);
+  operands[2] = ia64_gp_save_reg (0);
   operands[3] = gen_reg_rtx (DImode);
   operands[4] = gen_reg_rtx (DImode);
 }")
 
-;; We can't save GP in a pseudo if we are calling setjmp, because pseudos
-;; won't be restored by longjmp.  For now, we save it in r4.
-
-;; ??? It would be more efficient to save this directly into a stack slot.
-;; Unfortunately, the stack slot address gets cse'd across the setjmp call
-;; because the NOTE_INSN_SETJMP note is in the wrong place.
-
-;; ??? This is an unsatisfying solution.  Should rethink.
-
-(define_expand "setjmp_call_pic"
-  [(set (match_dup 2) (reg:DI 1))
-   (parallel [(call (mem:DI (match_operand 0 "" "")) (match_operand 1 "" ""))
-	      (use (reg:DI 1))
-	      (clobber (reg:DI 320))])
-   (set (reg:DI 1) (match_dup 2))]
-  ""
-  "
-{
-  operands[2] = gen_rtx_REG (DImode, GR_REG (4));
-}")
-
 ;; ??? Saving/restoring the GP register is not needed if we are calling
 ;; a function in the same module.
 
@@ -3051,7 +3279,9 @@
   ""
   "
 {
-  operands[2] = gen_reg_rtx (DImode);
+  /* ??? Using setjmp_operand is an unsatisfying solution.  Should rethink.  */
+  operands[2] = ia64_gp_save_reg (setjmp_operand (XEXP (operands[0], 0),
+						  VOIDmode));
 }")
 
 (define_insn "call_internal"
@@ -3109,9 +3339,6 @@
   else if (TARGET_CONST_GP)
     emit_call_insn (gen_call_value_internal (operands[0], addr, operands[2],
 					     gen_rtx_REG (DImode, R_BR (0))));
-  /* ??? This is an unsatisfying solution.  Should rethink.  */
-  else if (setjmp_operand (addr, mode))
-    emit_insn (gen_setjmp_call_value_pic (operands[0], addr, operands[2]));
   /* This is for HFA returns.  */
   else if (GET_CODE (operands[0]) == PARALLEL)
     emit_insn (gen_call_multiple_values_pic (operands[0], addr, operands[2]));
@@ -3134,7 +3361,7 @@
   ""
   "
 {
-  operands[3] = gen_reg_rtx (DImode);
+  operands[3] = ia64_gp_save_reg (0);
   operands[4] = gen_reg_rtx (DImode);
   operands[5] = gen_reg_rtx (DImode);
 }")
@@ -3157,7 +3384,7 @@
   int i;
   rtx call;
 
-  operands[3] = gen_reg_rtx (DImode);
+  operands[3] = ia64_gp_save_reg (0);
   operands[4] = gen_reg_rtx (DImode);
   operands[5] = gen_reg_rtx (DImode);
 
@@ -3183,29 +3410,6 @@
 
 }")
 
-;; We can't save GP in a pseudo if we are calling setjmp, because pseudos
-;; won't be restored by longjmp.  For now, we save it in r4.
-
-;; ??? It would be more efficient to save this directly into a stack slot.
-;; Unfortunately, the stack slot address gets cse'd across the setjmp call
-;; because the NOTE_INSN_SETJMP note is in the wrong place.
-
-;; ??? This is an unsatisfying solution.  Should rethink.
-
-(define_expand "setjmp_call_value_pic"
-  [(set (match_dup 3) (reg:DI 1))
-   (parallel [(set (match_operand 0 "" "")
-		   (call (mem:DI (match_operand 1 "" ""))
-			 (match_operand 2 "" "")))
-	      (use (reg:DI 1))
-	      (clobber (reg:DI 320))])
-   (set (reg:DI 1) (match_dup 3))]
-  ""
-  "
-{
-  operands[3] = gen_rtx_REG (DImode, GR_REG (4));
-}")
-
 ;; ??? Saving/restoring the GP register is not needed if we are calling
 ;; a function in the same module.
 
@@ -3220,7 +3424,9 @@
   ""
   "
 {
-  operands[3] = gen_reg_rtx (DImode);
+  /* ??? Using setjmp_operand is an unsatisfying solution.  Should rethink.  */
+  operands[3] = ia64_gp_save_reg (setjmp_operand (XEXP (operands[1], 0),
+						  VOIDmode));
 }")
 
 ;; ??? Saving/restoring the GP register is not needed if we are calling
@@ -3241,7 +3447,7 @@
   int i;
   rtx call;
 
-  operands[4] = gen_reg_rtx (DImode);
+  operands[4] = ia64_gp_save_reg (0);
 
   call = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (DImode, operands[1]),
 		       operands[2]);
@@ -3423,7 +3629,7 @@
 (define_insn "prologue_allocate_stack"
   [(set (match_operand:DI 0 "register_operand" "=r,r,r")
 	(plus:DI (match_operand:DI 1 "register_operand" "%r,r,a")
-		 (match_operand:DI 2 "reg_or_22bit_operand" "r,I,J")))
+		 (match_operand:DI 2 "gr_reg_or_22bit_operand" "r,I,J")))
    (set (match_operand:DI 3 "register_operand" "=r,r,r")
 	(match_dup 3))]
   ""
@@ -3458,75 +3664,56 @@
   [(set_attr "type" "M")
    (set_attr "predicable" "no")])
 
-(define_insn "gr_spill"
+;; Modifies ar.unat
+(define_expand "gr_spill"
+  [(parallel [(set (match_operand:DI 0 "memory_operand" "=m")
+		   (unspec:DI [(match_operand:DI 1 "register_operand" "r")
+			       (match_operand:DI 2 "const_int_operand" "")] 1))
+	      (clobber (match_dup 3))])]
+  ""
+  "operands[3] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);")
+
+(define_insn "gr_spill_internal"
   [(set (match_operand:DI 0 "memory_operand" "=m")
-	(unspec:DI [(match_operand:DI 1 "register_operand" "r")] 1))]
+	(unspec:DI [(match_operand:DI 1 "register_operand" "r")
+		    (match_operand:DI 2 "const_int_operand" "")] 1))
+   (clobber (match_operand:DI 3 "register_operand" ""))]
   ""
-  "st8.spill %0 = %1%P0"
+  ".mem.offset %2, 0\;st8.spill %0 = %1%P0"
   [(set_attr "type" "M")])
 
-(define_insn "gr_restore"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec:DI [(match_operand:DI 1 "memory_operand" "m")] 2))]
+;; Reads ar.unat
+(define_expand "gr_restore"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "=r")
+		   (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
+			       (match_operand:DI 2 "const_int_operand" "")] 2))
+	      (use (match_dup 3))])]
+  ""
+  "operands[3] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);")
+
+(define_insn "gr_restore_internal"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec:DI [(match_operand:DI 1 "memory_operand" "m")
+		    (match_operand:DI 2 "const_int_operand" "")] 2))
+   (use (match_operand:DI 3 "register_operand" ""))]
   ""
-  "ld8.fill %0 = %1%P1"
+  ".mem.offset %2, 0\;ld8.fill %0 = %1%P1"
   [(set_attr "type" "M")])
 
 (define_insn "fr_spill"
-  [(set (match_operand:XF 0 "memory_operand" "=m")
-	(unspec:XF [(match_operand:XF 1 "register_operand" "f")] 3))]
+  [(set (match_operand:TF 0 "memory_operand" "=m")
+	(unspec:TF [(match_operand:TF 1 "register_operand" "f")] 3))]
   ""
   "stf.spill %0 = %1%P0"
   [(set_attr "type" "M")])
 
 (define_insn "fr_restore"
-  [(set (match_operand:XF 0 "register_operand" "=f")
-	(unspec:XF [(match_operand:XF 1 "memory_operand" "m")] 4))]
+  [(set (match_operand:TF 0 "register_operand" "=f")
+	(unspec:TF [(match_operand:TF 1 "memory_operand" "m")] 4))]
   ""
   "ldf.fill %0 = %1%P1"
   [(set_attr "type" "M")])
 
-(define_insn "pr_spill"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec:DI [(const_int 0)] 5))]
-  ""
-  "mov %0 = pr"
-  [(set_attr "type" "I")])
-
-;; ??? This is volatile to prevent it from being moved before a conditional
-;; expression that calculates the return value.
-
-(define_insn "pr_restore"
-  [(unspec_volatile [(const_int 0)] 6)
-   (use (match_operand:DI 0 "register_operand" "r"))]
-  ""
-  "mov pr = %0, -1"
-  [(set_attr "type" "I")])
-
-;; ??? This is volatile to prevent it from being moved before a call.
-;; Should instead add a ar.pfs hard register which is call clobbered.
-
-(define_insn "pfs_restore"
-  [(unspec_volatile [(const_int 0)] 4)
-   (use (match_operand:DI 0 "register_operand" "r"))]
-  ""
-  "mov ar.pfs = %0"
-  [(set_attr "type" "I")])
-
-(define_insn "unat_spill"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(unspec:DI [(const_int 0)] 9))]
-  ""
-  "mov %0 = ar.unat"
-  [(set_attr "type" "M")])
-
-(define_insn "unat_restore"
-  [(unspec [(const_int 0)] 10)
-   (use (match_operand:DI 0 "register_operand" "r"))]
-  ""
-  "mov ar.unat = %0"
-  [(set_attr "type" "M")])
-
 (define_insn "bsp_value"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(unspec:DI [(const_int 0)] 20))]
@@ -3604,31 +3791,39 @@
   ""
   "
 {
-  if (GET_CODE (operands[0]) != REG)
-    operands[0] = force_reg (Pmode, operands[0]);
-  emit_move_insn (virtual_stack_vars_rtx, operands[0]);
-  emit_insn (gen_rtx_USE (VOIDmode, frame_pointer_rtx));
-  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));
-  emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));
   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__ia64_nonlocal_goto\"),
-		     0, VOIDmode, 4,
-		     operands[0], Pmode, operands[1], Pmode,
+		     0, VOIDmode, 3,
+		     operands[1], Pmode,
 		     copy_to_reg (XEXP (operands[2], 0)), Pmode,
 		     operands[3], Pmode);
   emit_barrier ();
   DONE;
 }")
 
-;; ??? We need this because the function __ia64_nonlocal_goto can't easily
-;; access the FP which is currently stored in a local register.  Maybe move
-;; the FP to a global register to avoid this problem?
+;; Restore the GP after the exception/longjmp.  The preceeding call will
+;; have tucked it away.
+(define_expand "exception_receiver"
+  [(set (reg:DI 1) (match_dup 0))]
+  ""
+  "operands[0] = ia64_gp_save_reg (0);")
+
+;; The rest of the setjmp processing happens with the nonlocal_goto expander.
+;; ??? This is not tested.
+(define_expand "builtin_setjmp_setup"
+  [(use (match_operand:DI 0 "" ""))]
+  ""
+  "
+{
+  emit_move_insn (ia64_gp_save_reg (0), gen_rtx_REG (DImode, GR_REG (1)));
+  DONE;
+}")
 
-(define_expand "nonlocal_goto_receiver"
-  [(use (const_int 0))]
+(define_expand "builtin_setjmp_receiver"
+  [(use (match_operand:DI 0 "" ""))]
   ""
   "
 {
-  emit_move_insn (frame_pointer_rtx, gen_rtx_REG (DImode, GR_REG (7)));
+  emit_move_insn (gen_rtx_REG (DImode, GR_REG (1)), ia64_gp_save_reg (0));
   DONE;
 }")
 
@@ -3657,20 +3852,7 @@
 
   cfun->machine->ia64_eh_epilogue_sp = sp;
   cfun->machine->ia64_eh_epilogue_bsp = bsp;
-
 }")
-
-;; This flushes at least 64 bytes starting from the address pointed
-;; to by operand[0].
-
-;; ??? This should be a define expand.
-
-(define_insn "flush_cache"
-  [(unspec_volatile [(match_operand:DI 0 "register_operand" "=&r")] 3)]
-  ""
-  "fc %0\;;;\;adds %0=31,%0\;;;\;fc %0\;;;\;sync.i\;srlz.i"
-  [(set_attr "type" "unknown")
-   (set_attr "predicable" "no")])
 
 ;; Builtin apply support.
 
@@ -3690,421 +3872,82 @@
 
 ;;; Intrinsics support.
 
-(define_insn "ccv_restore_si"
-  [(unspec [(const_int 0)] 11)
-   (use (match_operand:SI 0 "register_operand" "r"))]
-  ""
-  "mov ar.ccv = %0"
-  [(set_attr "type" "M")])
-
-(define_insn "ccv_restore_di"
-  [(unspec [(const_int 0)] 11)
-   (use (match_operand:DI 0 "register_operand" "r"))]
+(define_expand "mf"
+  [(set (mem:BLK (match_dup 0))
+	(unspec:BLK [(mem:BLK (match_dup 0))] 12))]
   ""
-  "mov ar.ccv = %0"
-  [(set_attr "type" "M")])
+  "
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+}")
 
-(define_insn "mf"
-  [(unspec [(match_operand:BLK 0 "memory_operand" "m")] 12)]
+(define_insn "*mf_internal"
+  [(set (match_operand:BLK 0 "" "")
+	(unspec:BLK [(match_operand:BLK 1 "" "")] 12))]
   ""
   "mf"
   [(set_attr "type" "M")])
 
 (define_insn "fetchadd_acq_si"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "fetchadd_operand" "n")] 19))]
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(match_dup 1))
+   (set (match_operand:SI 1 "not_postinc_memory_operand" "+S")
+	(unspec:SI [(match_dup 1)
+		    (match_operand:SI 2 "fetchadd_operand" "n")] 19))]
   ""
   "fetchadd4.acq %0 = %1, %2"
   [(set_attr "type" "M")])
 
 (define_insn "fetchadd_acq_di"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "fetchadd_operand" "n")] 19))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(match_dup 1))
+   (set (match_operand:DI 1 "not_postinc_memory_operand" "+S")
+	(unspec:DI [(match_dup 1)
+		    (match_operand:DI 2 "fetchadd_operand" "n")] 19))]
   ""
   "fetchadd8.acq %0 = %1, %2"
   [(set_attr "type" "M")])
 
 (define_insn "cmpxchg_acq_si"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 13))]
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+	(match_dup 1))
+   (set (match_operand:SI 1 "not_postinc_memory_operand" "+S")
+        (unspec:SI [(match_dup 1)
+                    (match_operand:SI 2 "gr_register_operand" "r")
+		    (match_operand:SI 3 "ar_ccv_reg_operand" "")] 13))]
   ""
-  "cmpxchg4.acq %0 = %1, %2, ar.ccv"
+  "cmpxchg4.acq %0 = %1, %2, %3"
   [(set_attr "type" "M")])
 
 (define_insn "cmpxchg_acq_di"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 13))]
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+	(match_dup 1))
+   (set (match_operand:DI 1 "not_postinc_memory_operand" "+S")
+        (unspec:DI [(match_dup 1)
+                    (match_operand:DI 2 "gr_register_operand" "r")
+		    (match_operand:DI 3 "ar_ccv_reg_operand" "")] 13))]
   ""
-  "cmpxchg8.acq %0 = %1, %2, ar.ccv"
+  "cmpxchg8.acq %0 = %1, %2, %3"
   [(set_attr "type" "M")])
 
-(define_expand "val_compare_and_swap_si"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")
-                    (match_operand:SI 3 "register_operand" "r")] 14))]
-  ""
-  "
-{
-  rtx tmp_reg = gen_rtx_REG (DImode, GR_REG(0));
-  rtx target = gen_rtx_MEM (BLKmode, tmp_reg);
-  RTX_UNCHANGING_P (target) = 1;
-  emit_insn (gen_ccv_restore_si (operands[2]));
-  emit_insn (gen_mf (target));
-  emit_insn (gen_cmpxchg_acq_si (operands[0], operands[1], operands[3]));
-  DONE;
-}")
-
-(define_expand "val_compare_and_swap_di"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")
-                    (match_operand:DI 3 "register_operand" "r")] 14))]
-  ""
-  "
-{
-  rtx tmp_reg = gen_rtx_REG (DImode, GR_REG(0));
-  rtx target = gen_rtx_MEM (BLKmode, tmp_reg);
-  RTX_UNCHANGING_P (target) = 1;
-  emit_insn (gen_ccv_restore_di (operands[2]));
-  emit_insn (gen_mf (target));
-  emit_insn (gen_cmpxchg_acq_di (operands[0], operands[1], operands[3]));
-  DONE;
-}")
-
 (define_insn "xchgsi"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (match_operand:SI 1 "memory_operand" "+m"))
+  [(set (match_operand:SI 0 "gr_register_operand" "=r")
+        (match_operand:SI 1 "not_postinc_memory_operand" "+S"))
    (set (match_dup 1)
-        (match_operand:SI 2 "register_operand" "r"))]
+        (match_operand:SI 2 "gr_register_operand" "r"))]
   ""
   "xchg4 %0 = %1, %2"
   [(set_attr "type" "M")])
 
 (define_insn "xchgdi"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (match_operand:DI 1 "memory_operand" "+m"))
+  [(set (match_operand:DI 0 "gr_register_operand" "=r")
+        (match_operand:DI 1 "not_postinc_memory_operand" "+S"))
    (set (match_dup 1)
-        (match_operand:DI 2 "register_operand" "r"))]
+        (match_operand:DI 2 "gr_register_operand" "r"))]
   ""
   "xchg8 %0 = %1, %2"
   [(set_attr "type" "M")])
-
-(define_expand "lock_test_and_set_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 16))]
-  ""
-  "
-{
-  emit_insn (gen_xchgsi (operands[0], operands[1], operands[2]));
-  DONE;
-}")
-
-(define_expand "lock_test_and_set_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 16))]
-  ""
-  "
-{
-  emit_insn (gen_xchgdi (operands[0], operands[1], operands[2]));
-  DONE;
-}")
-
-(define_expand "fetch_and_add_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "nonmemory_operand" "")] 18))]
-  ""
-  "
-{
-  int x;
-
-  if (GET_CODE (operands[2]) == CONST_INT)
-    {
-      x = INTVAL(operands[2]);
-      if (x == -16 || x == -8 || x == -4 || x == -1 ||
-          x ==  16 || x ==  8 || x ==  4 || x ==  1)
-        {
-          emit_insn (gen_fetchadd_acq_si (operands[0], operands[1], operands[2]));
-          DONE;
-        }
-    }
-
-  ia64_expand_fetch_and_op (IA64_ADD_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_sub_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_SUB_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_or_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_OR_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_and_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_AND_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_xor_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_XOR_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_nand_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_NAND_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_add_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "nonmemory_operand" "")] 18))]
-  ""
-  "
-{
-  int x;
-
-  if (GET_CODE (operands[2]) == CONST_INT)
-    {
-      x = INTVAL(operands[2]);
-      if (x == -16 || x == -8 || x == -4 || x == -1 ||
-          x ==  16 || x ==  8 || x ==  4 || x ==  1)
-        {
-          emit_insn (gen_fetchadd_acq_di (operands[0], operands[1], operands[2]));
-          DONE;
-        }
-    }
-
-  ia64_expand_fetch_and_op (IA64_ADD_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_sub_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_SUB_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_or_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_OR_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_and_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_AND_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_xor_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_XOR_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "fetch_and_nand_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 18))]
-  ""
-  "
-{
-  ia64_expand_fetch_and_op (IA64_NAND_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "add_and_fetch_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_ADD_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "sub_and_fetch_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_SUB_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "or_and_fetch_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_OR_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "and_and_fetch_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_AND_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "xor_and_fetch_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_XOR_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "nand_and_fetch_di"
-  [(set (match_operand:DI 0 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 1 "memory_operand" "m")
-                    (match_operand:DI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_NAND_OP, DImode, operands);
-  DONE;
-}")
-
-(define_expand "add_and_fetch_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_ADD_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "sub_and_fetch_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_SUB_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "or_and_fetch_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_OR_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "and_and_fetch_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_AND_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "xor_and_fetch_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_XOR_OP, SImode, operands);
-  DONE;
-}")
-
-(define_expand "nand_and_fetch_si"
-  [(set (match_operand:SI 0 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
-                    (match_operand:SI 2 "register_operand" "r")] 17))]
-  ""
-  "
-{
-  ia64_expand_op_and_fetch (IA64_NAND_OP, SImode, operands);
-  DONE;
-}")
 
 ;; Predication.
 
@@ -4121,3 +3964,22 @@
   ".pred.rel.mutex %0, %I0"
   [(set_attr "type" "unknown")
    (set_attr "predicable" "no")])
+
+(define_insn "safe_across_calls_all"
+  [(unspec_volatile [(const_int 0)] 8)]
+  ""
+  ".pred.safe_across_calls p1-p63"
+  [(set_attr "type" "unknown")
+   (set_attr "predicable" "no")])
+
+(define_insn "safe_across_calls_normal"
+  [(unspec_volatile [(const_int 0)] 9)]
+  ""
+  "*
+{
+  emit_safe_across_calls (asm_out_file);
+  return \"\";
+}"
+  [(set_attr "type" "unknown")
+   (set_attr "predicable" "no")])
+
--- gcc/config/ia64/ia64intrin.h.jj	Thu Mar  9 01:26:04 2000
+++ gcc/config/ia64/ia64intrin.h	Mon Feb  5 14:56:13 2001
@@ -1,60 +1,132 @@
 #ifndef _IA64INTRIN_H_INCLUDED
 #define _IA64INTRIN_H_INCLUDED
 
-void __sync_synchronize (void);
-
-int  __sync_val_compare_and_swap_si (int *, int, int);
-long __sync_val_compare_and_swap_di (long *, long, long);
-#define __sync_val_compare_and_swap(A,B,C) ((sizeof (*(A)) == sizeof(int)) ? __sync_val_compare_and_swap_si((int *)(A),(int)(B),(int)(C)) : __sync_val_compare_and_swap_di((long *)(A),(long)(B),(long)(C)))
-
-int  __sync_bool_compare_and_swap_si (int *, int, int);
-long __sync_bool_compare_and_swap_di (long *, long, long);
-#define __sync_bool_compare_and_swap(A,B,C) ((sizeof (*(A)) == sizeof(int)) ? __sync_bool_compare_and_swap_si((int *)(A),(int)(B),(int)(C)) : __sync_bool_compare_and_swap_di((long *)(A),(long)(B),(long)(C)))
-
-void __sync_lock_release_si (int *);
-void __sync_lock_release_di (long *);
-#define __sync_lock_release(A) ((sizeof (*(A)) == sizeof(int)) ? __sync_lock_release_si((int *)(A)) : __sync_lock_release_di((long *)(A)))
-
-int  __sync_lock_test_and_set_si (int *, int);
-long __sync_lock_test_and_set_di (long *, long);
-#define __sync_lock_test_and_set(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_lock_test_and_set_si((int *)(A),(int)(B)) : __sync_lock_test_and_set_di((long *)(A),(long)(B)))
-
-int  __sync_fetch_and_add_si  (int *, int);
-int  __sync_fetch_and_sub_si  (int *, int);
-int  __sync_fetch_and_and_si  (int *, int);
-int  __sync_fetch_and_or_si   (int *, int);
-int  __sync_fetch_and_xor_si  (int *, int);
-int  __sync_fetch_and_nand_si (int *, int);
-long __sync_fetch_and_add_di  (long *, long);
-long __sync_fetch_and_sub_di  (long *, long);
-long __sync_fetch_and_and_di  (long *, long);
-long __sync_fetch_and_or_di   (long *, long);
-long __sync_fetch_and_xor_di  (long *, long);
-long __sync_fetch_and_nand_di (long *, long);
-#define __sync_fetch_and_add(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_add_si((int *)(A),(int)(B)) : __sync_fetch_and_add_di((long *)(A),(long)(B)))
-#define __sync_fetch_and_sub(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_sub_si((int *)(A),(int)(B)) : __sync_fetch_and_sub_di((long *)(A),(long)(B)))
-#define __sync_fetch_and_and(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_and_si((int *)(A),(int)(B)) : __sync_fetch_and_and_di((long *)(A),(long)(B)))
-#define __sync_fetch_and_or(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_or_si((int *)(A),(int)(B)) : __sync_fetch_and_or_di((long *)(A),(long)(B)))
-#define __sync_fetch_and_xor(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_xor_si((int *)(A),(int)(B)) : __sync_fetch_and_xor_di((long *)(A),(long)(B)))
-#define __sync_fetch_and_nand(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_fetch_and_nand_si((int *)(A),(int)(B)) : __sync_fetch_and_nand_di((long *)(A),(long)(B)))
-
-int  __sync_add_and_fetch_si  (int *, int);
-int  __sync_sub_and_fetch_si  (int *, int);
-int  __sync_and_and_fetch_si  (int *, int);
-int  __sync_or_and_fetch_si   (int *, int);
-int  __sync_xor_and_fetch_si  (int *, int);
-int  __sync_nand_and_fetch_si (int *, int);
-long __sync_add_and_fetch_di  (long *, long);
-long __sync_sub_and_fetch_di  (long *, long);
-long __sync_and_and_fetch_di  (long *, long);
-long __sync_or_and_fetch_di   (long *, long);
-long __sync_xor_and_fetch_di  (long *, long);
-long __sync_nand_and_fetch_di (long *, long);
-#define __sync_add_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_add_and_fetch_si((int *)(A),(int)(B)) : __sync_add_and_fetch_di((long *)(A),(long)(B)))
-#define __sync_sub_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_sub_and_fetch_si((int *)(A),(int)(B)) : __sync_sub_and_fetch_di((long *)(A),(long)(B)))
-#define __sync_and_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_and_and_fetch_si((int *)(A),(int)(B)) : __sync_and_and_fetch_di((long *)(A),(long)(B)))
-#define __sync_or_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_or_and_fetch_si((int *)(A),(int)(B)) : __sync_or_and_fetch_di((long *)(A),(long)(B)))
-#define __sync_xor_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_xor_and_fetch_si((int *)(A),(int)(B)) : __sync_xor_and_fetch_di((long *)(A),(long)(B)))
-#define __sync_nand_and_fetch(A,B) ((sizeof (*(A)) == sizeof(int)) ? __sync_nand_and_fetch_si((int *)(A),(int)(B)) : __sync_nand_and_fetch_di((long *)(A),(long)(B)))
+/* Actually, everything is a compiler builtin, but just so
+   there's no confusion... */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void __sync_synchronize (void);
+
+extern int __sync_val_compare_and_swap_si (int *, int, int);
+extern long __sync_val_compare_and_swap_di (long *, long, long);
+#define __sync_val_compare_and_swap(PTR, OLD, NEW)			\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR)))						\
+    __sync_val_compare_and_swap_si((int *)(PTR),(int)(OLD),(int)(NEW))	\
+  : (__typeof__(*(PTR)))						\
+    __sync_val_compare_and_swap_di((long *)(PTR),(long)(OLD),(long)(NEW)))
+
+extern int __sync_bool_compare_and_swap_si (int *, int, int);
+extern long __sync_bool_compare_and_swap_di (long *, long, long);
+#define __sync_bool_compare_and_swap(PTR, OLD, NEW)			\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR)))						\
+    __sync_bool_compare_and_swap_si((int *)(PTR),(int)(OLD),(int)(NEW))	\
+  : (__typeof__(*(PTR)))						\
+    __sync_bool_compare_and_swap_di((long *)(PTR),(long)(OLD),(long)(NEW)))
+
+extern void __sync_lock_release_si (int *);
+extern void __sync_lock_release_di (long *);
+#define __sync_lock_release(PTR)		\
+  ((sizeof (*(PTR)) == sizeof(int))		\
+   ? __sync_lock_release_si((int *)(PTR))	\
+   : __sync_lock_release_di((long *)(PTR)))
+
+extern int __sync_lock_test_and_set_si (int *, int);
+extern long __sync_lock_test_and_set_di (long *, long);
+#define __sync_lock_test_and_set(PTR,VAL)				\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_lock_test_and_set_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_lock_test_and_set_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_fetch_and_add_si (int *, int);
+extern long __sync_fetch_and_add_di (long *, long);
+#define __sync_fetch_and_add(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_fetch_and_add_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_fetch_and_add_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_fetch_and_sub_si (int *, int);
+extern long __sync_fetch_and_sub_di (long *, long);
+#define __sync_fetch_and_sub(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_fetch_and_sub_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_fetch_and_sub_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_fetch_and_and_si (int *, int);
+extern long __sync_fetch_and_and_di (long *, long);
+#define __sync_fetch_and_and(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_fetch_and_and_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_fetch_and_and_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_fetch_and_or_si (int *, int);
+extern long __sync_fetch_and_or_di (long *, long);
+#define __sync_fetch_and_or(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_fetch_and_or_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_fetch_and_or_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_fetch_and_xor_si (int *, int);
+extern long __sync_fetch_and_xor_di (long *, long);
+#define __sync_fetch_and_xor(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_fetch_and_xor_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_fetch_and_xor_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_fetch_and_nand_si (int *, int);
+extern long __sync_fetch_and_nand_di (long *, long);
+#define __sync_fetch_and_nand(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_fetch_and_nand_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_fetch_and_nand_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_add_and_fetch_si (int *, int);
+extern long __sync_add_and_fetch_di (long *, long);
+#define __sync_add_and_fetch(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_add_and_fetch_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_add_and_fetch_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_sub_and_fetch_si (int *, int);
+extern long __sync_sub_and_fetch_di (long *, long);
+#define __sync_sub_and_fetch(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_sub_and_fetch_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_sub_and_fetch_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_and_and_fetch_si (int *, int);
+extern long __sync_and_and_fetch_di (long *, long);
+#define __sync_and_and_fetch(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_and_and_fetch_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_and_and_fetch_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_or_and_fetch_si (int *, int);
+extern long __sync_or_and_fetch_di (long *, long);
+#define __sync_or_and_fetch(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_or_and_fetch_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_or_and_fetch_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_xor_and_fetch_si (int *, int);
+extern long __sync_xor_and_fetch_di (long *, long);
+#define __sync_xor_and_fetch(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_xor_and_fetch_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_xor_and_fetch_di((long *)(PTR),(long)(VAL)))
+
+extern int __sync_nand_and_fetch_si (int *, int);
+extern long __sync_nand_and_fetch_di (long *, long);
+#define __sync_nand_and_fetch(PTR,VAL)					\
+ ((sizeof (*(PTR)) == sizeof(int))					\
+  ? (__typeof__(*(PTR))) __sync_nand_and_fetch_si((int *)(PTR),(int)(VAL)) \
+  : (__typeof__(*(PTR))) __sync_nand_and_fetch_di((long *)(PTR),(long)(VAL)))
+
+#ifdef __cplusplus
+}
+#endif
 
 #endif
--- gcc/config/ia64/lib1funcs.asm.jj	Mon Apr 17 13:42:47 2000
+++ gcc/config/ia64/lib1funcs.asm	Mon Feb  5 14:56:13 2001
@@ -1,3 +1,45 @@
+#ifdef L__divtf3
+// Compute a 80-bit IEEE double-extended quotient.
+//
+// From the Intel IA-64 Optimization Guide, choose the minimum latency
+// alternative.
+//
+// farg0 holds the dividend.  farg1 holds the divisor.
+
+	.text
+	.align 16
+	.global __divtf3
+	.proc __divtf3
+__divtf3:
+	frcpa f10, p6 = farg0, farg1
+	;;
+(p6)	fnma.s1 f11 = farg1, f10, f1
+	;;
+(p6)	fma.s1 f12 = f11, f10, f10
+(p6)	fma.s1 f11 = f11, f11, f0
+	;;
+(p6)	fma.s1 f11 = f11, f12, f12
+	;;
+(p6)	fnma.s1 f12 = farg1, f11, f1
+(p6)	fma.s1 f10 = farg0, f10, f0
+	;;
+(p6)	fma.s1 f11 = f12, f11, f11
+(p6)	fnma.s1 f12 = farg1, f10, farg0
+	;;
+(p6)	fma.s1 f10 = f12, f11, f10
+(p6)	fnma.s1 f12 = farg1, f11, f1
+	;;
+(p6)	fnma.s1 f8 = farg1, f10, farg0
+(p6)	fma.s1 f9 = f12, f11, f11
+	;;
+(p6)	fma f10 = f8, f9, f10
+	;;
+	mov fret0 = f10
+	br.ret.sptk rp
+	;;
+	.endp __divtf3
+#endif
+
 #ifdef L__divdf3
 // Compute a 64-bit IEEE double quotient.
 //
@@ -563,33 +605,43 @@ __umodsi3:
 	.global __ia64_save_stack_nonlocal
 	.proc __ia64_save_stack_nonlocal
 __ia64_save_stack_nonlocal:
-	alloc r18=ar.pfs,2,0,0,0
-	st8 [in0]=in1,8
-	mov r19=ar.rsc
-	;;
-	flushrs
-	and r19=0x1c,r19
-	mov ar.pfs=r18
-	;;
-	mov ar.rsc=r19
-	mov r16=ar.bsp
-	adds r2=16,in0
-	;;
-	mov r17=ar.rnat
-	st8 [in0]=r16,8
-	or r19=0x3,r19
-	;;
-	st8 [in0]=r17
-	mov ar.rsc=r19
-	st8 [r2]=r18
-	mov ar.pfs=r18
-	br.ret.sptk.few rp
-	;;
+	{ .mmf
+	  alloc r18 = ar.pfs, 2, 0, 0, 0
+	  mov r19 = ar.rsc
+	  ;;
+	}
+	{ .mmi
+	  flushrs
+	  st8 [in0] = in1, 24
+	  and r19 = 0x1c, r19
+	  ;;
+	}
+	{ .mmi
+	  st8 [in0] = r18, -16
+	  mov ar.rsc = r19
+	  or r19 = 0x3, r19
+	  ;;
+	}
+	{ .mmi
+	  mov r16 = ar.bsp
+	  mov r17 = ar.rnat
+	  adds r2 = 8, in0
+	  ;;
+	}
+	{ .mmi
+	  st8 [in0] = r16
+	  st8 [r2] = r17
+	}
+	{ .mib
+	  mov ar.rsc = r19
+	  br.ret.sptk.few rp
+	  ;;
+	}
 	.endp __ia64_save_stack_nonlocal
 #endif
 
 #ifdef L__nonlocal_goto
-// void __ia64_nonlocal_goto(void *fp, void *target_label, void *save_area,
+// void __ia64_nonlocal_goto(void *target_label, void *save_area,
 //			     void *static_chain);
 
 	.text
@@ -597,35 +649,47 @@ __ia64_save_stack_nonlocal:
 	.global __ia64_nonlocal_goto
 	.proc __ia64_nonlocal_goto
 __ia64_nonlocal_goto:
-	alloc r20=ar.pfs,4,0,0,0
-	mov r19=ar.rsc
-	adds r2=8,in2
-	ld8 r12=[in2],16
-	mov.ret.sptk rp = r33, .L0
-	;;
-	flushrs
-	ld8 r16=[r2],16
-	and r19=0x1c,r19
-	ld8 r17=[in2]
-	;;
-	ld8 r18=[r2]
-	mov ar.rsc=r19
-	;;
-	mov ar.bspstore=r16
-	;;
-	mov ar.rnat=r17
-	mov ar.pfs=r18
-	or r19=0x3,r19
-	;;
-	loadrs
-	invala
-	mov r7=r32
-.L0:	{
-	mov ar.rsc=r19
-	mov r15=r35
-	br.ret.sptk.few rp
+	{ .mmi
+	  alloc r20 = ar.pfs, 3, 0, 0, 0
+	  ld8 r12 = [in1], 8
+	  mov.ret.sptk rp = in0, .L0
+	  ;;
+	}
+	{ .mmf
+	  ld8 r16 = [in1], 8
+	  mov r19 = ar.rsc
+	  ;;
+	}
+	{ .mmi
+	  flushrs
+	  ld8 r17 = [in1], 8
+	  and r19 = 0x1c, r19
+	  ;;
+	}
+	{ .mmi
+	  ld8 r18 = [in1]
+	  mov ar.rsc = r19
+	  or r19 = 0x3, r19
+	  ;;
+	}
+	{ .mmi
+	  mov ar.bspstore = r16
+	  ;;
+	  mov ar.rnat = r17
+	  ;;
+	}
+	{ .mmi
+	  loadrs
+	  invala
+	  mov r15 = in2
+	  ;;
+	}
+.L0:	{ .mib
+	  mov ar.rsc = r19
+	  mov ar.pfs = r18
+	  br.ret.sptk.few rp
+	  ;;
 	}
-	;;
 	.endp __ia64_nonlocal_goto
 #endif
 
@@ -640,31 +704,84 @@ __ia64_nonlocal_goto:
 	.global __ia64_restore_stack_nonlocal
 	.proc __ia64_restore_stack_nonlocal
 __ia64_restore_stack_nonlocal:
-	alloc r20=ar.pfs,4,0,0,0
-	mov r19=ar.rsc
-	adds r2=8,in0
-	ld8 r12=[in0],16
-	;;
-	flushrs
-	ld8 r16=[r2],16
-	and r19=0x1c,r19
-	ld8 r17=[in0]
-	;;
-	ld8 r18=[r2]
-	mov ar.rsc=r19
-	;;
-	mov ar.bspstore=r16
-	;;
-	mov ar.rnat=r17
-	mov ar.pfs=r18
-	or r19=0x3,r19
-	;;
-	loadrs
-	invala
-.L0:	{
-	mov ar.rsc=r19
-	br.ret.sptk.few rp
+	{ .mmf
+	  alloc r20 = ar.pfs, 4, 0, 0, 0
+	  ld8 r12 = [in0], 8
+	  ;;
+	}
+	{ .mmb
+	  ld8 r16=[in0], 8
+	  mov r19 = ar.rsc
+	  ;;
+	}
+	{ .mmi
+	  flushrs
+	  ld8 r17 = [in0], 8
+	  and r19 = 0x1c, r19
+	  ;;
+	}
+	{ .mmf
+	  ld8 r18 = [in0]
+	  mov ar.rsc = r19
+	  ;;
+	}
+	{ .mmi
+	  mov ar.bspstore = r16
+	  ;;
+	  mov ar.rnat = r17
+	  or r19 = 0x3, r19
+	  ;;
+	}
+	{ .mmf
+	  loadrs
+	  invala
+	  ;;
+	}
+.L0:	{ .mib
+	  mov ar.rsc = r19
+	  mov ar.pfs = r18
+	  br.ret.sptk.few rp
+	  ;;
 	}
-	;;
 	.endp __ia64_restore_stack_nonlocal
+#endif
+
+#ifdef L__trampoline
+// Implement the nested function trampoline.  This is out of line
+// so that we don't have to bother with flushing the icache, as
+// well as making the on-stack trampoline smaller.
+//
+// The trampoline has the following form:
+//
+//		+-------------------+ \ 
+//	TRAMP:	| __ia64_trampoline | |
+//		+-------------------+  > fake function descriptor
+//		| TRAMP+16          | |
+//		+-------------------+ /
+//		| target descriptor |
+//		+-------------------+
+//		| static link	    |
+//		+-------------------+
+
+	.text
+	.align 16
+	.global __ia64_trampoline
+	.proc __ia64_trampoline
+__ia64_trampoline:
+	{ .mmi
+	  ld8 r2 = [r1], 8
+	  ;;
+	  ld8 r15 = [r1]
+	}
+	{ .mmi
+	  ld8 r3 = [r2], 8
+	  ;;
+	  ld8 r1 = [r2]
+	  mov b6 = r3
+	}
+	{ .bbb
+	  br.sptk.many b6
+	  ;;
+	}
+	.endp __ia64_trampoline
 #endif
--- gcc/config/ia64/linux.h.jj	Sun Jul  2 10:37:13 2000
+++ gcc/config/ia64/linux.h	Mon Feb  5 14:56:13 2001
@@ -10,7 +10,7 @@
 
 /* ??? ia64 gas doesn't accept standard svr4 assembler options?  */
 #undef ASM_SPEC
-#define ASM_SPEC "-x"
+#define ASM_SPEC "-x %{mconstant-gp} %{mauto-pic}"
 
 /* Define this for shared library support because it isn't in the main
    linux.h file.  */
--- gcc/config/ia64/sysv4.h.jj	Mon Jun 19 11:17:45 2000
+++ gcc/config/ia64/sysv4.h	Mon Feb  5 14:56:13 2001
@@ -37,7 +37,8 @@ extern int size_directive_output;
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \
 do {									\
-  if (XSTR (XEXP (DECL_RTL (DECL), 0), 0)[0] == SDATA_NAME_FLAG_CHAR)	\
+  if ((DECL)								\
+      && XSTR (XEXP (DECL_RTL (DECL), 0), 0)[0] == SDATA_NAME_FLAG_CHAR) \
     sbss_section ();							\
   else									\
     bss_section ();							\
@@ -114,14 +115,8 @@ while (0)
   } while (0)
 
 /* svr4.h undefines this, so we need to define it here.  */
-#define DBX_REGISTER_NUMBER(REGNO) 					\
-  (IN_REGNO_P (REGNO) ? (32 + (REGNO) - IN_REG (0)) 			\
-   : LOC_REGNO_P (REGNO) ? (32 + ia64_input_regs +			\
-			    (REGNO) - LOC_REG (0))			\
-   : OUT_REGNO_P (REGNO) ? (32 + ia64_input_regs + ia64_local_regs	\
-			    + (REGNO) - OUT_REG (0))			\
-   : (REGNO) == FRAME_POINTER_REGNUM ? ia64_fp_regno 			\
-   : (REGNO))
+#define DBX_REGISTER_NUMBER(REGNO) \
+  ia64_dbx_register_number(REGNO)
 
 /* Things that svr4.h defines to the wrong type, because it assumes 32 bit
    ints and 32 bit longs.  */
@@ -183,7 +178,7 @@ do {									\
 #define ASM_FILE_START(STREAM) \
 do {									\
   output_file_directive (STREAM, main_input_filename);			\
-  ia64_file_start(STREAM);						\
+  emit_safe_across_calls (STREAM);					\
 } while (0)
 
 /* Case label alignment is handled by ADDR_VEC_ALIGN now.  */
--- gcc/config/ia64/t-ia64.jj	Thu Jun  1 11:56:48 2000
+++ gcc/config/ia64/t-ia64	Mon Feb  5 14:56:13 2001
@@ -8,10 +8,10 @@ LIB1ASMSRC    = ia64/lib1funcs.asm
 # ??? We change the names of the DImode div/mod files so that they won't
 # accidentally be overridden by libgcc2.c files.  We used to use __ia64 as
 # a prefix, now we use __ as the prefix.
-LIB1ASMFUNCS  = __divdf3 __divsf3 \
+LIB1ASMFUNCS  = __divtf3 __divdf3 __divsf3 \
 	__divdi3 __moddi3 __udivdi3 __umoddi3 \
 	__divsi3 __modsi3 __udivsi3 __umodsi3 __save_stack_nonlocal \
-	__nonlocal_goto __restore_stack_nonlocal
+	__nonlocal_goto __restore_stack_nonlocal __trampoline
 
 # ??? Hack to get -P option used when compiling lib1funcs.asm, because Intel
 # assembler does not accept # line number as a comment.
--- gcc/config/elfos.h.jj	Fri Jun 16 13:10:29 2000
+++ gcc/config/elfos.h	Mon Feb  5 14:56:13 2001
@@ -582,7 +582,8 @@ dtors_section ()						\
       								\
       size_directive_output = 0;				\
       								\
-      if (!flag_inhibit_size_directive && DECL_SIZE (DECL))	\
+      if (!flag_inhibit_size_directive				\
+	  && (DECL) && DECL_SIZE (DECL))			\
 	{							\
 	  size_directive_output = 1;				\
 	  fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);		\
--- gcc/testsuite/gcc.c-torture/compile/961203-1.x.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/gcc.c-torture/compile/961203-1.x	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,7 @@
+# This doesn't work on any host with 32 bit int or smaller.
+
+# Because this test tends to consume lots of system resources and doesn't
+# currently work, don't actually run it.  Just report a failure.
+setup_xfail "*-*-*"
+fail "gcc.c-torture/compile/961203-1.c"
+return 1 ;# `1' says we handled the testcase ourselves
--- gcc/testsuite/gcc.c-torture/compile/981211-1.c.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/gcc.c-torture/compile/981211-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,43 @@
+/* Basic tests of the #assert preprocessor extension. */
+
+#define fail  int fail
+
+#assert abc (def)
+#assert abc (ghi)
+#assert abc (jkl)
+#assert space ( s p a c e )
+
+/* Basic: */
+#if !#abc (def) || !#abc (ghi) || !#abc (jkl)
+fail
+#endif
+
+/* any answer for #abc */
+#if !#abc
+fail
+#endif
+
+/* internal whitespace is collapsed,
+   external whitespace is deleted  */
+#if !#space (s p  a  c e) || !#space (  s p a c e  ) || #space (space)
+fail
+#endif
+
+/* removing assertions */
+#unassert abc (jkl)
+#if !#abc || !#abc (def) || !#abc (ghi) || #abc (jkl)
+fail
+#endif
+
+#unassert abc
+#if #abc || #abc (def) || #abc (ghi) || #abc (jkl)
+fail
+#endif
+
+int gobble
+
+/* make sure it can succeed too.
+   also check space before open paren isn't significant */
+#if #space(s p a c e)
+;
+#endif
--- gcc/testsuite/gcc.c-torture/execute/20000523-2.c.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/gcc.c-torture/execute/20000523-2.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,47 @@
+#include <stdio.h>
+int   flg = 0 ;
+struct SRT {
+
+    signed long     m1 ;
+    signed int      m2 ;
+    signed int      m3 ;
+} ;
+
+void foo(volatile struct SRT a1, volatile struct SRT ss)
+{
+   if (flg != 0) abort ();
+   exit (0);
+}
+
+struct SRT func( volatile struct SRT a1, volatile struct SRT *a2 )
+{
+    struct SRT ss =  *((struct SRT *)&a1) ;
+
+    ss.m1 = 1 ;
+    ss.m2 = 1 ;
+    ss.m3 = 1 ;
+
+    a2 = &ss ;
+    a1.m1 = (a2->m1 += 1) ;
+    a1.m2 = (a2->m2 += 1) ;
+    a1.m3 = (a2->m3 += 1) ;
+
+    if ( ss.m1 != 2 || ss.m2 != 2 || ss.m3 != 2  ||
+         a1.m1 != 2 || a1.m2 != 2 || a1.m3 != 2
+    ) {
+        flg = 1;
+        foo (a1, ss);
+    }
+
+
+    return( ss ) ;
+}
+
+void main( void )
+{
+    volatile struct SRT dat = { 0, 0, 0 } ;
+
+    dat =  func( dat, &dat ) ;
+    exit (0);
+}
+
--- gcc/testsuite/gcc.c-torture/execute/20000531-1.c.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/gcc.c-torture/execute/20000531-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,13 @@
+main()
+{
+    int         is = -32768 ;
+    unsigned int    iu = 0 ;
+    unsigned int    ua ;
+
+    ua = ( iu >= is ) ? iu : is ;
+
+    if( ua == is ) 
+        exit (0);
+    abort ();
+}
+
--- gcc/testsuite/gcc.c-torture/execute/20000629-1.c.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/gcc.c-torture/execute/20000629-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,19 @@
+main()
+{
+        int i = 0 , j ;
+        int a[2] = { 0, 1 } ;
+
+        while ( i == 0 ){
+                a[0] = 2 ;
+                for ( j = 1 ; j < 2 ; j++) {
+                        a[j] = a[j-1] ;
+                }
+                i++ ;
+        }
+
+        if( a[1] != 2 ) 
+	  abort ();
+
+	exit (0);
+}
+
--- gcc/testsuite/gcc.c-torture/code_quality/920608-1.c.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/gcc.c-torture/code_quality/920608-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,25 @@
+foo (p)
+     int *p;
+{
+  int x;
+  int a;
+
+  a = p[0];
+  x = a + 5;
+  a = -1;
+  p[0] = x - 5;
+  return a;
+}
+
+bar (p)
+{
+  short x;
+  int a;
+
+  x = ((short *) p)[1];
+#if INHIBIT_COMBINE
+  ((short *) p)[0] = x;
+#endif
+
+  return (x < 45);
+}
--- gcc/testsuite/gcc.c-torture/code_quality/code_quality.exp.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/gcc.c-torture/code_quality/code_quality.exp	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,55 @@
+#
+# Expect driver script for GCC Regression Tests
+#   Copyright (C) 1993, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+#
+
+#
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# This loop will run c-torture on any *.c file found in this directory.
+# If a *.c has a corresponding *.exp file, then the test is skipped as
+# as the *.exp will drive the test itself. I did things this way so that
+# generic tests did not need a seperate .exp for it. Only the tests that 
+# required unique options would need it's own .exp file.
+#
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    if [file exists [file rootname $testcase].exp] then {
+	verbose "INFO:\"[file rootname $testcase].exp\" exists, skipping test" 3
+	continue
+    }
+
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+    
+    c-torture $testcase
+}
+
--- gcc/testsuite/gcc.c-torture/noncompile/920507-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/920507-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+x(){register*a asm("unknown_register");int*v[1]={a};}
--- gcc/testsuite/gcc.c-torture/noncompile/920616-2.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/920616-2.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+f(void a,...){}
--- gcc/testsuite/gcc.c-torture/noncompile/920721-2.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/920721-2.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+f(int n){int s;for(s=0;s<n;s++)s==5?1 n=1;}
--- gcc/testsuite/gcc.c-torture/noncompile/920824-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/920824-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+struct s{struct s{int i;}x;};
--- gcc/testsuite/gcc.c-torture/noncompile/920923-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/920923-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,36 @@
+typedef BYTE unsigned char;typedef int item_n;typedef int perm_set;struct
+PENT{caddr_t v_addr;};typedef struct PENT prec;typedef struct PENT*
+prec_t;prec_t mem_hash;BYTE*mem_base;struct PTE{BYTE*p_page;perm_set
+p_perms;};typedef struct PTE pte;struct PTP{union{struct*PTP
+p_tablep;struct*PTE p_entry;}u;int valid;};typedef struct PTP
+(u.p_tablep);int pfree=0;int pcount=0;void mmu_walk_find(va)caddr_t va;{
+BYTE*page_addr;if(mmu_base[Level1(va)]->valid==0x0){l1_base=
+mmu_base[Level1(va)]->(u.p_tablep)=p_alloc();mmu_base[Level1(va)]->valid=
+0x3;for(idx=0;idx<LEVEL1_ENTRIES;idx++)l1_base[idx]->valid=0x0;goto
+build_level2;}else l1_base=mmu_base[Level1(va)]->(u.p_tablep);if
+(l1_base[Level2(va)]->valid==0x0){build_level2:l2_base=
+l1_base[Level2(va)]->(u.p_tablep)=p_alloc();l1_base[Level2(va)]->valid=
+0x3;for(idx=0;idx<LEVEL2_ENTRIES;idx++)l2_base[idx]->valid=0x0;goto
+build_page;}else l2_base=mmu_base[Level2(va)]->(u.p_tablep);
+page_addr=l2_base[Level2(va)]->valid;}void*a_translate(va_op,v_addr)int
+va_op;caddr_t v_addr;{register prec_t bucket;register caddr_t p_addr;
+bucket=mem_hash+((((v_addr)>>ITEMBITS))&hash_mask);do{if
+(bucket->v_addr==((v_addr)>>ITEMBITS){if(!(bucket->perm_set&va_op))
+goto prot_fault;return mem_base+v_addr;}}while((bucket++)->v_addr!=
+((caddr_t)0));page_miss:p_addr=(--bucket)->p_addr;page_type:switch
+(p_addr){case BUCKET_FULL:enlarge_hash_table(mem_hash);case((caddr_t)0):
+p_addr=fill_item_entry(va_op,v_addr);goto page_type;case((caddr_t)1):
+default:((void)(((0))?0:(__eprintf("Failed assertion`%s'at line%d
+of`%s'.\n","FALSE",327,"b.c"),0)));}}void flush_hash(hasht,
+hash_size)prec_t hasht;int hash_size;{register prec_t bucket;register int
+idx;bucket=hasht;for(idx=(hash_size*3)-1;idx>=0;idx--){
+bucket->v_addr=((caddr_t)0);bucket->p_addr=((caddr_t)0);
+bucket->perm_set=VA_EMPTY;}}void init_mem(){mem_base=(BYTE*)calloc(1024
+,(1<<13));((void)((mem_base!=(BYTE*)0)?0:(__eprintf("Failed
+assertion`%s'at line%d of`%s'.\n","mem_base!=(BYTE*)0",366,"b.c"),
+0)));hash_num=INIT_NUM_ENTRIES*3;mem_hash=(prec_t)calloc(hash_num,
+sizeof(prec));((void)((mem_hash!=(prec_t)0)?0:(__eprintf("Failed
+assertion`%s'at line%d of`%s'.\n","mem_hash!=(prec_t)0",370,"b.c"),
+0)));flush_hash(mem_hash,32);build_ptables(mem_base,1024*(1<<13));}
+struct tm{int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int
+tm_year;int tm_wday;int tm_yday;int tm_isdst;char*tm_zone;long tm_gmtoff;};
--- gcc/testsuite/gcc.c-torture/noncompile/921102-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/921102-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+int x[]={[0.3 ... 4.6]9};
--- gcc/testsuite/gcc.c-torture/noncompile/921116-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/921116-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+void a (void x) {}
--- gcc/testsuite/gcc.c-torture/noncompile/930301-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/930301-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,5 @@
+struct a *q;
+f()
+{
+  q++;
+}
--- gcc/testsuite/gcc.c-torture/noncompile/930622-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/930622-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,6 @@
+f ()
+{
+  double b;
+  b = b * 10;
+  goto c;
+}
--- gcc/testsuite/gcc.c-torture/noncompile/930622-2.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/930622-2.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,6 @@
+f ()
+{
+  int i;
+  for (i--)
+    ;
+}
--- gcc/testsuite/gcc.c-torture/noncompile/930714-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/930714-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,25 @@
+typedef union _yystype
+{
+  int i;
+  int *iptr;
+  int (*ifunc)(int);
+  void (*vfunc)(int);
+}
+YYSTYPE;
+
+extern int f1(int k);
+
+void test()
+{
+  YYSTYPE a;
+  int (*iptr)(int);
+  int foo[5];
+
+  a = f1;
+  a = (YYSTYPE)f1;
+  a = (YYSTYPE)foo;
+  a = (YYSTYPE)(int *)foo;
+  iptr = f1;
+  a = iptr;
+  a = (YYSTYPE)iptr;
+}
--- gcc/testsuite/gcc.c-torture/noncompile/931203-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/931203-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,11 @@
+typedef struct
+{
+  int x, y;
+} point_t;
+
+
+point_t
+f ()
+{
+  return 0;
+}
--- gcc/testsuite/gcc.c-torture/noncompile/940112-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/940112-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,7 @@
+double
+f (int x)
+{
+  double e = 1;
+  e = 1;
+  return (e)
+}
--- gcc/testsuite/gcc.c-torture/noncompile/940227-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/940227-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,5 @@
+struct font {
+  struct {
+    char *line,*ulmask;
+  } c[2];
+} character[1] = { { {"", ""}, {"", ""} } };
--- gcc/testsuite/gcc.c-torture/noncompile/940510-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/940510-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+struct { int a[]; } x = { 0 };
--- gcc/testsuite/gcc.c-torture/noncompile/940712-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/940712-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,14 @@
+/* PR 4713 */
+
+#include "940712-1.h"
+#include "940712-1a.h"
+#include "940712-1b.h"
+
+/* comment start in comment error
+/* in a .c file */
+
+int main ()
+{
+    return 0;
+}
+
--- gcc/testsuite/gcc.c-torture/noncompile/940712-1.h.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/940712-1.h	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,10 @@
+/* comment start in comment error
+/* in a .h file */
+
+#if 0
+#endif /* comment start in comment error
+/* after a cpp directive */
+
+/* comment start in comment error
+
+
--- gcc/testsuite/gcc.c-torture/noncompile/940712-1a.h.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/940712-1a.h	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,4 @@
+/* spanning a .h file */
+
+#if 0
+#endif /* comment start in comment error
--- gcc/testsuite/gcc.c-torture/noncompile/940712-1b.h.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/940712-1b.h	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,2 @@
+/* spanning a .h file */
+
--- gcc/testsuite/gcc.c-torture/noncompile/950825-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/950825-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+main() { return (struct x) {{y: 0}}; }
--- gcc/testsuite/gcc.c-torture/noncompile/950921-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/950921-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,10 @@
+typedef enum
+{
+  a = (X) 0,
+  b
+} c;
+
+typedef enum
+{
+  d = (X) 0
+} e;
--- gcc/testsuite/gcc.c-torture/noncompile/951025-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/951025-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+#include /\
--- gcc/testsuite/gcc.c-torture/noncompile/951123-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/951123-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,2 @@
+struct S { int a; int b[2]; };
+struct S x = { 0, [0]; };
--- gcc/testsuite/gcc.c-torture/noncompile/951227-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/951227-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,2 @@
+#if 0xe-1
+#endif
--- gcc/testsuite/gcc.c-torture/noncompile/971104-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/971104-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,26 @@
+typedef unsigned short          ushort;
+struct sembuf {
+  ushort  sem_num;         
+  short   sem_op;          
+  short   sem_flg;         
+};
+union semun {
+  int val;                       
+  struct semid_ds *buf;          
+  ushort *array;                 
+  struct seminfo *__buf;         
+  void *__pad;
+};
+static union semun semctl_arg;
+static int semid;
+static void up(int sem){
+  struct sembuf sb;
+  sb.sem_num = (unsigned short) sem;
+  sb.sem_op  = 1;         
+  sb.sem_flg = 0x1000 ;  
+  if(semop(semid, &sb, 1) == -1) error("up failure");
+  if(semctl(semid, sb.sem_num, 12 , semctl_arg) == 0)
+    printf("%s had processes sleeping on it!\n",
+    ({ "MUTEX     ", "BARB_SEM 1", "BARB_SEM 2", "CUST_SEM 1", "CUST_SEM 2", "WA
+IT_SEM 1", "WAIT_SEM 2", "WAIT_SEM 3", "WAIT_SEM 4"} [( sb.sem_num )]) );
+}
--- gcc/testsuite/gcc.c-torture/noncompile/990416-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/990416-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,10 @@
+typedef int word_type;
+   
+static void
+copy_reg (unsigned int reg, frame_state *udata, frame_state *target_udata)
+{  
+  word_type *preg = get_reg_addr (reg, udata, 0);
+  word_type *ptreg = get_reg_addr (reg, target_udata, 0);
+   
+  memcpy (ptreg, preg, __builtin_dwarf_reg_size (reg));
+}
--- gcc/testsuite/gcc.c-torture/noncompile/init-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/init-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,17 @@
+struct a
+{ double a, b, c; };
+
+struct b
+{
+  struct a arr[6];
+};
+
+static struct b a_b =
+{
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+};
--- gcc/testsuite/gcc.c-torture/noncompile/init-2.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/init-2.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+int d[][] = { {1}, {2}, {3} };
--- gcc/testsuite/gcc.c-torture/noncompile/invalid_asm.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/invalid_asm.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+asm_invalid_register_name(){asm("":::"this_is_an_invalid_register_name");}
--- gcc/testsuite/gcc.c-torture/noncompile/noncompile.exp.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/noncompile.exp	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,335 @@
+#   Copyright (C) 1988, 90-92, 1997, 1999 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Jeff Law. (law@cs.utah.edu)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+load_lib mike-gcc.exp
+
+# This is done just to set the value of TORTURE_OPTIONS.
+load_lib c-torture.exp
+
+proc postbase_with_opts { src run groups } {
+    global TORTURE_OPTIONS
+    # loop through all the options
+    foreach option $TORTURE_OPTIONS {
+        postbase $src $run $groups $option
+    }
+}
+
+# Test 920507-1.c
+prebase
+
+set src_code 920507-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 920616-2.c
+prebase
+
+set src_code 920616-2.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 920721-2.c
+prebase
+
+set src_code 920721-2.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 920824-1.c
+prebase
+
+set src_code 920824-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 920923-1.c
+prebase
+
+set src_code 920923-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 921102-1.c
+prebase
+
+set src_code 921102-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 921116-1.c
+prebase
+
+set src_code 921116-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 930301-1.c
+prebase
+
+set src_code 930301-1.c
+set compiler_output ".*:4:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 930622-1.c
+prebase
+
+set src_code 930622-1.c
+set compiler_output ".*:5:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 930622-2.c
+prebase
+
+set src_code 930622-2.c
+set compiler_output ".*:4:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 930714-1.c
+prebase
+
+set src_code 930714-1.c
+# Not really sure what the error should be here...
+set compiler_output ".*:18.*:23"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+# Test 931203-1.c
+prebase
+
+set src_code 931203-1.c
+set compiler_output ".*:10"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 940112-1.c
+prebase
+
+set src_code 940112-1.c
+set compiler_output ".*:7"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 940227-1.c
+prebase
+
+set src_code 940227-1.c
+set compiler_output ".*:5.*:5"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 940510-1.c
+prebase
+
+set src_code 940510-1.c
+set compiler_output ".*:1"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 940712-1.c
+prebase
+
+set src_code 940712-1.c
+set compiler_output ".*:8.*:4"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 950825-1.c
+prebase
+set src_code 950825-1.c
+set compiler_output ".*:1.*:1.*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 950921-1.c
+prebase
+set src_code 950921-1.c
+set compiler_output ".*:3.*:3.*:9.*:9:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 951025-1.c
+prebase
+set src_code 951025-1.c
+set compiler_output ".*:\[12\]:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 951123-1.c
+prebase
+set src_code 951123-1.c
+set compiler_output ".*:2:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 951227-1.c
+prebase
+set src_code 951227-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test 971104-1.c
+prebase
+set src_code 971104-1.c
+set compiler_output ".*:25:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+# Test 990416-1.c
+prebase
+set src_code 990416-1.c
+set compiler_output ".*:4:.*:6:.*:6:.*:6:.*:6:.*:6:.*:7:.*:7:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+# Test init-1.c
+prebase
+set src_code init-1.c
+set compiler_output ".*:12.*:12.*:13.*:13.*:14.*:14.*:15.*:15.*:16.*:16:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test init-2.c
+prebase
+set src_code init-2.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test invalid_asm.c
+prebase
+set src_code invalid_asm.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+
+# Test va-arg-1.c
+# It is debatable if this test should be included at all.
+# varags may be implemented by macros, which may not actually
+# reference the bogus argument.
+prebase
+
+set src_code va-arg-1.c
+set compiler_output ".*:6:"
+
+set groups {passed gcc-noncompile}
+
+postbase_with_opts $src_code $run $groups
+
+# Test poison-1.c
+prebase
+
+set src_code poison-1.c
+set compiler_output ".*c:2:.*c:4:.*c:5:.*c:7:.*c:8:.*c:9:.*c:11:.*c:12:.*c:13:.*c:14:.*c:17:.*c:20:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
--- gcc/testsuite/gcc.c-torture/noncompile/poison-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/poison-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,22 @@
+#pragma poison foo
+foo
+#pragma poison foo2 foo3
+foo2
+foo3
+#pragma   poison	foo4 	foo5
+foo4
+foo5
+#pragma poison +++
+#define foo6 123
+#pragma poison foo6
+#define foo6 345
+#define foo6 456
+#ifdef foo6
+#error hey!  foo6 poisoned!
+#endif
+#if defined(foo6)
+#error no, foo6 still poisoned!
+#else
+foo6
+#endif
+#pragma poison
--- gcc/testsuite/gcc.c-torture/noncompile/va-arg-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/noncompile/va-arg-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,8 @@
+#include <stdarg.h>
+
+f (int x, ...)
+{
+  va_list args;
+  va_start (args, bogus_variable);
+  va_end (args);
+}
--- gcc/testsuite/gcc.c-torture/special/920413-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/920413-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+x(b){unsigned long c;c=4294967295U/(unsigned long)b;}
--- gcc/testsuite/gcc.c-torture/special/920520-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/920520-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+f(){asm("%0"::"r"(1.5F));}g(){asm("%0"::"r"(1.5));}
--- gcc/testsuite/gcc.c-torture/special/920521-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/920521-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1 @@
+f(){asm("f":::"cc");}g(x,y){asm("g"::"%r"(x), "r"(y));}
--- gcc/testsuite/gcc.c-torture/special/920717-x.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/920717-x.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,3 @@
+/* 920717-1.c */
+
+const char s[]="foo";
--- gcc/testsuite/gcc.c-torture/special/920717-y.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/920717-y.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,8 @@
+/* 920717-y.c */
+
+extern const char s[];
+
+main()
+{
+	puts(s);
+}
--- gcc/testsuite/gcc.c-torture/special/920730-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/920730-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,32 @@
+/* 920730-1.c */
+
+f1()
+{
+	int b=0x80000000;
+	return b>=0x80000000;
+}
+
+f2()
+{
+	int b=0x80000001;
+	return b>=0x80000001;
+}
+
+f3()
+{
+	int b=0x7fffffff;
+	return b>=0x7fffffff;
+}
+
+f4()
+{
+	int b=0xffffffff;
+	return b>=0xffffffff;
+}
+
+main ()
+{
+	if((f1()&f2()&f3()&f4())!=1)
+		abort();
+		exit(0);
+}
--- gcc/testsuite/gcc.c-torture/special/921210-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/921210-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,4 @@
+#define a1(y) (y+1)
+#define a2(y) a1(y)+1
+#define f a->f
+a2(f)
--- gcc/testsuite/gcc.c-torture/special/930510-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/930510-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,3 @@
+#define ugly 3
+#ugly "foobar" 3	/* { dg-error "invalid" "invalid directive" } */
+int main() { exit (0); }
--- gcc/testsuite/gcc.c-torture/special/951130-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/951130-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,2 @@
+unsigned long long x = -(unsigned long long)(-(long long)(((unsigned long
+long)0 - 1) >> 1) - 1);
--- gcc/testsuite/gcc.c-torture/special/960224-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/960224-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,6 @@
+#if 0
+#if 0
+#endif \
+\
+
+#endif
--- gcc/testsuite/gcc.c-torture/special/960224-2.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/960224-2.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,4 @@
+#if 0
+#if 0
+#endif /
+#endif
--- gcc/testsuite/gcc.c-torture/special/981006-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/981006-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,50 @@
+/* Test that tablejump insns are correctly handled.  If the compiler
+   loses track of the jump targets, it will report that x and y can be
+   used uninitialized.
+
+   This is broken in egcs 1998/10/06 for mips in pic mode.  */
+/* { dg-do compile } */
+
+int foo (int a, int b)
+{
+  __label__ z;
+  int x; /* { dg-bogus "warning: `.' might be used uninitialized in this function" } */
+  int y; /* { dg-bogus "warning: `.' might be used uninitialized in this function" } */
+  static void *p;
+
+  switch (a) {
+  case 2:
+    x = 4;
+    break;
+  case 4:
+    x = 6;
+    break;
+  case 8: case 10: case 13: case 11: case 17: case 19:
+    x = 7;
+    break;
+  default:
+    x = -1;
+    break;
+  }
+  switch (b) {
+  case 2:
+    y = 4;
+    break;
+  case 4:
+    y = 6;
+    break;
+  case 8: case 10: case 13: case 11: case 17: case 19:
+    y = 7;
+    break;
+  default:
+    y = -1;
+    break;
+  }
+ z:
+  p = &&z;
+  return x * y;
+}
+int main (int argc, char *argv[])
+{
+  return 1 == foo (argc, argc + 1);
+}
--- gcc/testsuite/gcc.c-torture/special/eeprof-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/eeprof-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,67 @@
+#define ASSERT(X)	if (!(X)) abort ();
+#define NOCHK __attribute__ ((no_instrument_function))
+
+int entry_calls, exit_calls;
+void (*last_fn_entered)();
+void (*last_fn_exited)();
+
+int main () NOCHK;
+
+void foo ()
+{
+  ASSERT (last_fn_entered == foo);
+}
+
+static void foo2 ()
+{
+  ASSERT (entry_calls == 1 && exit_calls == 0);
+  ASSERT (last_fn_entered == foo2);
+  foo ();
+  ASSERT (entry_calls == 2 && exit_calls == 1);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo);
+}
+
+void nfoo (void) NOCHK;
+void nfoo ()
+{
+  ASSERT (entry_calls == 2 && exit_calls == 2);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo2);
+  foo ();
+  ASSERT (entry_calls == 3 && exit_calls == 3);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo);
+}
+
+int main ()
+{
+  ASSERT (entry_calls == 0 && exit_calls == 0);
+
+  foo2 ();
+
+  ASSERT (entry_calls == 2 && exit_calls == 2);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo2);
+
+  nfoo ();
+
+  ASSERT (entry_calls == 3 && exit_calls == 3);
+  ASSERT (last_fn_entered == foo);
+
+  return 0;
+}
+
+void __cyg_profile_func_enter (void (*fn)(), void (*parent)()) NOCHK;
+void __cyg_profile_func_exit (void (*fn)(), void (*parent)()) NOCHK;
+
+void __cyg_profile_func_enter (void (*fn)(), void (*parent)())
+{
+  entry_calls++;
+  last_fn_entered = fn;
+}
+void __cyg_profile_func_exit (void (*fn)(), void (*parent)())
+{
+  exit_calls++;
+  last_fn_exited = fn;
+}
--- gcc/testsuite/gcc.c-torture/special/special.exp.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.c-torture/special/special.exp	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,118 @@
+# Copyright (C) 1988, 90-96, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+load_lib gcc-dg.exp
+
+################## ADD NEXT CASE HERE (NOT AT THE END) ##################
+
+# 981006-1
+# For MIPS at least, pic is needed to trigger the problem.
+dg-init
+if { [istarget rs6000-*-aix*]
+     || [istarget powerpc*-*-aix*]
+     || [istarget arm*-*-*]
+     || [istarget strongarm*-*-*]
+     || [istarget fr30-*-*]
+} {
+    set extra_flags ""
+} else {
+    set extra_flags "-fpic"
+}
+dg-runtest $srcdir/$subdir/981006-1.c "-Wuninitialized -O2 $extra_flags" ""
+dg-finish
+
+# 921210-1
+set lines [gcc_target_compile $srcdir/$subdir/921210-1.c "" preprocess ""]
+set lines [prune [split [prune_warnings [prune_gcc_output $lines]] "\n"] ""]
+set line [lindex $lines [expr [llength $lines]-1]]
+regsub -all " " $line "" clean
+if [expr [string compare $clean "(a->f+1)+1"]==0] then {
+    pass "921210-1.c"
+} else {
+    fail "921210-1.c"
+}
+
+# 920521-1
+c-torture 920521-1.c "-S"
+
+# 920520-1
+c-torture 920520-1.c "-S"
+
+# 920717-1
+if [isnative] then {
+    set lines [gcc_target_compile "$srcdir/$subdir/920717-x.c" "920717-x.o" object {additional_flags="-w"}]
+    if ![string match "" $lines] then {
+	fail "920717-x.c"
+    } else {
+	# This is a completely bogus test. Sorry.
+	catch exec "rm -f 920717-y.o"
+	send_log "cc -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null\n"
+	catch exec "cc -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null"
+	if ![file exists "920717-y.o"] then {
+	    send_log "c89 -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null\n"
+	    catch exec "c89 -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null"
+	}
+	if [file exists "920717-y.o"] then {
+	    set lines [gcc_target_compile "920717-y.o x.o" "x" executable ""]
+	    if [string match "" $lines] then {
+		pass "920717-1.c"
+	    } else {
+		fail "920717-1.c"
+	    }
+	}
+    }
+}
+
+# 920730-1
+if [isnative] then {
+    c-torture "920730-1.c"
+    c-torture "920730-1.c" "-traditional"
+}
+
+# 920413-1
+c-torture 920413-1.c "-Wtraditional"
+
+# 930510-1
+dg-init
+dg-runtest $srcdir/$subdir/930510-1.c "" ""
+dg-finish
+
+# 951130-1
+c-torture 951130-1.c "-Werror"
+
+# 960224-1
+c-torture 960224-1.c "-E -ansi -pedantic-errors"
+
+# 960224-2
+#c-torture 960224-2.c "-E -ansi -pedantic-errors"
+
+c-torture-execute $srcdir/$subdir/eeprof-1.c "-finstrument-functions"
--- gcc/testsuite/gcc.dg/noncompile/920923-1.c.jj	Thu Jun 29 21:55:26 2000
+++ gcc/testsuite/gcc.dg/noncompile/920923-1.c	Mon Feb  5 14:56:14 2001
@@ -96,6 +96,8 @@ int hash_size;
      }
 }
 
+extern void *calloc(__SIZE_TYPE__, __SIZE_TYPE__);
+
 void
 init_mem()
 {
--- gcc/testsuite/lib/consistency.exp.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/lib/consistency.exp	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,172 @@
+# Copyright (C) 1998,1999 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written for by Valdimir N. Makarov
+# (vmakarov@cygnus.com) on the base of gcc.exp.
+
+# This file is loaded by the tool init file (eg: unix.exp).  It
+# provides default definitions for consistency_start, etc. and other
+# supporting cast members.
+
+# These globals are used by consistency_start if no compiler arguments
+# are provided.  They are also used by the various testsuites to
+# define the environment: where to find stdio.h, libc.a, etc.
+
+# we want to use libgloss so we can get find_gcc.
+load_lib libgloss.exp
+
+#
+# GCC_UNDER_TEST is the compiler under test.
+#
+
+#
+# consistency_init -- called at the start of each .exp script.
+#
+# There currently isn't much to do, but always using it allows us to
+# make some enhancements without having to go back and rewrite the scripts.
+#
+
+set consistency_initialized 0
+
+proc consistency_init { args } {
+    global tmpdir
+    global libdir
+    global gluefile
+    global consistency_initialized
+    global GCC_UNDER_TEST
+    global TOOL_EXECUTABLE
+
+    if { $consistency_initialized == 1 } { return; }
+
+    if ![info exists GCC_UNDER_TEST] {
+	if [info exists TOOL_EXECUTABLE] {
+	    set GCC_UNDER_TEST $TOOL_EXECUTABLE;
+	} else {
+	    set GCC_UNDER_TEST "[find_gcc]"
+	}
+    }
+
+    if ![info exists tmpdir] then {
+	set tmpdir /tmp
+    }
+
+    if { [target_info needs_status_wrapper]!="" && ![info exists gluefile] } {
+	if [target_info exists uses_underscores] {
+	    set flags "additional_flags=-DUNDERSCORES"
+	} else {
+	    set flags ""
+	}
+	if [target_info exists wrap_compile_flags] {
+	    lappend flags "additional_flags=[target_info wrap_compile_flags]";
+	}
+	if { [target_compile ${libdir}/testglue.c ${tmpdir}/testglue.o object $flags] == "" } {
+	    set gluefile [remote_download host ${tmpdir}/testglue.o testglue.o];
+	}
+    }
+}
+
+proc gcc_target_compile { source dest type options } {
+    global tmpdir;
+    global gluefile wrap_flags;
+    global GCC_UNDER_TEST
+    global TOOL_OPTIONS
+
+    if { [target_info needs_status_wrapper]!="" && [info exists gluefile] } {
+	lappend options "libs=${gluefile}"
+	lappend options "ldflags=$wrap_flags"
+    }
+
+    if [target_info exists gcc,stack_size] {
+	lappend options "additional_flags=-DSTACK_SIZE=[target_info gcc,stack_size]"
+    }
+    if [target_info exists gcc,no_trampolines] {
+	lappend options "additional_flags=-DNO_TRAMPOLINES"
+    }
+    if [target_info exists gcc,no_label_values] {
+	lappend options "additional_flags=-DNO_LABEL_VALUES"
+    }
+    if [info exists TOOL_OPTIONS] {
+	lappend options "additional_flags=$TOOL_OPTIONS"
+    }
+    if [target_info exists gcc,no_varargs] {
+	lappend options "additional_flags=-DNO_VARARGS"
+    }
+    if [target_info exists gcc,timeout] {
+	lappend options "timeout=[target_info gcc,timeout]"
+    }
+    lappend options "compiler=$GCC_UNDER_TEST"
+    return [target_compile $source $dest $type $options]
+}
+
+#
+# consistency_finish -- called at the end of every .exp script that calls
+# consistency_init
+#
+# The purpose of this proc is to hide all quirks of the testing
+# environment from the testsuites.  It also exists to undo anything
+# that consistency_init did (that needs undoing).  #
+
+proc consistency_finish { } {
+    # The testing harness apparently requires this.
+    global errorInfo;
+
+    if [info exists errorInfo] then {
+	unset errorInfo
+    }
+
+    # Might as well reset these (keeps our caller from wondering whether
+    # s/he has to or not).
+    global prms_id bug_id
+    set prms_id 0
+    set bug_id 0
+}
+
+proc consistency_exit { } {
+    global gluefile;
+
+    if [info exists gluefile] {
+	file_on_build delete $gluefile;
+	unset gluefile;
+    }
+}
+    
+# If this is an older version of dejagnu (without runtest_file_p),
+# provide one and assume the old syntax: foo1.exp bar1.c foo2.exp bar2.c.
+# This can be deleted after next dejagnu release.
+
+if { [info procs runtest_file_p] == "" } then {
+    proc runtest_file_p { runtests testcase } {
+	if { $runtests != "" && [regexp "\[.\]\[cC\]" $runtests] } then {
+	    if { [lsearch $runtests [file tail $testcase]] >= 0 } then {
+		return 1
+	    } else {
+		return 0
+	    }
+	}
+	return 1
+    }
+}
+
+# Provide a definition of this if missing (delete after next dejagnu release).
+
+if { [info procs prune_warnings] == "" } then {
+    proc prune_warnings { text } {
+	return $text
+    }
+}
--- gcc/testsuite/g++.old-deja/g++.brendan/misc12.C.jj	Mon Feb  5 14:35:34 2001
+++ gcc/testsuite/g++.old-deja/g++.brendan/misc12.C	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,16 @@
+// GROUPS passed miscellaneous
+extern "C" void exit (int);
+extern "C" int printf (const char *, ...);
+
+/* Make sure cp-lex.c handles these properly--if this links, that means
+   it emitted the strings instead of __FUNCTION__.0, etc.  */
+
+int
+main()
+{
+  const char *a = __FUNCTION__;
+  const char *b = __PRETTY_FUNCTION__;
+
+  printf ("PASS\n");
+  exit (0);
+}
--- gcc/testsuite/g++.old-deja/g++.other/mangle3.C.jj	Mon Feb  5 16:32:52 2001
+++ gcc/testsuite/g++.old-deja/g++.other/mangle3.C	Mon Feb  5 16:33:53 2001
@@ -0,0 +1,42 @@
+// Test for proper mangling by setting up name clashes.
+// Special g++ Options: -fsquangle
+
+class A;
+typedef A A2;
+typedef int I;
+typedef void V;
+typedef I I2;
+
+void f (const A2&, int, const A2&, const A&) { } // ERROR - name clash
+int f__FRC1AiRCB0n1 = 0; // ERROR - name clash
+
+void f (int, long, int, I) { } // ERROR - name clash
+int f__Filii = 0; // ERROR - name clash
+
+void f (I, float, I, I2) { } // ERROR - name clash
+int f__Fifii = 0; // ERROR - name clash
+
+void f (void*, float, void*, V*) { } // ERROR - name clash
+int f__FPvfPvn1 = 0; // ERROR - name clash
+
+void f (wchar_t) { } // ERROR - name clash
+int f__Fw = 0; // ERROR - name clash
+
+void f(int, A, A2, A) { } // ERROR - name clash
+int f__FiG1An2 = 0; // ERROR - name clash
+
+void f(const A2&, const A2&, const A2&, const A2&,
+       int&) { } // ERROR - name clash
+int f__FRC1An3Ri = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&,
+       int&) { } // ERROR - name clash
+int f__FRC1AiRCB0n2Ri = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&, int&, int&,
+       int&) { } // ERROR - name clash
+int f__FRC1AiRCB0n2Rin2 = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&, int, int,
+       int) { } // ERROR - name clash
+int f__FRC1AiRCB0n2in2 = 0; // ERROR - name clash
--- gcc/testsuite/g++.old-deja/g++.pt/friend19.C.jj	Mon Feb  5 14:35:36 2001
+++ gcc/testsuite/g++.old-deja/g++.pt/friend19.C	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,26 @@
+// Build don't link:
+
+template <class U>
+class S1
+{
+  template <class T>
+  friend class S2;
+
+  static int i;
+};
+
+
+template <class T>
+class S2
+{
+public:
+  static void f() { S1<T>::i = 3; }
+};
+
+
+void g()
+{
+  S2<double>::f();
+  S2<long>::f();
+}
+
--- gcc/testsuite/gcc.failure/940409-1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.failure/940409-1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,3 @@
+struct S { volatile int field; };
+int f (register struct S arg);
+int g (register struct S);
--- gcc/testsuite/gcc.failure/940409-1.x.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.failure/940409-1.x	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,6 @@
+# gcc doesn't handle compile/940409-1.cexp properly, but it's an obscure bug
+# so rather than constantly seeing it fail, just record it as expected to
+# fail.
+
+set torture_compile_xfail "*-*-*"
+return 0 ;# `0' says we didn't handle the testcase ourselves so continue
--- gcc/testsuite/gcc.failure/failure.exp.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.failure/failure.exp	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,58 @@
+#
+# Expect driver script for GCC Regression Tests
+#   Copyright (C) 1993, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+#
+
+#
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# This loop will run c-torture on any *.c file found in this directory.
+# If a *.c has a corresponding *.exp file, then the test is skipped as
+# as the *.exp will drive the test itself. I did things this way so that
+# generic tests did not need a seperate .exp for it. Only the tests that 
+# required unique options would need it's own .exp file.
+#
+
+#
+# The main logic is in ../lib/c-torture.exp. This was done to eliminate
+# redundant code that otherwise lived in each of these driver files.
+#
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    
+    # let c-torture.exp figure out the path. this lets users add new
+    # special tests without having to remeber to use $srcdir/$subdir
+    
+    if [file exists [file rootname $testcase].exp] then {
+	verbose "INFO:\"[file rootname $testcase].exp\"exists, skipping test" 1
+	continue
+    } else {
+	c-torture [file tail $testcase]
+    }
+}
+
--- gcc/testsuite/gcc.wendy/gnu1.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu1.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,17 @@
+unsigned char	msgi[10] = {0x10, 0x09, 0x88, 0xaa, 0x22, 0x09};
+#define	MAGIC	0125252		/* checksum is subtracted from this */
+
+int
+main()
+{
+	unsigned short pktsum, oursum;
+
+	pktsum = msgi[2] + (msgi[3] << 8);
+
+	/* Check checksums for control packets */
+	oursum = MAGIC - msgi[4];
+	if (pktsum != oursum)
+		printf("control checksum bad %x %x\n", pktsum, oursum);
+	else
+		printf("Test passed\n");
+}
--- gcc/testsuite/gcc.wendy/gnu10.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu10.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,11 @@
+/*
+ * Unsigned bitfields now promote to signed ints in expressions, grumble.
+ */
+main() {
+	struct s {unsigned i9:9, i1:1;} x;
+	x.i9 = 0;
+	if ( x.i9 <= -139 )
+		printf("Failed...\n");
+	else
+		printf("Test passed\n");
+}
--- gcc/testsuite/gcc.wendy/gnu11.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu11.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,8 @@
+/* DEJAGNU_OUTPUT:"Failed (if it compiled at all)..." */
+
+main() {
+	int s;
+	
+	s = sizeof main;
+	printf("Failed (if it compiled at all)...\n");
+}
--- gcc/testsuite/gcc.wendy/gnu12.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu12.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,36 @@
+/*
+Deceived: by hoptoad.uucp (1.1/SMI-3.0DEV3)
+	id AA08037; Wed, 1 Apr 87 03:40:07 PST
+Message-Id: <8704010914.AA23555@prep.ai.mit.edu>
+Date: 31 Mar 1987 2359-PST (Tuesday)
+From: Malcolm Wing <wing@sonoma.stanford.edu>
+To: bug-gcc@prep.ai.mit.edu
+Subject: Clobber nil bug and Tail recursion bug
+
+BUG 2
+    When compiling Ackerman for the vax it tries to remove the
+tail recursion. However the tail recursive call contains another
+call so the update (used to be parameter passing) can't be done
+until the imbedded call returns.
+
+SOURCE
+
+/* Ackerman's function */
+main()
+{
+	int i;
+
+	i = A(3,6);
+	if (i == 509)
+		printf("Test passed\n");
+	else
+		printf("FAILED ackerman's(3, 6): %d\n", i);
+}
+
+A(x,y)
+int x,y;
+{
+    if(x==0) return(++y);
+    if(y==0) return(A(--x,1));
+    return(A(x-1,A(x,--y)));
+    }
--- gcc/testsuite/gcc.wendy/gnu13.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu13.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,92 @@
+/*
+Date: Tue, 21 Apr 87 09:58:10 PDT
+From: aks@acc-sb-unix.arpa (Alan Stebbens)
+To: bug-gcc@PREP.AI.MIT.EDU
+Subject: Optimizer doesn't.
+
+Dear GCC guys:
+
+The following simple C program illustrates a problem with the
+current version of GCC.  What happens is that D3 is used doubly:
+once for loop limit testing, and once for long constant stores.
+Also, a loop limit test is being performed for the first iteration
+even when both the initial value and the ending values are known
+constants.  Most optimizers can avoid the initial test if these
+values are known.
+
+Thanks for your time.
+
+Alan Stebbens (aks@acc-sb-unix.ARPA)
+
+==================== tst1.c ====================
+*/
+int array[100];
+int darray[10][10];
+
+main()
+{
+   register int i, j;
+   for (i = 0; i < 100; i++) array[i] = 3;
+   for (i = 0; i < 10; i++)
+      for (j = 0; j < 10; j++)
+	 darray[i][j] = 3;
+   return 0;
+}
+
+/*
+==================== tst1.s ====================
+.comm _array,400
+.comm _darray,400
+.globl _main
+.text
+	.even
+_main:
+	link a6,#0
+	moveml #0x3030,sp@-
+	clrl d2
+	lea _array,a0
+	moveq #100,d3	<------ D3 now has limit of the test
+	cmpl d2,d3
+	jle L19
+L2:
+	moveq #3,d3	<----- D3 is being reused!!
+	movl d3,a0@(d2:l:4)
+	addql #1,d2
+	moveq #100,d3	<----- D3 is being reloaded!
+	cmpl d2,d3
+	jgt L2
+L19:
+	clrl d2
+	lea _darray,a2
+	moveq #10,d3
+	cmpl d2,d3
+	jle L18
+L7:
+	clrl d1
+	movl d2,d0
+	asll #5,d0
+	movl d0,a3
+	lea a3@(d2:l:8),a1
+	moveq #10,d3
+	cmpl d1,d3
+	jle L17
+L10:
+	lea a1@(d1:l:4),a0
+	moveq #3,d3
+	movl d3,a2@(a0:l)
+	addql #1,d1
+	moveq #10,d3
+	cmpl d1,d3
+	jgt L10
+L17:
+	addql #1,d2
+	moveq #10,d3
+	cmpl d2,d3
+	jgt L7
+L18:
+	moveml a6@(-16),#0xc0c
+	unlk a6
+	rts
+
+Alan Stebbens (aks@acc-sb-unix.ARPA)
+*/
--- gcc/testsuite/gcc.wendy/gnu14.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu14.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,23 @@
+/*
+Return-Path: <ucsfcgl!TOR.NTA.NO!H_Eidnes%vax.runit.unit.uninett>
+Date: Tue, 23 Jun 87 17:17:38 +0200
+From: H}vard Eidnes <ucsfcgl!TOR.NTA.NO!H_Eidnes%vax.runit.unit.uninett>
+To: <bug-gcc@prep.ai.mit.edu>
+Message-Id: <2178:H_Eidnes@vax.runit.unit.uninett>
+Subject: Spurious error-message (?) from GCC
+
+The following is an exerpt from a header file from the X Window
+System, version 10r3.
+
+GCC (version 1.5) says:
+/usr/include/X/Xlib.h:108: declaration of table invalidly omits array size
+*/
+
+typedef struct _x_assoc_table {
+	struct _x_assoc (*table)[];	/* Array of association queues. */
+	int size;			/* Table size. */
+} XAssocTable;
+
+main() {
+	printf("Test passed\n");
+}
--- gcc/testsuite/gcc.wendy/gnu15.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu15.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,30 @@
+/*
+Date: Sun, 5 Jul 87 18:24:54 PDT
+From: andy@csvax.caltech.edu (Andy Fyfe)
+To: bug-gcc@prep.ai.mit.edu
+Subject: unsigned -> float conversion
+*/
+
+main()
+{
+    unsigned u = 0x80000000;
+
+    printf("(f)u = %g\n", (float)u);
+    printf("(f)(u)0x80000000 = %g\n", (float)(unsigned)0x80000000);
+
+    exit(0);
+}
+
+/*
+Using 68020/68881 the above gives:
+
+(f)u = 2.14748e+09
+(f)(u)0x80000000 = -2.14748e+09
+
+Using 68020/soft-float the above gives:
+
+(f)u = -2.14748e+09
+(f)(u)0x80000000 = -2.14748e+09
+
+gcc, version 1.6, compiled on a sun3 by gcc itself.
+*/
--- gcc/testsuite/gcc.wendy/gnu16.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu16.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,16 @@
+int install = !0;	/* Gcc 1.16 said "initializer is not constant" */
+			/* Gcc 1.17 gets wrong answer! */
+char foo = !1;
+int bar = !3.14156;	/* SunOS 3.3 cc said "Illegal initialization" */
+int pno = ! &bar;	/* Gcc 1.17 said "initializer for static variable
+			   uses complex arithmetic" */
+int pyes = !(char *)0;
+
+main() {
+	if (install && !foo && !bar && pyes && !pno)
+		printf("Test passed\n");
+	else
+		printf("FAILED, install=%d, foo=%d, bar=%d, pno=%d, pyes=%d\n",
+			install, foo, bar, pno, pyes);
+}
+
--- gcc/testsuite/gcc.wendy/gnu17.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu17.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,169 @@
+#if 0
+/*
+Date: Mon, 17 Aug 87 09:03:50 PDT
+From: bruce@stride.stride.com (Bruce Robertson)
+To: bug-gcc@prep.ai.mit.edu
+Subject: Optimizer bug in gcc 1.x
+
+I found the cause of the optimizer bug that I've been sending you.  It
+occurs because you scan for the first and last occurances of registers
+before common subexpression processing, but cse can change these
+occurances.  The bug appears in the example program because loop
+optimization removes a load of "mem" into a pseudo-register, because
+based on the information of the register scan it thinks that there are
+no more appearances of the pseudo-register.  Cse added a reference,
+however, and this information is not placed in regno_last_uid[].  The
+solution seems to be to call reg_scan() again after calling
+cse_main().  It fixed the bug anyway, and didn't seem to cause
+anything bad.
+
+Diffs for the fix, and the original sample program follow.
+
+
+Diffs:
+======================================================================
+*** /tmp/,RCSt1a00495	Thu Aug 13 13:09:01 1987
+--- toplev.c	Thu Aug 13 13:08:39 1987
+***************
+*** 776,781 ****
+--- 776,786 ----
+  
+        TIMEVAR (cse_time, tem = cse_main (insns, max_reg_num ()));
+  
++       /* We need to scan for registers again, because common subexpression
++ 	 elimination could have rearranged the first and last occurrances
++ 	 of registers. */
++       TIMEVAR (cse_time, reg_scan (insns, max_reg_num ()));
++ 
+        if (tem)
+  	TIMEVAR (jump_time, jump_optimize (insns, 0, 0));
+      }
+
+
+
+Sample program:
+======================================================================
+#endif
+
+typedef unsigned char quarterword;
+typedef unsigned short halfword;
+
+typedef union
+{ 
+    struct { 
+        halfword    lh; 
+        halfword    rh; 
+    } hh1; 
+    struct { 
+        quarterword b0; 
+        quarterword b1; 
+        halfword    rh; 
+    } hh2; 
+}
+    two_halves;
+
+typedef struct
+{ 
+    quarterword b0;
+    quarterword b1;
+    quarterword b2;
+    quarterword b3;
+}
+    four_quarters;
+
+typedef union
+{ 
+    int         i;   
+    float      gr;  
+    two_halves      hh;  
+    four_quarters   qqqq;
+}
+    memory_word;
+
+memory_word     mem[10];
+
+unsigned int fewest_demerits;
+unsigned short best_bet = 0;
+unsigned short best_line = -1;
+
+
+void
+foo(r)
+	unsigned short r;
+{
+
+	do {
+		if (mem[r].hh.hh2.b0 != 2 &&
+		    mem[(r) + 2].i < fewest_demerits) {
+                        best_bet = r;
+		}
+		r = mem[r].hh.hh1.rh;
+	} while (r != (65501 - 7));
+
+	/*
+	 * This is the statement that is causing trouble.  See the comment
+	 * in the assembly code below.
+	 */
+	best_line = mem[best_bet + 1].hh.hh1.lh;
+}
+
+main()
+{
+	mem[0].hh.hh2.b0 = 0;
+	mem[0].hh.hh1.rh = 65501-7;
+	mem[1].hh.hh1.lh = 456;
+	mem[2].i = 30;
+	foo(0);
+	if (best_line == 456)
+		printf("Test passed\n");
+	else
+		printf("Test failed, best_line = %d\n", best_line);
+}
+
+/*
+
+#NO_APP
+.comm _fewest_demerits,4
+.comm _best_bet,2
+.comm _best_line,2
+.globl _foo
+.text
+	.even
+_foo:
+	link a6,#0
+	moveml #0x3000,sp@-
+	movew #1,d0
+	clrl d1
+	clrl d2
+	lea _mem,a0
+L2:
+	movew d0,d1
+	cmpb #2,a0@(d1:l:4)
+	jeq L4
+	movel a0@(8,d1:l:4),d3
+	cmpl _fewest_demerits,d3
+	jcc L4
+	movew d0,_best_bet
+L4:
+	movew d0,d2
+	movew a0@(2,d2:l:4),d0
+	cmpw #65494,d0
+	jne L2
+	clrl d0
+	movew _best_bet,d0
+
+|
+|	Where did this reference (below) to A1 come from?  It should be A0,
+|	since that still points to "mem".  A1 is never set in the code
+|	above.
+|
+|	When this code fragment is in place in Common Tex (in function
+|	"line_break()" in file "par.c") the reference is to -4(fp)
+|	rather than A1.
+|
+
+	movew a1@(4,d0:l:4),_best_line
+	moveml a6@(-8),#0xc
+	unlk a6
+	rts
+*/
--- gcc/testsuite/gcc.wendy/gnu18.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu18.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,46 @@
+/*
+Date: Sat, 5 Sep 87 00:34:13 PDT
+From: gnu (John Gilmore)
+To: rms
+Subject: Stack adjustment bug in 'continue' -- gcc 1.10+
+
+Compiling the following simplified program with or without -O produces
+bad code.  The 'continue' compiles to a jump to a label which PRECEDES
+the stack adjust for the printf at the end of the loop.  This makes the
+stack pointer walk up each time around the loop.  If you compile without
+-O, "foo" gets allocated on the stack and the debug printf fires.
+Compiled with -O, it coredumps before printing.  Compiled on a working
+compiler, it loops forever.
+
+I have installed the bugfix for while loops posted to bug-gcc; it fails
+with or without the bugfix.
+*/
+
+int	tty;
+
+iscmd() {
+	static int counter;
+
+	if (counter++ < 10000) return 0;
+	printf("Test passed\n");
+	exit(0);
+}
+
+void
+main()
+{
+	int foo = 0;
+
+	for ( ;; ) {
+		if (foo != 0) printf("***BUG*** foo=%x\n", foo);
+		if (!tty) {
+			if (!iscmd ())
+				continue;
+			foo = 1;
+		}
+
+		printf("**BUG** Past iscmd\n");
+	}
+
+	return;
+}
--- gcc/testsuite/gcc.wendy/gnu19.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu19.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,26 @@
+/*
+Date: Wed, 7 Oct 87 11:54:57 PDT
+From: faustus%ic.Berkeley.EDU@cad.Berkeley.EDU (Wayne A. Christopher)
+To: bug-gcc@PREP.AI.MIT.EDU
+Subject: GNU CC bug
+
+The following fragment of code causes the message "xx.c:7: parse error" to
+be printed:
+*/
+	typedef struct foo {
+		int i;
+	} foo;
+
+	typedef struct bar {
+		foo *foo;
+	} bar;
+
+main(){
+	printf("Test passed (if it compiled)\n");
+}
+/*
+I can't find anything in the ANSI standard saying that a structure tag can't
+be the same as a typedef name.
+
+	Wayne
+*/
--- gcc/testsuite/gcc.wendy/gnu2.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu2.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,122 @@
+/*
+ * Causes gnu cc 1.14 to coredump.  Not sure why.
+ * An excerpt from PD tar's "list.c" file.
+ */
+typedef	unsigned char	u_char;
+typedef	unsigned short	u_short;
+typedef	unsigned int	u_int;
+typedef	unsigned long	u_long;
+typedef	unsigned short	ushort;		 
+typedef	unsigned int	uint;		 
+
+
+
+
+
+
+
+
+typedef	struct	_physadr { short r[1]; } *physadr;
+typedef	struct	label_t	{
+	int	val[13];
+} label_t;
+
+typedef	struct	_quad { long val[2]; } quad;
+typedef	long	daddr_t;
+typedef	char *	caddr_t;
+typedef	u_long	ino_t;
+typedef	long	swblk_t;
+
+typedef	long	time_t;
+typedef	short	dev_t;
+typedef	int	off_t;
+typedef long	key_t;
+
+typedef	struct	fd_set { int fds_bits[1]; } fd_set;
+
+
+struct	stat {
+	dev_t	st_dev;
+	ino_t	st_ino;
+	unsigned short st_mode;
+	short	st_nlink;
+	short	st_uid;
+	short	st_gid;
+	dev_t	st_rdev;
+	off_t	st_size;
+	time_t	st_atime;
+	int	st_spare1;
+	time_t	st_mtime;
+	int	st_spare2;
+	time_t	st_ctime;
+	int	st_spare3;
+	long	st_blksize;
+	long	st_blocks;
+	long	st_spare4[2];
+};
+
+union record {
+	char		charptr[512 ];
+	struct header {
+		char	name[100 ];
+		char	mode[8];
+		char	uid[8];
+		char	gid[8];
+		char	size[12];
+		char	mtime[12];
+		char	chksum[8];
+		char	linkflag;
+		char	linkname[100 ];
+		char	magic[8];
+		char	uname[32 ];
+		char	gname[32 ];
+		char	devmajor[8];
+		char	devminor[8];
+	} header;
+};
+long from_oct();			 
+
+decode_header(header, st, stdp, wantug)
+	register union record	*header;
+	register struct stat	*st;
+	int	*stdp;
+	int	wantug;
+{
+
+	st->st_mode = from_oct(8,  header->header.mode);
+	st->st_mtime = from_oct(1+12, header->header.mtime);
+	
+	if (0==strcmp(header->header.magic, 	"ustar  "	)) {
+		 
+		*stdp = 1;
+		if (wantug) {
+			st->st_uid = finduid(header->header.uname);
+			st->st_gid = findgid(header->header.gname);
+		}
+		switch  (header->header.linkflag) 
+		case 	'4'		: case 	'3'		:
+		    st->st_rdev = ((dev_t)(((from_oct(8, header->header.devmajor))<<8) | (
+			 		  from_oct(8, header->header.devminor)))) ;
+	} else {
+		*stdp = 0;
+		st->st_uid = from_oct(8,  header->header.uid);
+		st->st_gid = from_oct(8,  header->header.gid);
+		st->st_rdev = 0;
+	}
+}
+
+main(){
+	printf("Test passed (if it compiled at all)\n");
+}
+
+long from_oct(x)
+	char *x;
+{
+	return 0;
+}
+
+int finduid(x) char *x;
+{	return 0; }
+
+int findgid(x) char *x;
+{	return 0; }
--- gcc/testsuite/gcc.wendy/gnu20.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu20.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,69 @@
+/*
+Return-Path: <ucsfcgl!reagan.ai.mit.edu!RUTGERS.EDU!RUTGERS.EDU!uiucdcs!uiucuxc!sys1!sneaky!gordon>
+Date: Tue Dec 15, 1987 at 10:25:42 cst
+From: uiucdcs!uiucuxc!sys1!sneaky!gordon@rutgers.edu (Gordon Burditt)
+Message-Id: <8712151625.AA15898@sneaky.UUCP>
+To: uiucdcs!uiucuxc!sys1!techsup!vaxnix!ron@rutgers.edu,
+        bug-gcc@prep.ai.mit.edu
+Subject: gcc bug
+Sent: Tue Dec 15, 1987 at 10:25:42 cst
+
+I have been asked to pass along this bug report for gcc 1.15.
+I am having trouble figuring out from the ANSI spec whether this really
+is a bug or not.  ANSI says that side effects caused by function argument
+evaluation must be complete by the time the call is done, but how about side 
+effects in evaluating the function address?
+
+From: ron@vaxnix.tandy.COM (Ron Light)
+Date: Sat, 12 Dec 87 7:50:53 CST
+*/
+
+typedef int (*Inst)();		/* machine instruction */
+#define STOP (Inst)(0)
+
+Inst *pc;			/* program counter during execution */
+
+execute(p)			/* run the machine */
+Inst *p;
+{
+	for(pc = p; *pc != STOP;)
+		(*(*pc++))();
+}
+
+int inst();
+Inst instrs[] = {inst, inst, inst, STOP};
+int inst() {
+	if (pc == &instrs[1])
+		printf("Test passed\n");
+	else
+		printf("FAILED, pc = %x, instrs = %x\n", pc, instrs);
+	exit(0);
+}
+main()
+{
+
+	execute(instrs);
+}
+/*
+code produced by gcc:
+.text
+	.even
+.globl _execute
+_execute:
+	link a6,#0
+	movl a6@(8),_pc
+	jra L2
+L5:
+	movl _pc,a0
+	movl a0@,a0        ;<---------------------------+
+	jbsr a0@           ;                            |
+	addql #4,_pc       ; This should be here--------+
+L2:
+	movl _pc,a0
+	tstl a0@
+	jne L5
+	unlk a6
+	rts
+.comm _pc,4
+
+*/
--- gcc/testsuite/gcc.wendy/gnu21.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu21.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,30 @@
+/*
+Message-Id: <8712292244.AA24155@prep.ai.mit.edu>
+Date: Mon, 28 Dec 87 21:05:20 PST
+From: Greg Satz <satz@clutter.cisco.com>
+To: bug-gcc@prep.ai.mit.edu
+Subject: Error handling bug?
+
+The following program causes cc1 to make a core file.  Since it was
+caused by a syntax error, I didn't spend that much time tracking it
+down.  I was able to reduce the example to this small result.  Could
+someone check to see if this bug exists in the Vax and Sun versions as
+well and let me know?  Thanks!
+*/
+
+int global;
+main()
+{
+    int ch;
+
+  if (global) {
+    printf("here");
+  } else {
+    if (((ch & 0x7f) == 0)) && (ch & 1)) { /* syntax error here */
+	if (!ch)
+	    return(0);
+	ch = 0;
+    }
+  }
+}
+
--- gcc/testsuite/gcc.wendy/gnu22.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu22.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,57 @@
+/*
+From ptsfa!ames!sdcsvax!nosc!cod!owen Mon Dec 28 14:54:53 1987
+From: owen@cod.NOSC.MIL (Wallace E. Owen)
+Newsgroups: comp.lang.c
+Subject: msc bitfield bug
+Message-ID: <934@cod.NOSC.MIL>
+Date: 28 Dec 87 22:54:53 GMT
+Organization: Naval Ocean Systems Center, San Diego
+
+The following small bug in Microsoft 'C' (4.0) handling of forcing
+a bitfield to the next int or long was revealed while developing a Large
+piece of software. It's in the form of a small program which reveals the
+bug:
+
+/*
+   This short program displays a bug in MS C buildout of bitfield expressions.
+   Problem: Forcing bit field alignment to the next unsigned int or unsigned
+   long works if the next statement is a bitfield expression, but if it's
+   a unsigned long for instance, the padding ':0;' forces an extra item to
+   be allocated BETWEEN the two expressions. Must be the method used
+   to force bitfield to the next unsigned int or unsigned long. Should check
+   that indeed the next statement IS a bitfield expression.
+*/
+
+struct testa			/* 8 bytes */
+{
+	unsigned long
+		a: 5, b: 5, c: 5, d: 5, e: 5, : 0;
+	unsigned long
+		f: 8, g: 8, h: 8, i: 8;
+};
+
+struct testb				/* Should be 8 bytes, but it's 12! */
+{
+	unsigned long
+		a: 5, b: 5, c: 5, d: 5, e: 5, : 0;
+	unsigned long f;
+};
+
+main()
+{
+	/* Print sizes of things */
+	if (sizeof (struct testa) == sizeof (struct testb)) {
+		printf("Test passed\n");
+	} else {
+		printf("Size of struct testa: %u\n", sizeof( struct testa));
+		printf("Size of struct testb: %u\n", sizeof( struct testb));
+	}
+}
+
+/*
+I'm going to try this with 5.0- Also, while at the c++ conference in
+Santa Fe, met the author of MSC 5.0's front end, and showed him this code.
+		-- Wallace Owen
+		(owen@cod.nosc.mil)
+		(619) 553-3567
+*/
--- gcc/testsuite/gcc.wendy/gnu23.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu23.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,60 @@
+/* From Sun-Spots v6n11
+Date:    Fri, 22 Jan 88 10:07:18 EST
+From:    im4u!rutgers!rochester!srs!matt@ut-sally.UUCP
+Subject: Bug in C compiler
+
+We have had a bug in our main signal analysis tool for well over a year.
+Occasionally, and apparently w/o any regularity, one of the graphs (a
+raster display of FFTs of an input signal) would produce what looked like
+garbage, but tended to follow the basic trend of the input data.
+Recompiling the tool sometimes changed the frequency of occurance and with
+the latest changes, it tended to occur quite often.  Well, I have finally
+tracked it down to a compiler problem and this bug will bother us no
+more...
+
+Release:  Sun OS 3.2
+Systems:  Sun3, Sun2
+Comment:  The following program outputs (erroneously) 0xff00 for the
+	  second call to screwit().  Basically, the compiler fails to
+	  clear the upper half of "d7" before adding it into "a".
+	  "a" can be a signed or unsigned short.  If "a" is an int
+	  (long), it appears to work correctly.
+
+gnu@toad.com comment:  Appears to only fail this with without -O, probably
+	because the stores to d7 in main() are removed by c2.
+*/
+#include <stdio.h>
+static int fail;
+
+main()
+{
+    register short d7;
+    unsigned char b = 0;
+
+    d7 = 0x00ff;
+    screwit(&b);
+    d7 = 0xffff;
+    screwit(&b);
+    if (!fail)
+	printf("Test passed\n", d7);
+    else
+	printf("Test FAILED\n", d7);
+}
+
+screwit(b)
+register unsigned char *b;
+{
+    register unsigned char d7;
+    register unsigned short a = 0;
+
+    d7 = *b; 
+    a += (unsigned short) d7;
+    if (a == 0) return;
+    printf("C: 0x%04x\n", a);
+    fail++;
+}
+
+/*
+UUCP:	{allegra,rutgers,ames}!rochester!srs!matt	Matt Goheen
+	"First the pants, THEN the shoes."		S.R. Systems
+*/
--- gcc/testsuite/gcc.wendy/gnu24.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu24.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,32 @@
+/* From Sun-Spots v6n12
+Date:    26 Jan 88 15:58:58 CST (Tue)
+From:    uunet!mcrware!jejones@ut-sally.UUCP
+Subject: ?: vs. pointer to function "returning" void
+
+I find that on a Sun 3, the C compiler complains about code of the following
+form with a message "operands of : have incompatible types."  I don't think
+this is correct, because woof1 and woof2 are both pointers to functions
+"returning" void, so that (pointer to function returning void) should be
+the type of the actual parameter.  Right?
+
+Have other people seen this problem?  Is it, if it is indeed a problem
+with the Sun C compiler, fixed in some release?
+
+                James Jones
+*/
+
+void    woof1() {};
+void	woof2() {};
+
+main(i, argv)
+int     i;
+char **argv;
+{
+	bletch(i ? woof1 : woof2);
+	printf("Test passed (if it compiled at all)\n");
+}
+
+bletch(x)
+	void (*x)();
+{
+}
--- gcc/testsuite/gcc.wendy/gnu25.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu25.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,55 @@
+/*
+ * gnu25.c
+ *
+ * This was originally reported as a bug in the Sun C compiler in
+ * Sun-Spots, by ihnp4!stcvax!stc-auts!kak, but he forgot to declare
+ * double sqrt().  However, the code generated for the initialization
+ * by gcc-1.19 plus a fix, reuses fp0 for both arguments of the divide.
+ * oops!  the result is always 1!
+
+	John Gilmore, 16April88
+ * 
+ * showbug
+ * compile: cc showbug.c -o showbug -lm
+ */
+double sqrt();
+compare(a, b)
+	double a, b;
+{
+
+	if (a != b) return 1;		/* Not computed the same */
+	if (a > 0.014) return 1;	/* Wrong answer */
+	if (a < 0.012) return 1;	/* Wrong answer */
+	return 0;
+}
+main()
+{
+        float mean = 0.035000;
+        int samples = 200;
+        {
+                double sigma = sqrt( (mean*(1 - mean))/ samples);
+
+		if (compare(sigma, 
+                        sqrt((mean*(1 - mean))/ samples ))) {
+
+			printf("sigma = sqrt( (%f)/%d) ",
+				(mean*(1 - mean)), samples );
+			printf("= sqrt( %f ) ",
+				(mean*(1 - mean))/ samples );
+			printf("= %f ",
+				sqrt((mean*(1 - mean))/ samples ));
+			printf("= %f (!)\n", sigma );
+		} else {
+			printf("Test passed\n");
+		}
+        }
+}
+
+/* We'd like to link with -lm, but "runt" doesnt do this. */
+double sqrt(x) double x;
+{
+	/* Quick fakery. */
+	if (x > .000165 && x < .00017)	 /* arg is right */
+		return .0129951914;		/* Right result */
+	return 0;		/* CHeap imitation sqrt routine */
+}
--- gcc/testsuite/gcc.wendy/gnu26.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu26.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,53 @@
+/*
+Deceived: by hoptoad.uucp (1.1/SMI-3.0DEV3)
+	id AA08037; Wed, 1 Apr 87 03:40:07 PST
+Message-Id: <8704010914.AA23555@prep.ai.mit.edu>
+Date: 31 Mar 1987 2359-PST (Tuesday)
+From: Malcolm Wing <wing@sonoma.stanford.edu>
+To: bug-gcc@prep.ai.mit.edu
+Subject: Clobber nil bug and Tail recursion bug
+
+BUG 2
+    When compiling Ackerman for the vax it tries to remove the
+tail recursion. However the tail recursive call contains another
+call so the update (used to be parameter passing) can't be done
+until the imbedded call returns.
+
+SOURCE
+
+/* Ackerman's function */
+main()
+{
+	int i, j;
+
+	i = A(3,6);
+	j = B(3,6);
+	if (i == 509 && j == 509 && i == j)
+		printf("Test passed\n");
+	else
+		printf("FAILED ackerman's(3, 6): %d, %d\n", i, j);
+}
+
+A(x,y)
+int x,y;
+{
+    if(x==0) return(++y);
+    if(y==0) return(A(--x,1));
+    return(A(x-1,A(x,--y)));
+}
+
+/* This one is more in the true spirit of the original Algol code. */
+B(m,n)
+int m,n;
+{
+  return m==0 ? n+1 : n==0 ? B(m-1,1) : B(m-1,B(m,n-1));
+}
+
+/* Try it with subtract/add rather than ++ and -- */
+C(x,y)
+int x,y;
+{
+    if(x==0) return(y+1);
+    if(y==0) return(C(x-1,1));
+    return(C(x-1,C(x,y-1)));
+}
--- gcc/testsuite/gcc.wendy/gnu27.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu27.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,28 @@
+/* DEJAGNU_OUTPUT:"Test failed (if it compiles at all)" */
+
+/*
+ * This program should generate at least a warning; preferably an error.
+ */
+int *
+main()
+{ 
+   int local = 1; 
+
+   printf("Test failed (if it compiles at all)\n");
+
+   return &local;
+}
+
+/*
+ * RMS comments:
+ *
+Date: Sun, 18 Dec 88 14:39:18 EST
+From: rms@wheaties.ai.mit.edu (Richard Stallman)
+To: gnu@toad.com
+Subject: gcc-1.31 sparc test suite results
+
+I do not anticipate that gnu27.c will ever produce a warning
+message.  I can see kludgy ways to produce them in simple cases,
+but more complicated circumlocutions would avoid them.  In general
+the problem is uncomputable.
+ */
--- gcc/testsuite/gcc.wendy/gnu28.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu28.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,63 @@
+/*
+From: uunet!mcvax!sor.inria.fr!tiemann (Mike Tiemann)
+Date: Sun, 4 Sep 88 11:15:27 +0100
+
+I got all your tests working (except str1597a.c), and the compiler
+bootstrapping itself, and I thought I was done.  Then I remembered
+*my* favorite test program...which used to work, but now fails again.
+Here it is, for your collecting joy:
+
+[Altered in obvious ways to avoid using function prototypes -- gnu]
+*/
+
+/* a reasonably sized structure.  */
+typedef struct foo
+{
+  int x[57];
+} foo;
+
+int bad = 0;
+
+foo sum (x, y)
+  foo x; foo y;
+{
+  foo s;
+  int i;
+
+  for (i = 0; i < 57; i++)
+    {
+      if (x.x[i] != 1) {printf("sum x[%d] = %d\n", i, x.x[i]); bad++;}
+      if (y.x[i] != 2) {printf("sum y[%d] = %d\n", i, y.x[i]); bad++;}
+      s.x[i] = x.x[i] + y.x[i];
+    }
+  return s;
+}
+
+foo init (val)
+  int val;
+{
+  foo s;
+  int i;
+
+  for (i = 0; i < 57; i++)
+    s.x[i] = val;
+  return s;
+}
+
+main ()
+{
+  foo s;
+  foo t;
+  int i;
+
+  s = sum (init (1), init (2));
+  t = sum (init (1), init (2));
+
+  for (i = 0; i < 57; i++)
+    if (s.x[i] != 3 || t.x[i] != 3) {
+      printf ("failure at %i\n", i);
+      bad++;
+    }
+  if (bad) printf ("Failed %d ways.\n", bad);
+  else     printf ("Test passed.\n");
+}
--- gcc/testsuite/gcc.wendy/gnu29.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu29.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,80 @@
+/*
+Date: 25 Jan 89 14:43:05 GMT
+From: meyering@cs.utexas.edu  (Jim Meyering)
+Subject: 1.32 sun4os4 bug-- passing structures
+Message-Id: <150@ai.cs.utexas.edu>
+To: bug-gcc@prep.ai.mit.edu
+ */
+
+/*
+ *	gcc-1.32 (sun4-os4) has a problem passing structure arguments.
+ *
+ *	If the type FLT is changed to float, all problems disappear.
+ *
+ *	If PRINTF is defined and -O is *not* used, the program terminates
+ *	with a segmentation fault.  In all other cases I've tried, the
+ *	program runs, but the arguments to foo are not properly copied.  
+ *	To be precise, in foo, the value that one would normally expect
+ *	to find in b.y is overwritten with that of b.x. (see output in
+ *	comments below)
+ */
+
+typedef double FLT;
+typedef struct point { FLT x, y; } PT;
+
+#define N 4
+FLT x[N];
+
+#if defined(PRINTF)
+#define PRINT(a) for (i=0;i<N;i++) printf("%g ", (a)[i]); printf("\n");
+#endif
+
+#if defined(FPRINTF) || !defined(PRINTF)
+#include <stdio.h>
+#define PRINT(a) for (i=0;i<N;i++) fprintf(stdout,"%g ", (a)[i]); \
+	fprintf(stdout,"\n");
+#endif
+
+	void
+main()
+{
+	int bad,i;
+	PT s,t;
+	FLT w[N];
+	void foo(PT,PT);
+
+	s.x = 0;
+	s.y = 1;
+	t.x = 999;
+	t.y = 3;
+	w[0] = s.x; w[1] = s.y;
+	w[2] = t.x; w[3] = t.y;
+
+	foo(s,t);
+
+	bad = -1;
+	for (i=0;i<N;i++) {
+		if (w[i] != x[i]) {
+			bad = i;
+			break;
+		}
+	}
+
+	if (bad >= 0) {
+		PRINT(w);
+		PRINT(x);
+	} else {
+		printf("Test passed.\n");
+	}
+	exit(0);
+}
+
+	void
+foo(PT a,PT b)
+{
+	extern FLT x[N];
+	x[0] = a.x;
+	x[1] = a.y;
+	x[2] = b.x;
+	x[3] = b.y;
+}
--- gcc/testsuite/gcc.wendy/gnu3.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu3.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,30 @@
+/*
+ * From ptsfa!ames!hc!siegel Tue Nov 24 15:38:28 1987
+ * From: siegel@hc.DSPO.GOV (Josh Siegel)
+ * Newsgroups: comp.bugs.4bsd
+ * Subject: Bug in Sun compiler...
+ * Message-ID: <11636@hc.DSPO.GOV>
+ * Date: 24 Nov 87 23:38:28 GMT
+ * Organization: Los Alamos National Laboratory
+ * 
+ * The program causes Suns compiler to generate code that 
+ * has a Segmentation fault upon exiting.
+ * 
+ * The reason being that Sun don't check to see if you specificly 
+ * returned a structure.  The register d0 is null and it offsets 
+ * through it.
+ * 
+ * Vax and GNU do this correctly...
+ */
+
+struct {
+        int a,b,c;
+        } 
+bar()
+{}
+
+main()
+{
+	bar();
+	printf("Test passed\n");
+}
--- gcc/testsuite/gcc.wendy/gnu30.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu30.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,83 @@
+/*
+Message-Id: <8901111052.AA21004@hop.toad.com>
+To: rms
+Cc: gnu
+Subject: gcc-1.32 sparc bug: uses invalid addressing mode
+Date: Wed, 11 Jan 89 02:52:19 -0800
+From: gnu
+
+The following program crashes because
+
+	sth	...,[_foo]
+
+is not valid, since it only has a few displacement bits but needs to represent
+a 32-bit address.  Unfortunately the Sun assembler does not catch this at
+assembly time, nor does the linker complain.
+
+This is excerpted from gnuchess.
+
+I tried to track it down myself; things are OK through the lreg pass,
+which marks this pseudo-reg as live in "-1" instrs, indicating that
+it is infrequently used and should not get a register.  Greg deletes
+the instruction that loads it, and substitutes the name _Developed
+for the pseudo-reg, apparently not realizing that this is invalid.
+
+	John
+
+[In gcc-1.33 prototype, this coredumps cc1 in 
+#0  0x77978 in next_insn_tests_no_inequality (insn=(rtx) 0xa6750) (recog.c line 97)
+#1  0x60858 in subst (x=(rtx) 0xa66a0, to=(rtx) 0xa6630, from=(rtx) 0xa6628) (combine.c line 1063)
+#2  0x5fd44 in subst (x=(rtx) 0xa6728, to=(rtx) 0xa6630, from=(rtx) 0xa6628) (combine.c line 852)
+#3  0x5fd44 in subst (x=(rtx) 0xa6880, to=(rtx) 0xa6630, from=(rtx) 0xa6628) (combine.c line 852)
+#4  0x5fd44 in subst (x=(rtx) 0xa6740, to=(rtx) 0xa6630, from=(rtx) 0xa6628) (combine.c line 852)
+#5  0x5f3c0 in try_combine (i3=(rtx) 0xa6750, i1=(rtx) 0xa6648, i2=(rtx) 0xa66c0) (combine.c line 521)
+#6  0x5eb58 in combine_instructions (f=(rtx) 0xa6828, nregs=276) (combine.c line 272)
+#7  0x1ad1c in rest_of_compilation (decl=(tree) 0xa8cf0) (toplev.c line 1357)
+#8  0x10cb8 in finish_function () (c-decl.c line 3507)
+#9  0x5d7c in yyparse () (c-parse.y line 244)
+#10 0x19ed8 in compile_file (name=(char *) 0xf7fffa67 "foo.c") (toplev.c line 966)
+#11 0x1bbb4 in main (argv=(char **) 0xf7fff98c, argc=5) (toplev.c line 1709)
+
+(gdb) p *insn
+$1 = {code = INSN, mode = VOIDmode, jump = 0, call = 0, unchanging = 0, volatil = 0, in_struct = 0, used = 0, integrated = 0, fld = {{rtint = 8, rtstr = 0x8 <Address 0x8 out of bounds>, rtx = 0x8, rtvec = 0x8, rttype = SFmode}}}
+(gdb) 
+
+I am wondering why "nregs" in combine_instructions (#6) is so high on such a
+small program.  This may have nothing to do with the bug.
+
+	John
+]
+
+*/
+
+
+short board[64];
+short Developed[1];
+
+ExaminePosition()
+{
+    Developed[0] = board[0] != 2;
+}
+
+
+
+/* main() added for test purposes. */
+main()
+{
+	int fail = 0;
+
+	board[0] = 5;
+	ExaminePosition();
+	if (Developed[0] != 1) {
+		printf("Test #1 failed, Developed[0] = %d\n", Developed[0]);
+		fail++;
+	}
+	board[0] = 2;
+	ExaminePosition();
+	if (Developed[0] != 0) {
+		printf("Test #2 failed, Developed[0] = %d\n", Developed[0]);
+		fail++;
+	}
+	if (fail == 0)
+		printf("Test passed\n");
+}
--- gcc/testsuite/gcc.wendy/gnu31.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu31.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,26 @@
+/*
+Message-Id: <9010022328.AA01576@shark2>
+To: cygint!bugs
+Subject: bug in gcc front end
+Date: Tue, 02 Oct 90 16:28:14 PDT
+From: @hermes.intel.com:kevins@shark2
+
+The following source program causes gcc to emit these errors:
+t1.c:3: bit-field `a' width not an integer constant
+t1.c:4: bit-field `b' width not an integer constant
+**** test ****/
+static struct b {	/* 3.4 (cont.) */
+	int i;
+	unsigned int a : (1 + 3 * 2) / 7;
+	unsigned int b : (1 + 3 * 2) / 7;
+	} b;
+/**** end test ****
+This program is legal in that ANSI (well Dec 7, 1988) 3.5.2.1 grammar
+allows constant expressions here.
+*/
+
+#include <stdio.h>
+main()
+{
+	printf("Test passed.\n");
+}
--- gcc/testsuite/gcc.wendy/gnu4.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu4.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,15 @@
+struct s {int x[5];};
+main()
+{
+        struct s {struct s *next; int i;};
+	static struct s sa[2];
+ 
+        /* bar(sa[0].next->x[4]); */
+	printf("Test passed (if it compiled)\n");
+	exit(0);
+        bar(sa[0].next->i);
+}
+
+bar(i)
+int i;
+{}
--- gcc/testsuite/gcc.wendy/gnu5.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu5.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,41 @@
+/*
+Date: 22 Dec 87 08:38:59 PST (Tuesday)
+Subject: Serious bug in gcc 1.16
+From: "James_L_Mayer.WBST128"@xerox.com
+To: bug-gcc@prep.ai.mit.edu
+Message-Id: <871222-084137-7045@Xerox>
+
+Here is a bug in release 1.16 of gcc running on a Sun3:
+
+Problem:
+	In assembler output, "pointer" is incremented twice for each iteration.
+	(when compiled optimized.)
+*/
+
+struct bits
+{
+	unsigned bit0: 1;
+	unsigned bit1: 1;
+} foo[2];
+
+alpha(pointer, count)
+	struct bits *pointer;
+	int count;
+{
+	while (--count >= 0)
+	{
+		pointer->bit0 = !pointer->bit0;
+		pointer++;
+	}
+	
+	if (pointer == &foo[2])
+		printf("Test passed\n");
+	else
+		printf("FAILED, pointer=%x, &foo[2]=%x\n", pointer, &foo[2]);
+}
+
+main()
+{
+	alpha(foo, 2);
+	return 0;
+}
--- gcc/testsuite/gcc.wendy/gnu6.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu6.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,8 @@
+static int it1, it3;
+int i1 = 4, i2 = 7;
+main() {
+	if ( (it3 = (it1 = i1) + (it1 = i2)) == i1+i2 )
+		printf("Test passed\n");
+	else
+		printf("Failed...\n");
+}
--- gcc/testsuite/gcc.wendy/gnu7.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu7.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,8 @@
+#define Neg -113
+static unsigned int ui2 = Neg;
+main() {
+	if ( ui2/2 == ((unsigned)Neg)/2 )
+		printf("Test passed\n");
+	else
+		printf("Failed...\n");
+}
--- gcc/testsuite/gcc.wendy/gnu8.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu8.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,8 @@
+#define Neg -113
+static unsigned int ui2 = Neg;
+main() {
+	if ( ui2%2 == ((unsigned)Neg)%2 )
+		printf("Test passed\n");
+	else
+		printf("Failed...\n");
+}
--- gcc/testsuite/gcc.wendy/gnu9.c.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/gnu9.c	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,9 @@
+main() {
+	struct s {unsigned i9:9, i1:1;} x;
+	x.i9 = 0;
+	x.i1 = 3;		/* Note: larger than bitfield */
+	if ( x.i9 == 0 )
+		printf("Test passed\n");
+	else
+		printf("Failed...\n");
+}
--- gcc/testsuite/gcc.wendy/wendy.dis.jj	Mon Feb  5 14:35:37 2001
+++ gcc/testsuite/gcc.wendy/wendy.dis	Mon Feb  5 14:56:14 2001
@@ -0,0 +1,180 @@
+# Expect script for the GCC "Wendy" Regression Testsuite
+# Copyright (C) 1994 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+# and Doug Evans (dje@cygnus.com).
+#
+# Tests in this directory, when they pass, must either
+# 1) have an exit code of 0, or
+# 2) have "Test passed" in their output, or
+# 3) have the *first* line of the file be
+#    /* DEJAGNU_CFLAGS:"flag1 flag2 ..." DEJAGNU_OUTPUT:"expected output" */
+#    The delimiter " may be anything.  The expected output is matched with
+#    tcl's "string match" (using csh-like pattern matching).
+#
+# If the file needs special cflags, see (3) above.
+# We only look at the first line of the file, if you need to specify both, put
+# them both on the first line (order doesn't matter).
+
+# This testsuite won't run on cross targets (you can't always get the output
+# of printf back), and it has some portability problems, so it's disabled for
+# now.  Since parts of it are "internal use only" (see README), what we need
+# to do is pull the pieces out of it that are good tests into another
+# framework.  We still keep this testsuite around for those who might want to
+# run it, but keep the checked in version disabled (by having it's name not end
+# in ".exp".
+
+if { $tracelevel } then {
+    set strace $tracelevel
+}
+
+# initialize harness
+gcc_init
+
+#
+# wendy_first_line
+#	Read the first line for DEJAGNU cflags and expected output parameters.
+#	The format is "/* DEJAGNU_CFLAGS:<delim>flag1 flag2<delim> DEJAGNU_OUTPUT:<delim>...<delim> */"
+#	We translate "\n" to newline so there can be many lines of output.
+#
+#	CFLAGS and OUTPUT are the names of variables to store the results in.
+#	Returns -1 if there is a DEJAGNU line but is badly formatted,
+#	1 if there is a (properly formatted) DEJAGNU line, 0 otherwise.
+#
+proc wendy_first_line { file cflags output } {
+    upvar $cflags my_cflags $output my_output
+    set fd [open $file r]
+    gets $fd line
+    close $fd
+    if [ string match "*DEJAGNU*" $line ] then {
+	# Fetch the delimiter.
+	verbose "$file has DEJAGNU line: $line" 4
+	regsub ".*DEJAGNU_\[A-Z\]*:(.).*" $line {\1} delim
+	# If there are no matches, there's a syntax error somewhere.
+	set match 0
+	# '\' is needed on the parens here because $delim(foo) means something.
+	# '\' is needed on the brackets because otherwise tcl will execute
+	# what's inbetween them (for you tcl newbies like me).
+	if [regsub ".*DEJAGNU_CFLAGS:$delim\(\[^$delim\]*\)$delim.*" $line {\1} tmp_cflags] then {
+	    set my_cflags $tmp_cflags
+	    set match 1
+	}
+	if [regsub ".*DEJAGNU_OUTPUT:$delim\(\[^$delim\]*\)$delim.*" $line {\1} tmp_output] then {
+	    # Convert "\n" in expected output to newlines.
+	    regsub -all "\\\\n" $tmp_output "\n" my_output
+	    set match 1
+	}
+	if {$match == 0} then {
+	    # Error in test case.
+	    return -1
+	}
+	return 1
+    } else {
+	return 0
+    }
+}
+
+#
+# wendy_try
+#	Try to run a testcase and report pass/fail.
+#	CFLAGS is the cflags you want reported in the pass/fail message
+#	(not all the cflags, just the exceptional ones).
+#
+proc wendy_try { testcase executable cflags expected_output } {
+    global exec_output
+
+    if ![file exists $executable] then {
+	gcc_fail $testcase $cflags
+    } else {
+	set status -1
+	set status [ eval gcc_load "$executable" ]
+	switch -- $status {
+	    "0" { 
+		catch "exec rm -f $executable"
+		gcc_pass $testcase $cflags
+	    }
+	    "1" { 
+		# Allow test cases to have a non-zero exit code and still
+		# succeed if the output is correct.
+		if [string match $expected_output $exec_output] then {
+		    catch "exec rm -f $executable"
+		    gcc_pass $testcase $cflags
+		} else {
+		    verbose "Expected $expected_output, got $exec_output" 4
+		    # Leave executable in place.
+		    gcc_fail $testcase $cflags
+		}
+	    }
+	    "-1" { 
+		perror "Couldn't load $executable." 
+	    }
+	}
+    }
+}
+
+#
+# main test loop
+# Testcases needing additional compilation options, or have non-standard
+# output, provide $testcase.exp which defines $wendy_cflags and $wendy_output.
+#
+
+set wendy_options ""
+if [info exists CFLAGS] then {
+    append wendy_options " $CFLAGS"
+}
+if [info exists LIBS] then {
+    append wendy_options " $LIBS"
+}
+append wendy_options " -lm"
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+    set executable $tmpdir/[file tail [file rootname $testcase].x]
+
+    # Remove any existing executable.
+    catch "exec rm -f $executable"
+
+    # Reset the expected output and optional cflags.
+    set wendy_cflags ""
+    set wendy_output "Test passed*"
+
+    # See if the testcase has special needs.
+    set status [wendy_first_line $testcase wendy_cflags wendy_output]
+    switch -- $status {
+	"0" {}
+	"1" {}
+	"-1" { 
+	    perror "Error in $testcase, badly formatted DEJAGNU line." 
+	}
+    }
+
+    # Compile the testcase.
+    gcc_start [list "$testcase" "-o $executable $wendy_options $wendy_cflags"]
+
+    # Run the executable if it exists.
+    wendy_try $testcase $executable "$wendy_cflags" "$wendy_output"
+}
+
+# call proc gcc_stat to print the testsuite pass/fail stats
+gcc_stat
+
+# Clean up.
+unset wendy_options
+gcc_finish
--- gcc/rtl.c.jj	Sat Feb  3 23:48:08 2001
+++ gcc/rtl.c	Mon Feb  5 14:56:14 2001
@@ -258,7 +258,7 @@ const char * const reg_note_name[] =
   "REG_LABEL", "REG_DEP_ANTI", "REG_DEP_OUTPUT", "REG_BR_PROB",
   "REG_EXEC_COUNT", "REG_NOALIAS", "REG_SAVE_AREA", "REG_BR_PRED",
   "REG_FRAME_RELATED_EXPR", "REG_EH_CONTEXT", "REG_EH_REGION",
-  "REG_EH_RETHROW", "REG_SAVE_NOTE"
+  "REG_EH_RETHROW", "REG_SAVE_NOTE", "REG_NORETURN"
 };
 
 static void fatal_with_file_and_line PARAMS ((FILE *, const char *, ...))
--- gcc/cse.c.jj	Sat Feb  3 23:47:57 2001
+++ gcc/cse.c	Mon Feb  5 15:03:08 2001
@@ -3498,6 +3498,13 @@ fold_rtx (x, insn)
 	return x;
       }
 
+#ifdef NO_FUNCTION_CSE
+    case CALL:
+      if (CONSTANT_P (XEXP (XEXP (x, 0), 0)))
+	return x;
+      break;
+#endif
+
     case ASM_OPERANDS:
       for (i = XVECLEN (x, 3) - 1; i >= 0; i--)
 	validate_change (insn, &XVECEXP (x, 3, i),
@@ -5328,8 +5335,16 @@ cse_insn (insn, libcall_insn)
 
 	  else if (constant_pool_entries_cost
 		   && CONSTANT_P (trial)
+		   /* Reject cases that will abort in decode_rtx_const.
+		      On the alpha when simplifying a switch, we get
+		      (const (truncate (minus (label_ref) (label_ref)))).  */
 		   && ! (GET_CODE (trial) == CONST
 			 && GET_CODE (XEXP (trial, 0)) == TRUNCATE)
+		   /* Likewise on IA-64, except without the truncate.  */
+		   && ! (GET_CODE (trial) == CONST
+			 && GET_CODE (XEXP (trial, 0)) == MINUS
+			 && GET_CODE (XEXP (XEXP (trial, 0), 0)) == LABEL_REF
+			 && GET_CODE (XEXP (XEXP (trial, 0), 1)) == LABEL_REF)
 		   && (src_folded == 0
 		       || (GET_CODE (src_folded) != MEM
 			   && ! src_folded_force_flag))
--- gcc/ChangeLog.Cygnus.jj	Mon Feb  5 14:34:43 2001
+++ gcc/ChangeLog.Cygnus	Mon Feb  5 14:56:13 2001
@@ -0,0 +1,7182 @@
+2000-11-17  H.J. Lu  (hjl@gnu.org)
+
+	* cpplex.c (_cpp_get_line): Check for command line include.
+
+2000-11-10  H.J. Lu  (hjl@gnu.org)
+
+	* cpplex.c (cpp_context): Use int instead of short for token
+	count.
+
+2000-09-26  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+
+	* doloop.c (doloop_modify): Prevent delete_insn() from
+	deleting too much.  Prefer loop->top over loop->start as
+	target for the new JUMP insn.
+	(doloop_valid_p): Ignore loop with exit_count > 0.
+
+2000-09-21  Jim Wilson  <wilson@cygnus.com>
+
+	* loop.c (strength_reduce): Disable code converting biv increments
+	into givs.
+
+2000-09-19  Jim Wilson  <wilson@cygnus.com>
+
+	* loop.c (strength_reduce): Disable code converting bivs to givs.
+
+2000-09-12  Jim Wilson  <wilson@cygnus.com>
+
+	* loop.c (recombine_givs): When handling combined givs, if lifetime
+	of combined giv wraps around end of loop, then set end_luid of combined
+	with giv to loop start.
+
+2000-08-20  Richard Henderson  <rth@cygnus.com>
+
+	* loop.c (simplify_giv_expr): Handle SUBREG separate from the
+	other ext_dep patterns.
+	(extend_value_for_giv): Don't do anything for constants; handle
+	subregs specially.
+
+2000-07-17  Timothy Wall  <twall@cygnus.com>
+
+	* configure.in (ia64*-*-linux*): Enable 32x64 builds.
+	* configure: Regenerate.
+
+2000-08-16  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.c (spill_restore_mem): Handle case where get_insns
+	returns NULL.
+
+2000-08-14  Richard Henderson  <rth@cygnus.com>
+
+	* loop.c (strength_reduce): Call check_ext_dependant_givs.
+	Properly extend the biv initial value for the giv.
+	(record_biv): Zero ext_dependant.
+	(record_giv): New argument ext_val.  Update all callers.
+	(general_induction_var): Likewise.
+	(consec_sets_giv): Likewise.
+	(simplify_giv_expr): Likewise.  Fill in ext_val if we find
+	a sign-extend, zero-extend, truncate, or zero offset subreg.
+	(combine_givs_p): Make sure modes are compatible.
+	(check_ext_dependant_givs): New.
+	(extend_value_for_giv): New.
+	* loop.h (struct induction): Add ext_dependant.
+	* unroll.c (iteration_info): Extend the biv initial value for the giv.
+	(find_splittable_givs): Likewise.
+	(final_giv_value): Likewise.
+
+2000-07-19  Jim Wilson  <wilson@cygnus.com>
+
+	* gcse.c (try_replace_reg): Don't add REG_EQUAL note for CCmode
+	SET_DEST.
+	* c-common.c (decl_attributes): Revert June 30 patch.
+
+Mon Jul 17 16:15:27 2000  Nick Clifton  <nickc@cygnus.com>
+
+	* config/i960/i960.h (TARGET_FLAG_MOVE_COALESCENCE): Fix
+	value.
+	(TARGET_MOVE_COALESCENCE): Fix deifinition.
+
+Sat Jul 15 20:15:52 2000  Jason Eckhardt  <jle@cygnus.com>
+
+	* haifa-sched.c (FIRST_CYCLE_MULTIPASS_SCHEDULING_LOOKAHEAD):
+	Don't guard definition with FIRST_CYCLE_MULTIPASS_SCHEDULING.
+
+Fri Jul 14 13:40:24 2000  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>
+
+	* haifa-sched.c (FIRST_CYCLE_MULTIPASS_SCHEDULING,
+ 	FIRST_CYCLE_MULTIPASS_SCHEDULING_LOOKAHEAD): Add definition of the
+ 	default values of the new macros.
+	(ready_try): The new global variable.
+	(max_issue, choose_ready): The new functions.
+	(schedule_block): Allocate, initialize, and deallocate array
+ 	ready_try.  Use function choose_ready.
+	(get_best_candidate_avail_op): Do not place non branch insn into a
+ 	packet after a branch insn.
+	
+Fri Jul 14 12:40:24 2000  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>
+
+	* rtl.def (AUTOMATA_OPTION): Add new construction.
+
+	* genattr.c (main): Add generation of macro CPU_UNITS_QUERY and
+ 	prototypes of function get_cpu_unit_code and
+ 	cpu_unit_reservation_p.
+
+	* genattrtab.c (gen_automata_option): New function.
+	(main): Call the new function for AUTOMATA_OPTION.
+
+	* genautomata.c (test_unit_reserv,
+ 	output_reserved_units_table_name, output_reserved_units_table,
+ 	units_cmp, output_get_cpu_unit_code_func,
+ 	output_cpu_unit_reservation_p): New functions.
+	(NO_MINIMIZATION_OPTION, NDFA_OPTION, CPU_UNITS_QUERY_MACRO_NAME,
+ 	GET_CPU_UNIT_CODE_FUNC_NAME, CPU_UNIT_RESERVATION_P_FUNC_NAME,
+ 	CPU_UNIT_NAME_PARAMETER_NAME, CPU_CODE_PARAMETER_NAME,
+ 	NAME_CODE_STRUCT_NAME, NAME_CODE_TABLE_NAME, NAME_MEMBER_NAME,
+ 	CODE_MEMBER_NAME, CMP_VARIABLE_NAME, LOW_VARIABLE_NAME,
+ 	MIDDLE_VARIABLE_NAME, HIGH_VARIABLE_NAME): New macros.
+	(add_advance_cycle_insn_decl, output_trans_table,
+ 	output_state_alts_table, output_min_issue_delay_table): Use cast
+ 	to char *.
+	(output_dead_lock_vect): Create dead_lock_vect as HWINT vector.
+  	Delete vector output_states_vect at the function end.
+	(initiate_automaton_gen): Use macros NO_MINIMIZATION_OPTION,
+ 	NDFA_OPTION.
+	(write_automata): Output AUTOMATON_STATE_ALTS.  Output macro
+ 	CPU_UNITS_QUERY and call functions to generate functions to query
+ 	cpu unit reservations.
+	
+2000-07-10  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.h (CONST_OK_FOR_O): Add missing closing
+	parenthesis.
+
+Fri Jul  7 12:37:13 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* mklibgcc.in (stmp-dirs): Use mkinstalldirs
+	* Makefile.in (libgcc.mk): Pass path to mkinstalldirs to mklibgcc.
+
+2000-07-03  Jason Eckhardt  <jle@cygnus.com>
+
+        * config/fp-bit.c (_unord_f2): Do not conditionally build this
+        function based on US_SOFTWARE_GOFAST.
+        (#ifdef US_SOFTWARE_GOFAST): Add definitions of __unord{s,d}f2.
+
+2000-03-29  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* regmove.c (lookup_related, rel_build_chain, rel_record_mem,
+	invalidate_related, find_related, chain_starts_earlier,
+	chain_ends_later, optimize_related_values_1, count_sets
+	optimize_related_values_0, optimize_related_values): Add prototypes.
+	(rel_build_chain): Delete one useless line.
+	(count_sets): Add "data" argument, mark two args as unused.
+	(optimize_related_values_1): Fix formatting and some comments.
+
+Wed Jul  5 15:37:40 2000  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>
+
+	* genautomata.c (IR_TOP_NULLIFY): Don't use nested obstack calls.
+	(form_regexp): Increase buffer size for string representation of
+ 	integer.
+	(output_vect, output_statistics): Transform HWINT into long before
+ 	outputting it and output it as long.
+	
+2000-06-30  Graham Stott  <grahams@cygnus.co.uk>
+
+	* haifa-sched.c (get_visual_tbl_length): Don't return 0.
+
+2000-06-27  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c (output_sa1110_fix): New function: Emit a
+	load operation twice to work around a hardware bug in the
+	StrongARM 1110.
+
+	* config/arm/arm.md: Use output_sa1110_fix.
+
+	* config/arm/arm-protos.h: Define prototype for output_sa1110_fix.
+
+2000-06-26  Jason Merrill  <jason@redhat.com>
+
+	* config/i386/i386.c (ix86_expand_prologue_fsa): Fix thinko.
+
+2000-06-26  Vladimir Makarov  <vmakarov@toke.to.cygnus.com>
+
+	* haifa-sched.c (packet): New member visit_number5.
+	(avail_list): New member avail_p.
+	(avail_list_el_create): New parameter avail_p.
+	(create_avail_list_el): New function.
+	(add_achievable_ops): Ditto.
+	(print_avail_list): New parameter full_p.
+	(last_packet_visit_number5): New variable.
+	(packet_create): Initiate visit_number5.
+	(schedule_state_hash): Hash only available ops.
+	(schedule_state_op_eq): Check dummy insn before cond_branch_p.
+	Take avail_p into account.  Check delay only for available
+	operations.
+	(add_consistent_jumps): Use create_avail_list_el.
+	(update_ready_avail_ops): Ditto.
+	(avail_op_cmp): Check avail_p the first.  Check dummy insn before
+	cond_branch_p and uncond_branch_p.
+	(get_best_candidate_avail_op): Check that all operations are
+	availabile.
+	(make_packet_avail_list): Use create_avail_list_el.
+	(schedule_packet): Increase last_packet_visit_number4 before
+	make_packet_avail_list.  Update min_it_n for the packet after
+	scheduling operation.  Add achievable operations after scheduling
+	the packet.
+	(add_jumps_4_cond_branches): Use last_packet_visit_number5 and
+	visit_number5 instead of last_packet_visit_number4 and
+	visit_number4.
+	(add_exit_jump): Ditto.
+	(add_jumps): Ditto.
+	(check_CFG): Ditto.
+	(check_DDG): Ditto.
+	(check_graphs): Ditto.
+	(print_packets_1, print_packets): Ditto.
+	(pipeline): Initiate last_packet_visit_number5.
+	(second_jumps_pass): Set up exit_packet_p for stop packets.
+	(unroll): Ditto.
+	
+200006-24  Jason Eckhardt  <jle@cygnus.com>
+
+        * haifa-sched.c (schedule_insns): Never emit a NOTE_INSN_DELETED
+        before a barrier.
+
+2000-06-24  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mips/mips.c (override_options): Accept RM5200,
+	RM5230, RM5231, RM5261, RM5721 and RM7000 as r5000 cpu
+	variants.
+
+	* invoke.texi: Document newly accepted cpu variants.
+
+2000-06-22  Vladimir Makarov  <vmakarov@toke.to.cygnus.com>
+
+	* haifa-sched.c (loc_hash): Use rtx loc for hashing.
+
+2000-06-22  Graham Stott  <grahams@cygnus.co.uk>
+
+	* gcse.c (hash_scan_set): Use regno_use_in instead of
+	comparing register numbers.
+	* Add white space.
+
+2000-06-21  Vladimir Makarov  <vmakarov@toke.to.cygnus.com>
+
+	* genautomata.c (gen_regexp_allof, gen_regexp_oneof,
+	gen_regexp_sequence): Allocate memory for array regexps.
+	(get_presence_absence_set): Clear up absence_set.
+	
+2000-06-16  Nick Clifton  <nickc@redhat.com>
+
+	* configure.in: Move arm-epoc-pe target above arm-*-pe target so
+	that it will match first.
+
+	* configure: Regenerate.
+	
+	* config/arm/epoc-pe.h (TARGET_DEFAULT): Replace TARGET_SOFT_FLOAT
+	(a run time test) with ARM_FLAG_SOFT_FLOAT (a constant).
+
+2000-06-15  Andrew MacLeod  <amacleod@cygnus.com>
+
+	* genautomata.c (add_presence_absence): ANSIfy the code.
+
+2000-06-15  Andrew MacLeod  <amacleod@cygnus.com>
+
+	* Makefile.in (LOOSE_CFLAGS): Define outside sanitize flags.
+
+Fri Jun 16 01:03:03 2000  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (optimize_related_values): Use the expander when
+	testing for the maximum constant that can be directly added.
+
+2000-06-15  Jason Merrill  <jason@redhat.com>
+
+	* expr.c (emit_move_insn_1): Pass align of BITS_PER_UNIT, not 1.
+
+2000-06-13  Richard Henderson  <rth@cygnus.com>
+
+	* range.c (range_finish): Rename REG_CHANGES_MODE.
+
+Mon Jun 12 22:02:00 Graham Stott <grahams@cygnus.co.uk>
+
+	* rtl.h (RANGE_REG_PSEUDO): Test for RANGE_REG, not REG.
+        (RANGE_REG_COPY): Likewise.
+
+Mon Jun 12 21:28:00 2000 Graham Stott <grahams@cygnus.co.uk>
+
+	* i386-protos.h: Add missing prototypes.
+
+Fri Jun  2 20:01:47 2000  Vladimir Makarov  <vmakarov@toad.to.cygnus.com>
+
+	* haifa-sched.c (curr_state): Define it only for
+	RCSP_SOFTWARE_PIPELINING.
+	(find_rgns): Use bad_loop_p only for RCSP_SOFTWARE_PIPELINING and
+ 	AUTOMATON_PIPELINE_INTERFACE.
+
+2000-06-02  Vladimir Makarov  <vmakarov@toke.to.cygnus.com>
+
+	* rtl.h (insn_note): Add new notes
+ 	NOTE_SOFTWARE_PIPELINED_LOOP_BEGIN and
+ 	NOTE_SOFTWARE_PIPELINED_LOOP_END.
+	(make_jump_insn_raw, mems_in_disjoint_alias_sets_p): Add external
+ 	function declarations.
+
+	* rtl.c (note_insn_name): Add names for notes
+ 	NOTE_SOFTWARE_PIPELINED_LOOP_BEGIN and
+ 	NOTE_SOFTWARE_PIPELINED_LOOP_END.
+	(copy_rtx): Add case for format 'n'.
+
+	* emit-rtl.c (make_jump_insn_raw):  Make the function external.
+
+	* final.c (final_scan_insn): Add cases for notes
+ 	NOTE_SOFTWARE_PIPELINED_LOOP_BEGIN and
+ 	NOTE_SOFTWARE_PIPELINED_LOOP_END.
+
+	* alias.c (mems_in_disjoint_alias_sets_p): Switch off static
+ 	declaration of function and make the function definition as
+ 	external one.
+
+	* flags.h (flag_rcsp): Add the external definition.
+
+	* toplev.c (flag_rcsp): Add the declaration.
+	(f_options): Add description of option `-frcsp'.
+	(main): Initialize flag_rcsp.
+
+	* genattr.c (main): Add output of declarations of new typedef
+ 	state_t, new function state_size.  Add new parameter in output of
+ 	function declarations state_reset, state_transition, state_alts,
+ 	min_issue_delay, state_dead_lock_p, and min_insn_conflict_delay.
+
+	* genautomata.c (STATE_TYPE_NAME, SIZE_FUNC_NAME, STATE_NAME): Add
+ 	new macros.
+	(output_chip_definitions): Switch off code for output structure
+ 	representing automata states.
+	(output_trans_func): Add output of new parameter representing
+ 	autoamata states.
+	(output_state_alts_func): Ditto.
+	(output_min_issue_delay_func): Ditto.
+	(output_dead_lock_func): Ditto.
+	(output_reset_func): Ditto.
+	(output_min_insn_conflict_delay_func): Ditto.
+	(output_internal_reset_func): Use memset to initialize automata
+ 	states.
+	(output_size_func): Add new function.
+	(write_automata): Call the new function.
+
+	* haifa-sched.c: Add new software pipeliner code.
+ 	(output.h): Add the include-file.
+	(RCSP_SOFTWARE_PIPELINING): Add the default macro definition.
+	(only_evaluate_block_p, curr_state): Add new static variables.
+	(region): Add new members rgn_may_be_pipelined_p,
+ 	rgn_do_not_schedule_p, and rgn_pipelined_loop.
+	(RGN_MAY_BE_PIPELINED_P, RGN_PIPELINED_LOOP,
+ 	RGN_DO_NOT_SCHEDULE_P): Add the new macros.
+	(may_be_pipelined_p, start_RCSP_interface, finish_RCSP_interface):
+ 	Add the new function declarations.
+	(find_single_block_region): .
+	(find_rgns): Find regions which are loops may be pipelined.
+	(insn_cost): Define latency for output- and anti-dependencies for
+ 	DFA interface.
+	(rank_for_schedule): Define rank for case when we do not make
+ 	scheduling.
+	(schedule_insn): When printing insn reservation, process case when
+ 	insn is not recognized.
+	(debug_dependencies): Ditto.
+	(schedule_insn): Add new parameter for DFA interface functions.
+	(queue_to_ready): Ditto.
+	(schedule_block): Ditto.
+	(schedule_region): Call software pipeliner for loops may be
+ 	pipelined.
+	(schedule_insns): Add code for allocating and freeing current DFA
+ 	state.  Change original loop insns by corresponding pipelined loop
+ 	insns.  Reevaluate basic block and flow information if there are
+ 	pipelined loops.
+	
+Fri Jun  2 00:05:20 2000  Michael Meissner  <meissner@redhat.com>
+
+	* expr.h (expect_optab): Delete, no longer used.
+	(OTI_expect): Ditto.
+
+2000-06-01  Michael Meissner  <meissner@redhat.com>
+
+	* genautomata.c (make_bypass_attr): Use the same test criteria for
+	storing fields the rtvec vector as we did to size the vector.
+
+2000-06-01  Richard Henderson  <rth@cygnus.com>
+
+	* combine.c (try_combine): Remove cygnus local branch prediction code.
+	* expr.h: Likewise.
+	* function.c (prepare_function_start): Likewise.
+	* function.h (struct function): Likewise.
+	* genopinit.c (optabs): Likewise.
+	* jump.c: Likewise.
+	* optabs.c (init_optabs): Likewise.
+	* reorg.c (mostly_true_jump): Likewise.
+	* rtl.def: Likewise.
+	* config/i960/i960.c: Likewise.
+	* config/i960/i960.md: Likewise.
+
+Wed May 31 10:55:12 2000   Chandrakala Chavva  <cchavva@cygnus.com>
+
+	* fold-const.c (fold): Convert to proper type before reducing the
+	depth of the tree.
+
+Mon May 29 17:47:19 2000  Vladimir Makarov  <vmakarov@toad.to.cygnus.com>
+
+	* genattr.c (main): Add generation of definitions of new macro
+ 	OLD_PIPELINE_INTERFACE.
+
+	* genattrtab.c (main): Use OLD_PIPELINE_INTERFACE instead of
+ 	!AUTOMATON_PIPELINE_INTERFACE.
+
+	* haifa-sched.c (AUTOMATON_PIPELINE_INTERFACE,
+ 	OLD_PIPELINE_INTERFACE, USE_AUTOMATON_PIPELINE_INTERFACE): Add
+ 	default definitions of the macros.
+	(OLD_PIPELINE_INTERFACE): Use it instead of
+ 	!AUTOMATON_PIPELINE_INTERFACE.
+	(insn_queue, q_ptr, q_size, NEXT_Q, NEXT_Q_AFTER): Switch off the
+ 	definitions for CYGNUS local code.
+	(max_insn_queue_index): New static variable definition for case
+ 	!AUTOMATON_PIPELINE_INTERFACE.
+	(insn_cost, priority, schedule_insn, queue_to_ready,
+ 	get_visual_tbl_length, print_insn, schedule_insns,
+ 	debug_dependencies): Make code for different combinations of
+ 	values of OLD_PIPELINE_INTERFACE, AUTOMATON_PIPELINE_INTERFACE,
+ 	and USE_AUTOMATON_PIPELINE_INTERFACE.
+	(schedule_block): Ditto.  Initialize max_insn_queue_index for old
+ 	pipeline interface.
+	(schedule_region): Remove cycle marks created during the 1st insns
+ 	scheduling only when USE_AUTOMATON_PIPELINE_INTERFACE is TRUE.
+	
+Wed May 24 14:15:38 2000  Vladimir Makarov  <vmakarov@toke.to.cygnus.com>
+
+	* Makefile.in (genattrtab.o): Add genautomata.c to prerequisites.
+
+2000-05-24  Vladimir Makarov  <vmakarov@toke.to.cygnus.com>
+
+	* rtl.def (REQUIRE_SET): Remove it.
+	(PRESENCE_SET, ABSENCE_SET): New constructions.
+
+	* genattrtab.c (gen_req_set): Remove the function declaration.
+	(gen_presence_set, gen_absence_set): New function declarations.
+	(main): Remove gen_req_set call for REQUIRE_SET and add calls of
+	gen_presence_set and gen_absence_set for PRESENCE_SET and
+	ABSENCE_SET.
+
+	* genautomata.c: Fix spelling in header comment and make better
+	format for static function declarations.
+	(excl_decl, req_decl): Remove the structures.
+	(unit_rel_decl): New structure.
+	(decl_mode): Remove enumeration constant dm_req and add constants
+	dm_presence and dm_absence.
+	(unit_decl): Remove member req_list and add members presence_list
+	and absence_list.
+	(reserv_decl): Remove member req and add members presence and
+	absence.
+	(process_reqs, add_reqs, initiate_req_sets, get_req_set): Remove
+	the functions.
+	(gen_presence_set, gen_absence_set, process_presence_absence,
+	add_presence_absence, initiate_presence_absence_sets,
+	get_presence_absence_set): New functions.
+	(req_set, unit_req_set_table): Remove the global variables.
+	(presence_set, absence_set, unit_presence_set_table,
+	unit_absence_set_table): Add the global variables.
+	(process_decls): Remove processing require set representation and
+	add processing presence and absence set representation.
+	(reserv_sets_are_intersected): Use presence and absence sets
+	instead of require set.
+	(output_description): Remove code to output require sets and add
+	code to output absence and presence sets.
+	(generate): Call initiate_presence_absence_sets instead of
+	initiate_req_sets.
+	
+Wed May 24 08:09:34 2000  Catherine Moore  <clm@cygnus.com>
+
+	* config/cygwin.h (FSA_STRIP_ENCODING): Fix typo.
+
+Sun May 21 12:38:14 2000  Michael Meissner  <meissner@redhat.com>
+
+	* m32r.md (commented out conditional execution): Update to use
+	new-style conditional execution.
+
+Sun May 21 11:48:14 2000  Michael Meissner  <meissner@redhat.com>
+
+	* genconfig.c (toplevel): Remove old-style conditional execution
+	support.
+	(walk_insn_part): Ditto.
+	(main): Ditto.
+
+	* jump.c (toplevel): Remove old-style conditional execution
+	support.
+	(jump_optimize_1): Ditto.
+	(conditional_execution): Delete, no longer used.
+
+	* d10v.c (reg_or_short_memory_operand): Return true if gpr or
+	memory based off of a pointer without offset.
+	(pc_or_label_operand): Disable conditional returns until the
+	assembler allows it again.
+	(unary_parallel_operator): Don't allow SIGN_EXTEND or
+	ZERO_EXTEND.
+	(extend_parallel_operator): Allow extending a register in addition
+	to memory.
+
+	* d10v.md (conditional execution patterns): Rewrite all
+	conditional execution patterns to use COND_EXEC.  Change the unary
+	operator patterns not to handle sign/zero extension.  Change the
+	extension patterns to handle extending a register as well as a
+	memory value.
+
+	* d10v-protos.h (reg_or_short_memory_operand): Declare.
+
+	* d10.h (PREDICATE_CODES): Add reg_or_short_memory_operand.
+
+2000-05-18  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.h (ARM_FLAG_SA1110_FIX): New command line flag.
+	(TARGET_SA1110_FIX): New target flag.
+	(TARGET_SWITCHES): Add -msa1110-fix.
+
+	* config/arm/arm.c (arm_print_operand): Add 'F' operand to print a
+	MEM without any pre or post increment or decrement.
+
+	* config/arm/arm.md (extendhidsi_insns_sa1110): New pattern.
+	(extendqihi_insn): Add code for SA1110 fix.
+	(extendqisi_insn): Add code for SA1110 fix.
+
+	* invoke.texi (ARM Options): Document -msa1110-fix.
+	
+2000-05-18  Vladimir Makarov  <vmakarov@toke.to.cygnus.com>
+
+	* haifa-sched.c (insn_cost): Add lost code for default insn
+	latency buffer initialization when automaton pipeline interface is
+	used.
+
+2000-05-17  Nick Clifton  <nickc@cygnus.com>
+
+	* function.c (identify_blocks_1): Remove extraneous debugging.
+
+2000-05-15  Aldy Hernandez  <aldyh@redhat.com>
+
+	* config/arm/arm.h: Don't set ARM_FLAG_SOFT_FLOAT in
+	TARGET_DEFAULT if target cpu is ``arm9e''.
+
+Thu May 11 20:30:15 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* config/dsp16xx: Resync with FSF sources.
+	* config/elxsi: Resync with FSF sources.
+	* config/fx80: Resync with FSF sources.
+	* config/gmicro: Resync with FSF sources.
+	* config/i370: Resync with FSF sources.
+	* config/i860: Resync with FSF sources.
+	* config/convex: Resync with FSF sources.
+	* config/clipper: Resync with FSF sources.
+	* config/a29k: Resync with FSF sources.
+	* config/arc: Resync with FSF sources.
+	* config/1750a: Resync with FSF sources.
+	* config/c4x: Resync with FSF sources.
+	* config/mn10200: Resync with FSF sources.
+	* config/mn10300: Resync with FSF sources.
+
+Wed May 10 18:58:56 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/elf.h (LIB_SPEC): Delete.
+	* config/ia64/ia64.h (TARGET_SWITCHED): Delete -misim, -mhpsim options.
+	(LINK_SPEC): Delete -misim support.
+
+Fri May  5 18:36:22 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* config/h8300: Resync with FSF sources.
+	* config/pa: Resync with FSF sources.
+
+2000-05-05  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* c-lex.c (yylex_buffer_max,yylex_buffer_count,
+	yylex_value_buffer,yylex_yylval_buffer): New. 
+	(yylex): Gather up a MSVC style inline assembler and send it to
+	the parser as an extended asm with the CONST attribute.
+	(msvc_asm_lookup_name,msvc_asm_lookup_this,msvc_asm_expand_operands,
+	msvc_asm_define_label,msvc_asm_addr_expr,
+	msvc_asm_build_component_ref): New.
+	(init_lex): Add RID for __msvc_asm__.
+	* c-lex.h : Add RID for __msvc_asm__.
+	* c-parse.in (stmt): Look for the CONST attribute in extended asms.
+	* toplev.c (rest_of_compilation): If the current function has
+	asms that have jumps or labels, turn off optimization for this
+	function.
+	* tree.h (DECL_ASMS_HAVE_JUMPS_OR_LABELS): New.
+        (tree_decl): Add asms_have_jumps_or_labels.
+	* config/i386/i386-protos.h (msvc_asm_lookup_name,msvc_asm_lookup_this,
+	msvc_asm_expand_operands,msvc_asm_define_label,msvc_asm_addr_expr,
+	msvc_asm_build_component_ref): New.
+	* config/i386/i386.c (ix86_no_register_prefix): New.
+	(print_reg): Use ix86_no_register_prefix.
+	(print_operand): Add %-PUNCTs [, <, and ].  Also don't output
+	QWORD PTR, XWORD PTR, and XMMWORD PTR.
+	(ENSURE_BUFFER,expand_msvc_asm): New.
+	* config/i386/i386.h (PRINT_OPERAND_PUNCT_VALID_P): Added [,<, and ].
+	(EXPAND_MSVC_ASM): New.
+	* c-parse.gperf (_asm,__msvc_asm__): New keywords.
+	* c-gperf.h : Rebuilt.
+
+2000-05-04  Geoff Keating  <geoffk@cygnus.com>
+
+	* config/rs6000/rs6000.md (expectsi3): Delete.
+	Delete the branch prediction stuff, it's obsolete.
+	* config/rs6000/rs6000.c (ccr_bit): Delete branch prediction stuff.
+	(print_operand): Delete 'Q' and 'q' operands, they're obsolete too.
+
+Thu May  4 13:39:07 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* gcse.c: Resync with net sources.
+	* toplev.c (rest_of_compilation): Related changes.
+
+Fri Apr 21 01:45:13 2000  Jason Eckhardt  <jle@cygnus.com>
+
+        * genattrtab.c (output_print_reservation_func): Add a break
+        statement to every case.
+
+Thu Apr 20 23:58:14 2000  Jason Eckhardt  <jle@cygnus.com>
+
+	* genattrtab.c (make_bypass_attr): Execute second loop only when
+	there are bypass declarations to be processed.
+
+2000-04-24  Zack Weinberg  <weinberg.cygnus.com>
+
+	* Makefile.in: Remove remnant from last week's cpplib merge.
+
+2000-04-12  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.h (CONST_OK_FOR_O): Fix computation to restrict
+	value to 9 bits.
+
+2000-03-29  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* config/i386/ptx4-i.h (RETURN_IN_MEMORY): Return MMX values in
+	memory.
+	* config/i386/sysv4.h (RETURN_IN_MEMORY): Likewise.
+	* config/i386/i386elf.h (RETURN_IN_MEMORY): Likewise.
+
+	* configure.in: Include i386-* in the list of configurations that
+	require long long HOST_WIDE_INT.
+	* configure: Rebuilt.
+
+2000-03-20  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* fold-const.c (reduce_expression_tree_depth): Use return value
+	of fold.
+
+
+2000-03-17  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* cppinit.c (version_string): Revert Zack's constification, it
+	conflicts with a declaration in mips.h.
+
+
+
+2000-03-15  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* config/rs6000/t-aix43 (AR_FOR_TARGET): Deleted.  Moved `-X32_64'...
+	(AR_FLAGS_FOR_TARGET): here.  New macro.
+
+
+
+2000-03-13  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* config/i386/i386.c (ix86_expand_builtin, case MASKMOVQ): Fix
+	operand order.
+	* config/i386/xmmintrin.h (_m_pmovmskb): Only takes one argument.
+	(_m_pshufw): Don't cast second argument.
+
+Wed Mar  8 15:11:33 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64-protos.h: Use PARAMS not PROTO.
+
+
+Wed Mar  1 16:32:07 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md (movsi_internal): Add *e/*e constraint.
+
+Wed Mar  1 12:52:47 2000  Jeffrey A Law  (law@cygnus.com)
+
+        * configure.in (hppa configurations): Add pa64-regs.h to the
+        list of tm files as appropriate.
+        (64bit hpux11 configuration): Remove MASK_64BIT from target_cpu_default.
+        * configure: Rebuilt.
+
+Wed Mar  1 01:33:45 2000  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (regmove_optimize): Allow a paradoxical SUBREG in
+	the source operand.
+	(fixup_match_1): Handle this case.
+
+2000-02-27  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* config/mips/iris6gld.h (UNIQUE_SECTION): The #define line was
+	missing.  Fixed.
+
+	* cpplib.c, cpplib.h: Reverted partial Zack's patch
+	checked in by accident.
+
+	* cpplib.h: Completed the merge below.  Reverted a delta that
+	unintentionally got in.
+	(cpp_fatal): Re-introduced declaration unintentionally removed.
+	* cpplib.c: Reverted a delta that unintentionally got in.
+
+	* cpp.1: Merged with net gcc as of `-D "2000-02-24 GMT"'.
+	* cpp.texi: Likewise.
+	* cppalloc.c, cpperror.c, cppexp.c, cppfiles.c: Likewise.
+	* cpphash.h, cpplib.c, cppmain.c: Likewise.
+	* cpplib.h: Partial merge with net gcc.  Did not delete most
+	conflicting declarations.
+	* cpphash.c, cppinit.c: Partial merge with net gcc.  Did not
+	delete declaration of version_string nor definition of
+	PATH_SEPARATOR.
+	* scan.c (hashstr): New function.  From net gcc.
+	* scan.h (hashstr): New declaration.  From net gcc.
+	* fix-header.c (lookup_std_proto): Use hashstr() instead of
+	hashf().  From net gcc.
+	(check_macro_names): Use cpp_defined() instead of cpp_lookup().
+	From net gcc.
+	* gen-protos.c (add_hash): Use hashstr() instead of hashf().  From
+	net gcc.
+Thu Feb 17 12:47:26 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_encode_section_info): Check for section
+	attributes.
+	* config/ia64/ia64.md (call_value): Call
+	gen_indirect_call_multiple_values_pic.
+	(indirect_call_multiple_values_pic): New pattern.
+
+2000-02-17  Richard Henderson  <rth@cygnus.com>
+
+	* ia64/crtbegin.asm: Put __dso_object in .bss for non-shared.
+	Use SHARED not PIC for shared version.
+	* ia64/t-ia64 (crtbeginS.o, crtendS.o): Likewise.
+
+2000-02-16  Richard Henderson  <rth@cygnus.com>
+
+	* ia64.md (movdi): Verify op1 is a symbol before checking
+	SYMBOL_REF_FLAG.  Look for any valid gprel address for load_gprel.
+
+2000-02-16  Ranjith Kumaran  <ranjith@cygnus.com>
+
+	* config/ia64/ia64.c: Fix oldval in ia64_expand_fetch_and_op.
+	* config/ia64/ia64.md: Change fetch_and_add_si and _di to take
+	nonmemory_operand.
+
+Tue Feb 15 20:13:11 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/lib1funcs.asm (__divdf3, __divsf3, __divdi3, __moddi3,
+	__udivdi3, __umoddi3): Use .s1.
+
+2000-02-15  Ranjith Kumaran  <ranjith@cygnus.com>
+
+	* config/ia64/ia64-protos.h: Add prototypes for ia64_init_builtins
+	and ia64_expand_builtin.
+	* config/ia64/ia64.c: Add intrinsics.
+	* config/ia64/ia64.h: Add types for intrinsics.
+	* config/ia64/ia64.md: Add intrinsics.
+	* config/ia64/ia64intrin.h: New file.
+	* config/ia64/t-ia64: Add EXTRA_HEADERS.
+
+2000-02-15  Richard Henderson  <rth@cygnus.com>
+
+	* ia64/crtbegin.asm: Actually dereference the dtor fptr.
+	* ia64/crtend.asm: Add missing post-dec.
+
+Tue Feb 15 16:49:36 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c: Fix terminology.
+	* config/ia64/ia64.h, config/ia64/ia64.md,
+	config/ia64/lib1funcs.asm: Likewise.
+
+2000-02-14  Richard Henderson  <rth@cygnus.com>
+
+	* ia64/crtbegin.asm: Fix thinkos.  Compress a bit more.
+	* ia64/crtend.asm: Update commentary.
+
+2000-02-14  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in (ia64-elf): Add t-ia64.
+	* ia64/t-ia64: Remove FPBIT and MULTILIB stuff.  Build crtfoo
+	from assembly files.
+	* ia64/crtbegin.asm, ia64/crtend.asm: New files.
+
+2000-02-14  Nick Clifton  <nickc@cygnus.com>
+
+	* config/generic/generic-protos.h: New file.  Prototypes for the
+	generic backend.
+	
+	* config/generic/generic.h: Move prototypes into generic-protos.h.
+	* config/generic/generic.c: Include tm_p.h.
+
+Mon Feb 14 14:55:21 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_encode_section_info): Add check for
+	flag_pic in sdata test.  Add comments.
+
+2000-02-10  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c (mcore_function_value): Invoke
+	PROMOTE_MODE on the return type.
+	(layout_mcore_frame): Force locals to padded to stack byte
+	boundary.
+	
+	* config/mcore/mcore-protos.h: New file: Prototypes for
+	functions defined in mcore.c.
+
+	* config/mcore/mcore.c: Remove M340 sanitization and CYGNUS
+	LOCAL markers.
+	* config/mcore/mcore.h: Ditto.
+	* config/mcore/mcore.md: Ditto.
+	* config/mcore/gfloat.h: Ditto.
+	* config/mcore/lib1.asm: Ditto.
+	* config/mcore/mcore-elf.h: Ditto.
+	* config/mcore/mcore-pe.h: Ditto.
+	* config/mcore/t-mcore: Ditto.
+	* config/mcore/t-mcore-pe: Ditto.
+	* config/mcore/xm-mcore.h: Ditto.
+	
+Thu Feb 10 13:24:25 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_encode_section_info): Check TARGET_NO_SDATA.
+	* config/ia64/ia64.h (MASK_NO_SDATA, TARGET_NO_SDATA): New.
+	(TARGET_SWITCHES): Add -msdata and -mno-sdata options.
+
+Wed Feb  2 12:55:58 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/sysv4.h (SELECT_SECTION): Delete flag_pic && RELOC check.
+	Add ! RELOC check to DECL_READONLY_SECTION check.
+
+Thu Jan 27 21:11:58 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_expand_epilogue): Call gen_blockage before
+	restoring the stack pointer.
+
+Thu Jan 27 17:28:17 2000  David Mosberger  <davidm@hpl.hp.com>
+
+	* config/ia64/ia64.c (ia64_print_operand): Add 'O' and 'Q' qualifiers.
+	* config/ia64/ia64.md: Append 'O' to every ld instruction, and 'Q' to
+	every store instruction.
+
+Wed Jan 26 21:45:30 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (sparc-*-solaris2*): Treat solaris2 like solaris2.6.
+	* configure: Regnerate.
+	
+2000-01-26  Nick Clifton  <nickc@redhat.com>
+
+	* calls.c (expand_call): Make sure that we are examining a
+	function call and not some other type of decl.
+
+Wed Jan 26 17:28:23 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (insn-recog.o): If compiling with 99r1, remove -O from
+	ALL_CFLAGS.
+
+Mon Jan 24 18:01:45 2000  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_encode_section_info): Reverse test for
+	__DTOR_END__.
+
+Mon Jan 17 18:00:09 2000  Michael Meissner  <meissner@cygnus.com>
+
+	* d30v-protos.h (cond_move_dest_operand): Add declaration.
+
+	* d30v.c (d30v_cond_exec_string): Make const char *.
+	(d30v_branch_cost_string): Ditto.
+	(cond_move_dest_operand): Clone from cond_move_operand, allowing
+	only REG, SUBREG, and MEM cases.
+
+	* d30v.h (d30v_cond_exec_string): Make const char *.
+	(d30v_branch_cost_string): Ditto.
+	(PREDICATE_OPCODES): Add cond_move_dest_operand.
+
+	* d30v.md (subsi3_set_carry): Specify mode.
+	(subsi3_use_carry): Ditto.
+	(call_internal): Ditto.
+	(call_value_internal): Ditto.
+	(cond_exec_call_true): Ditto.
+	(cond_exec_call_false): Ditto.
+	(cond_exec_call_value_true): Ditto.
+	(cond_exec_call_value_false): Ditto.
+	(andsi3_bclr): Delete, combine won't generate this case and it
+	casues warning messages in the compiler.
+	(iorsi3_bset): Ditto.
+	(iorsi3_bnot): Ditto.
+	(movqicc*): Use cond_move_dest_operand, not cond_move_operand for
+	destination to silence warnings.
+	(movhicc*): Ditto.
+	(movsicc*): Ditto.
+
+Thu Jan 13 03:02:38 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* fixinc/mkfixinc.sh; Remove CYGNUS LOCAL code which used
+	the old fixincludes shell script.
+
+Tue Jan  4 11:46:56 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* range.c (range_update_basic_block): Call calculate_loop_depth
+	as we may have created new basic blocks.
+	* flow.c (flow_depth_first_order_compute): Handle any unreachable
+	blocks created by LRS.
+
+Sun Jan  9 11:13:16 2000  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/pe.c (arm_pe_unique_section): Remvoe use of
+	nested macros.
+
+Tue Jan 4 14:40 2000 Chandrakala Chavva  <cchavva@cygnus.com>
+
+	* config/d10v/d10v.c (adjacent_memory_operands): Added a new
+	parameter 'swap_p' which specifies whether op1 and op2 are
+	swapped from their original order.   This controls which forms
+	of pre- and post- increment addressing are allowed.
+       	 
+	* config/d10v/d10v.md (peephole patterns): Add extra parameter
+	to invocations of adjacent_memory_operands().
+	
+	* config/d10v/d10v-protos.h (adjacent_memory_operands): Update
+	prototype to include new parameter.
+
+Fri Dec 31 15:48:28 1999  Clinton Popetz  <cpopetz@cygnus.com>
+
+	* config/mips/mips.c (function_arg_pass_by_reference): Pass a
+	copy of CUM to FUNCTION_ARG, so that multiple offsets aren't
+	built for each small structure passed in a register.
+
+Thu Dec 30 13:03:10 1999  Clinton Popetz  <cpopetz@cygnus.com>
+
+	* config/mips/elfb5000.h (DWARF2_DEBUGGING_INFO): define.
+	* config/mips/elfl5000.h (DWARF2_DEBUGGING_INFO): define.
+
+Tue Dec 28 12:24:37 1999  Clinton Popetz  <cpopetz@cygnus.com>
+
+	* config/arm/arm.md: (*mulsidi3adddi,*umulsidi3adddi): Remove
+	erroneous TARGET_ARM from condition.
+
+Mon Dec 27 10:06:40 1999  Clinton Popetz  <cpopetz@cygnus.com>
+
+	* config/mips/mips.h (REGISTER_MOVE_COST): Remove redundant
+	case for moving from HI/LO/HI_LO_REG.  This makes the behavior
+	match the comment for MIPS16.
+
+Tue Dec 14 16:13:23 1999  Clinton Popetz  <cpopetz@cygnus.com>
+
+	* config/mips/t-vr4xxx (MULTILIB_DONT_BUILD_DIRS): Add
+	el/eabi/mips16 and el/eabi/mips16/long32.
+
+Wed Dec  8 15:54:41 1999   Geoff Keating <geoffk@cygnus.com>
+  
+	* integrate.c (copy_insn_list): Define cc0_insn.
+	(expand_inline_function): Delete unused variables.
+
+Thu Dec 30 14:25:03 1999  Catherine Moore  <clm@cygnus.com>
+
+	* config/i386/linux-aout.h (ASM_DECLARE_FUNCTION_NAME): Redefine.
+        (ASM_DECLARE_FUNCTION_SIZE): Undefine.
+
+Thu Dec 23 11:12:22 1999  Vladimir Makarov  <vmakarov@toad.to.cygnus.com>
+
+	* Makefile.in: Use host version of xexit, xmalloc, getruntime and
+	hashtab for genattrtab.
+
+Wed Dec 22 13:17:58 MST 1999	Diego Novillo <dnovillo@cygnus.com>
+
+	* integrate.c (save_parm_insns): New function.
+	(save_for_inline_nocopy): Move code that records modified
+	parm insns to save_parm_insns. Needed to recursively
+	traverse insn lists in CALL_PLACEHOLDER insns.
+
+Mon Dec 20 17:46:47 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>
+
+	* haifa-sched.c (schedule_block): Force that asm insn is issued as
+ 	the single insn on one cpu cycle.
+
+Thu Dec 16 12:55:30 1999  Vladimir Makarov  <vmakarov@toad.to.cygnus.com>
+
+	* genattrtab.c: Switch on dfa generation code only when
+ 	DFA_GENERATE is defined.
+
+Mon Dec 20 11:01:40 1999  Donald Lindsay  <dlindsay@hound.cygnus.com>
+
+	* c-common.c (name_to_type_map, check_format_info, upto_semisplat,
+ 	string_to_type, read_printf_format_file, remove_printf_whitespace,
+ 	init_printf_formats, inspect_format_info): upgraded "printf
+ 	formats" feature to new Dec99 spec.
+
+1999-12-17  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm-wince-pe.h (USER_LABEL_PREFIX): Remove leading
+	underscore. 
+
+Mon Dec 13 10:57:39 1999  Geoff Keating  <geoffk@cygnus.com>
+
+	* integrate.c (copy_insn_list): When inlining a tail recursive
+	function, use the inlined function's tail recursion label
+	not the one of the function that it is being inlined into.
+
+1999-12-15  Brendan Kehoe  <brendan@cygnus.com>
+
+	* Makefile.in ($(HOST_PREFIX_1)varray.o): New rule, like rtl.o.
+
+Wed Dec 15 13:52:29 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm-wince-pe.h (LIB_SPEC): Linking coredll and
+	corelibc.
+	(STARTFILE_SPEC): Define as empty.
+	(ENDFILE_SPEC): Define as empty.
+
+Wed Dec 15 12:03:32 1999  Richard Henderson  <rth@cygnus.com>
+
+	* ia64/linux.h (DONT_USE_BUILTIN_SETJMP): Define.
+	(JMP_BUF_SIZE): Define.
+
+Tue Dec 14 13:29:08 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm-wince-pe.h (PE_SUBTARGET_CPP_SPEC): Add -DARM to
+	cpp command line.
+	Replace __unaligned with __attribute__((aligned (1))).
+
+Mon Dec 13 18:35:55 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm-wince-pe.h: Switch to APCS-32 default.
+
+Mon Dec 13 15:54:00 1999  Andrew Haley  <aph@cygnus.com>
+
+        * expr.c (expand_increment): Only queue postfix side effects if
+        flag_delay_postincrement is set.
+        * toplev.c (flag_delay_postincrement): add.
+        (f_options): add flag_delay_postincrement.
+        * flags.h: (flag_delay_postincrement): add.
+
+Sun Dec 12 16:22:43 1999  Geoff Keating  <geoffk@cygnus.com>
+
+	* genattrtab.c (struct nothing_regexp): Don't have an
+	empty structure.
+
+Fri Dec 10 12:10:08 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md (cmovne_internal, cmoveq_internal,
+	cmovnesi_internal): Drop r/c/m/m and m/c/r/r alternatives.
+
+	* config/ia64/ia64.c (ia64_local_regs, ia64_need_regstk): New globals.
+	(ia64_expand_prologue): Set them.
+	(ia64_function_prologue): Use ia64_need_regstk.
+	* config/ia64/ia64.h (LOC_REGNO_P, OUT_REGNO_P): New macros.
+	(ia64_input_regs, ia64_local_regs): Declare.
+	* config/ia64/sysv4.h (DBX_REGISTER_NUMBER): Remap local and out regs.
+
+Fri Dec 10 12:52:33 1999  Vladimir Makarov  <vmakarov@toad.to.cygnus.com>
+
+	* jump.c (jump_optimize): Call jump_optimize_1 with minimal
+ 	optimizations when MINIMAL_SECOND_JUMP_OPTIMIZATION is defined.
+	(delete_insn): When an insn is deleted, set correctly TImode for
+ 	the next insn.
+	
+1999-12-08  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* Makefile.in (s-mlib): Add options to genmultilib.
+	(stmp-multilib-sub): Create parents when creating multilib
+	directorys.
+	* gcc.c (set_multilib_dir): Handle multilib_redundant_dirs,
+	and multilib_dont_build_dirs.
+	(print_multilib_info): Same.
+	* genmultilib: Produce the new multilib_redundant_dirs,
+	and multilib_dont_build_dirs.
+	* config/mips/t-vr4xxx (MULTILIB_REDUNDANT_DIRS,
+	MULTILIB_DONT_BUILD_DIRS): New.
+	* config/mips/t-vr5000 (MULTILIB_REDUNDANT_DIRS,
+	MULTILIB_DONT_BUILD_DIRS): New.
+
+1999-12-07  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/elfb5000.h (MIPS_ENABLE_EMBEDDED_O32): Define.
+	(MULTILIB_DEFAULTS): Include newmultilib options.
+	(SUBTARGET_CPP_SPEC): Redefine to handle new multilibs.
+	(SUBTARGET_CPP_SIZE_SPEC): Redefine to handle more ABIs,
+	and more options.
+	* config/mips/elfl5000.h: Same.
+	* config/mips/t-vr5000: MULTILIB more options.
+
+1999-12-07  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/mips.h (GAS_ASM_SPEC): Add -mips2 under
+	special conditions.
+
+1999-12-07  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.md: Fix compile time errors.
+
+Mon Dec  6 16:31:58 1999  Vladimir Makarov  <vmakarov@toad.to.cygnus.com>
+
+	* genattrtab.c (UCHAR_MAX, SCHAR_MAX, SCHAR_MIN, USHRT_MAX,
+ 	SHRT_MAX, SHRT_MIN, UINT_MAX, INT_MAX, INT_MIN): Remove macro
+ 	definitions.
+	(process_excls, add_excls, process_reqs, add_reqs): Add
+ 	ATTRIBUTE_UNUSED to position parameter.
+	(check_name): Ditto.  Call error with name.
+	(process_insn_equiv_class): New variable temp_arc.
+	(MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND): New macro.
+	(estimate_one_automaton_bound): Use
+ 	MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND instead of DBL_MAX.
+	(output_range_type): Use values required by ANSI C Standard
+ 	instead of CHAR_MAX, SHRT_MAX, etc.
+
+	* Makefile.in (HOST_VARRAY): Define it.
+	(genattrtab): Use HOST_VARRAY in the Makefile entry.
+
+1999-12-03  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	From Richard Earnshaw (rearnsha@arm.com):
+	* arm.h (TARGET_APCS_FRAME): Renamed from TARGET_APCS -- all uses
+	updated.
+	(CAN_DEBUG_WITHOUT_FP): Define.
+	(FIXED_REGISTERS): Make r11 call-saved.
+	(CALL_USED_REGISTERS): Likewise.
+	(CONDITIONAL_REGISTER_USAGE): Fix r11 if TARGET_APCS_FRAME.
+	(FRAME_POINTER_REQUIRED): Correct logic for determining when a 
+	frame-pointer is required.
+	(TARGET_DEFAULT): Make default setting include ARM_FLAG_APCS_FRAME.
+	* arm.c (arm_override_options): Warn about -mno-apcs-frame and -g
+	if the target normally needs a stack frame in non-leaf functions.
+	(use_return_insn): Correct logic for determining when a return
+	instruction can be used.
+	(output_return_instruction): Handle the frame-pointer register as
+	a normal register when not TARGET_APCS_FRAME.
+	(arm_output_prologue): Likewise.
+	(arm_output_epilogue): Likewise.
+	(output_func_epilogue): Likewise.
+	(arm_expand_prologue): Likewise.
+	* arm.c (use_return_insn): No need to check floating point regs if
+	TARGET_SOFT_FLOAT.
+	(arm_find_minipool_constant): Correct typo; use GET_CODE to get
+	the code of value stored in the minipool array.
+	(arm_add_minipool_constant): Likewise.
+
+Thu Dec  2 12:27:33 1999  Vladimir Makarov  <vmakarov@toad.to.cygnus.com>
+
+	* rtl.def (DEFINE_CPU_UNIT, EXCLUSION_SET, REQUIRE_SET,
+ 	DEFINE_BYPASS, DEFINE_AUTOMATON, DEFINE_RESERVATION,
+ 	DEFINE_INSN_RESERVATION): New.
+
+	* genattr.c (main): Generate external definitions for interface to
+ 	pipeline hazards recognizer based in DFA if there is
+ 	define_insn_reservation in .md file.
+		
+	* genattrtab.c (num_dfa_decls): New global variable.
+	(gen_cpu_unit, gen_bypass, gen_excl_set, gen_req_set,
+ 	gen_automaton, gen_reserv, gen_insn_reserv,
+ 	initiate_automaton_gen, expand_automata, write_automata): New
+ 	function forward declarations.
+	(main): Initiate DFA generation, call functions to generate IR of
+ 	pipeline hazard description based on DFA, and finally generate
+ 	pipeline hazard recognizer based on DFA.
+        (error, create_node, copy_node, check_name, next_sep_el,
+ 	n_sep_els, get_str_vect, gen_regexp_el, gen_regexp_repeat,
+ 	gen_regexp_allof, gen_regexp_oneof, gen_regexp_sequence,
+ 	gen_regexp, string_hash, automaton_decl_hash, automaton_decl_eq_p,
+ 	insert_automaton_decl, find_automaton_decl,
+ 	initiate_automaton_decl_table, finish_automaton_decl_table,
+ 	insn_decl_hash, insn_decl_eq_p, insert_insn_decl, find_insn_decl,
+ 	initiate_insn_decl_table, finish_insn_decl_table, decl_hash,
+ 	decl_eq_p, insert_decl, find_decl, initiate_decl_table,
+ 	finish_decl_table, process_excls, add_excls, process_decls,
+ 	find_bypass, check_automaton_usage, process_regexp,
+ 	process_regexp_decls, check_usage, loop_in_regexp,
+ 	check_loops_in_regexps, process_regexp_cycles,
+ 	evaluate_max_reserv_cycles, check_all_description, create_ticker,
+ 	ticker_off, ticker_on, active_time, print_active_time,
+ 	add_advance_cycle_insn_decl, get_free_alt_state, free_alt_state,
+ 	free_alt_states, alt_state_cmp, uniq_sort_alt_states,
+ 	alt_states_eq, initiate_alt_states, finish_alt_states,
+ 	alloc_empty_reserv_sets, reserv_sets_hash_value, reserv_sets_cmp,
+ 	reserv_sets_eq, set_unit_reserv, it_is_empty_reserv_sets,
+ 	reserv_sets_are_intersected, reserv_sets_shift, reserv_sets_or,
+ 	reserv_sets_and, output_cycle_reservs, output_reserv_sets,
+ 	get_free_state, free_state, state_hash, state_eq_p, insert_state,
+ 	set_state_reserv, intersected_state_reservs_p, states_union,
+ 	state_shift, initiate_states, finish_states, free_arc, remove_arc,
+ 	find_arc, add_arc, first_out_arc, next_out_arc, initiate_arcs,
+ 	finish_arcs, initiate_excl_sets, get_excl_set, initiate_req_sets,
+ 	get_req_set, copy_insn_regexp, transform_1, transform_2,
+ 	transform_3, regexp_transform_func, transform_regexp,
+ 	transform_insn_regexps, process_seq_for_forming_states,
+ 	finish_forming_alt_state, process_alts_for_forming_states,
+ 	create_alt_states, form_ainsn_with_same_reservs, make_automaton,
+ 	form_arcs_marked_by_insn, create_composed_state, NDFA_to_DFA,
+ 	pass_state_graph, pass_states, initiate_pass_states,
+ 	add_achieved_state, set_out_arc_insns_equiv_num,
+ 	clear_arc_insns_equiv_num, copy_equiv_class, state_is_differed,
+ 	init_equiv_class, evaluate_equiv_classes, merge_states,
+ 	set_new_cycle_flags, minimize_DFA, incr_states_and_arcs_nums,
+ 	count_states_and_arcs, build_automaton, set_order_state_num,
+ 	enumerate_states, insert_ainsn_into_equiv_class,
+ 	delete_ainsn_from_equiv_class, process_insn_equiv_class,
+ 	process_state_for_insn_equiv_partition, set_insn_equiv_classes,
+ 	estimate_one_automaton_bound, compare_max_occ_cycle_nums,
+ 	units_to_automata_heuristic_distr, create_ainsns,
+ 	units_to_automata_distr, create_automata, form_regexp,
+ 	regexp_representation, finish_regexp_representation,
+ 	output_range_type, output_vect, output_chip_member_name,
+ 	output_temp_chip_member_name, output_translate_vect_name,
+ 	output_trans_full_vect_name, output_trans_comb_vect_name,
+ 	output_trans_check_vect_name, output_trans_base_vect_name,
+ 	output_state_alts_full_vect_name,
+ 	output_state_alts_comb_vect_name,
+ 	output_state_alts_check_vect_name,
+ 	output_state_alts_base_vect_name,
+ 	output_min_issue_delay_full_vect_name,
+ 	output_min_issue_delay_comb_vect_name,
+ 	output_min_issue_delay_check_vect_name,
+ 	output_min_issue_delay_base_vect_name, output_dead_lock_vect_name,
+ 	output_state_member_type, output_chip_definitions,
+ 	output_translate_vect, comb_vect_p, create_state_ainsn_table,
+ 	output_state_ainsn_table, add_vect, out_state_arcs_num,
+ 	compare_transition_els_num, add_vect_el, add_states_vect_el,
+ 	output_trans_table, output_state_alts_table,
+ 	min_issue_delay_pass_states, min_issue_delay,
+ 	initiate_min_issue_delay_pass_states,
+ 	output_min_issue_delay_table, output_dead_lock_vect,
+ 	output_tables, output_max_insn_queue_index_def,
+ 	output_internal_min_issue_delay_func, output_internal_trans_func,
+ 	output_internal_insn_code_evaluation, output_trans_func,
+ 	output_internal_state_alts_func, output_state_alts_func,
+ 	output_min_issue_delay_func, output_internal_dead_lock_func,
+ 	output_dead_lock_func, output_internal_reset_func,
+ 	output_reset_func, output_min_insn_conflict_delay_func,
+ 	output_internal_insn_latency_func, output_insn_latency_func,
+ 	output_print_reservation_func, output_regexp, output_description,
+ 	output_automaton_name, output_automaton_units, add_state_reservs,
+ 	output_state_arcs, state_reservs_cmp,
+ 	remove_state_duplicate_reservs, output_state,
+ 	output_automaton_descriptions, output_statistics,
+ 	output_time_statistics, generate, make_insn_alts_attr,
+ 	make_dfa_insn_code_attr, make_default_insn_latency_attr,
+ 	make_bypass_attr, file_name_suffix, base_file_name): New functions
+ 	and their forward definitions.
+	(assert, CHAR_BIT, UCHAR_MAX, SCHAR_MAX, SCHAR_MIN, USHRT_MAX,
+ 	SHRT_MAX, SHRT_MIN, UINT_MAX, INT_MAX, INT_MIN): New macro
+ 	definitions if they are not defined.
+	(pos_t, set_el_t, reserv_sets_t, vla_ptr_t, vla_hwint_t, ticker_t,
+ 	vect_el_t): New typedefs.
+	(ticker, unit_decl, bypass_decl, result_decl, automaton_decl,
+ 	excl_decl, req_decl, reserv_decl, insn_reserv_decl, decl,
+ 	unit_regexp, result_regexp, reserv_regexp, nothing_regexp,
+ 	sequence_regexp, repeat_regexp, allof_regexp, oneof_regexp,
+ 	regexp, description, unit_set_el, state, alt_state, arc, ainsn,
+ 	automaton, state_ainsn_table): New struct definitions.
+	(no_pos): New global variable.
+	(IR_START_ALLOC, IR_STOP_ALLOC, IR_ALLOC, IR_FREE, IR_TOP_FINISH,
+ 	IR_TOP_NULLIFY, IR_TOP_SHORTEN, IR_TOP_BEGIN, IR_TOP_LENGTH,
+ 	IR_TOP_EXPAND, IR_TOP_ADD_BYTE, IR_TOP_ADD_STRING,
+ 	IR_TOP_ADD_MEMORY): New macros.
+	(irp): New global variable.
+	(VLA_PTR_CREATE, VLA_PTR_DELETE, VLA_PTR_BEGIN, VLA_PTR_LAST,
+ 	VLA_PTR_NULLIFY, VLA_PTR_SHORTEN, VLA_PTR_EXPAND, VLA_PTR_ADD,
+ 	VLA_PTR_LENGTH, VLA_PTR, VLA_HWINT_CREATE, VLA_HWINT_DELETE,
+ 	VLA_HWINT_BEGIN, VLA_HWINT_LAST, VLA_HWINT_NULLIFY,
+ 	VLA_HWINT_SHORTEN, VLA_HWINT_EXPAND, VLA_HWINT_ADD,
+ 	VLA_HWINT_LENGTH, VLA_HWINT, FALSE, TRUE): New macros.
+	(ndfa_flag, no_minimization_flag, split_argument, time_flag,
+ 	v_flag, output_file, output_description_file,
+ 	output_description_file_name, description, num_of_errors): New
+ 	global variables.
+	(decl_mode, regexp_mode): New enum declarations.
+	(decls, reserv_str): New global variables.
+ 	(NOTHING_NAME): New macro.
+	(automaton_decl_table, work_automaton_decl, insn_decl_table,
+ 	work_insn_decl, decl_table, work_decl, automata_num,
+ 	transform_time, NDFA_time, NDFA_to_DFA_time, minimize_time,
+ 	equiv_time, automaton_generation_time, output_time, check_time,
+ 	generation_time, all_time, first_free_alt_state,
+ 	allocated_alt_states_num): New global variables.
+	(SET_BIT, TEST_BIT): New macros.
+	(max_cycles_num, els_in_cycle_reserv, els_in_reservs,
+ 	units_container, units_array, empty_reserv, state_table,
+ 	free_states, curr_unique_state_num, allocated_states_num):
+	(first_free_arc, allocated_arcs_num, excl_set,
+ 	unit_excl_set_table, regexp_transformed_p, state_being_formed,
+ 	alt_state_being_formed, curr_ainsn, curr_state_graph_pass_num,
+	all_achieved_states, curr_counted_states_num,
+	curr_counted_arcs_num, curr_state_order_num): New global variables.
+	(CHIP_NAME, ADVANCE_CYCLE_VALUE_NAME, AUTOMATON_STATE_ALTS_MACRO_NAME,
+ 	INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME, INTERNAL_TRANSITION_FUNC_NAME,
+ 	INTERNAL_STATE_ALTS_FUNC_NAME, INTERNAL_RESET_FUNC_NAME,
+ 	INTERNAL_DEAD_LOCK_FUNC_NAME, INTERNAL_INSN_LATENCY_FUNC_NAME,
+ 	TRANSITION_FUNC_NAME, STATE_ALTS_FUNC_NAME,
+ 	MIN_ISSUE_DELAY_FUNC_NAME, MIN_INSN_CONFLICT_DELAY_FUNC_NAME,
+ 	DEAD_LOCK_FUNC_NAME, RESET_FUNC_NAME, INSN_LATENCY_FUNC_NAME,
+ 	PRINT_RESERVATION_FUNC_NAME, INSN_PARAMETER_NAME,
+ 	INSN2_PARAMETER_NAME, CHIP_PARAMETER_NAME, FILE_PARAMETER_NAME,
+ 	INTERNAL_INSN_CODE_NAME, INTERNAL_INSN2_CODE_NAME,
+ 	TEMPORARY_VARIABLE_NAME, RESULT_VARIABLE_NAME,
+ 	INSN_ALTS_FUNC_NAME, DFA_INSN_CODE_FUNC_NAME,
+ 	INSN_DEFAULT_LATENCY_FUNC_NAME, BYPASS_P_FUNC_NAME): New macros.
+	(undefined_vect_el_value, output_states_vect,
+ 	current_min_insn_issue_delay, current_arc_pass_number,
+ 	locked_states_num): New global variables.
+	(MAX_LINE_LENGTH): New macro.
+	(state_reservs): New global variable.
+	(STANDARD_OUTPUT_DESCRIPTION_FILE_SUFFIX): New macro.
+	(xrealloc, xmalloc): Don't define them.
+	
+	* Makefile.in (genattrtab): Add varray.o and libiberty.a to build
+ 	genattrtab.
+	
+	* haifa-sched.c (FUNCTION_UNITS_SIZE, BLOCKAGE_BITS,
+ 	MAX_MULTIPLICITY, MIN_BLOCKAGE, MAX_BLOCKAGE): Undefine the macros
+ 	when automaton pipeline interface is used.
+	(target_units, issue_rate, ISSUE_RATE, insn_units, INSN_UNIT,
+ 	insn_blockage, INSN_BLOCKAGE, UNIT_BITS, BLOCKAGE_MASK,
+ 	ENCODE_BLOCKAGE, UNIT_BLOCKED, BLOCKAGE_RANGE, MIN_BLOCKAGE_COST,
+ 	MAX_BLOCKAGE_COST): Don't define them when automaton pipeline
+ 	interface is used.
+	(DONE_PRIORITY, MAX_PRIORITY, TAIL_PRIORITY, LAUNCH_PRIORITY,
+ 	DONE_PRIORITY_P, LOW_PRIORITY_P): Don't define this macros.
+	(MAX_INSN_QUEUE_INDEX, insn_queue, q_ptr, q_size, NEXT_Q,
+ 	NEXT_Q_AFTER): Define them for automaton pipeline interface.
+	(insn_unit, blockage_range, clear_units,
+ 	actual_hazard_this_instance, schedule_unit, actual_hazard,
+ 	potential_hazard, insn_issue_delay, init_target_units,
+ 	insn_print_units, print_block_visualization,
+ 	visualize_scheduled_insns, visualize_no_unit,
+ 	visualize_stall_cycles): Don't define them for automaton pipeline
+ 	interface.
+	(void remove_new_cpu_cycle_marks): Define it for automaton
+ 	pipeline interface.
+	(insn_cost): Add code for evaluation insn cost for automaton
+ 	pipeline interface.  Use negative cost as undefined value for
+ 	automaton pipeline interface.
+	(priority): Use negative priority as undefined value for automaton
+ 	pipeline interface.
+	(schedule_insn): Add code for automaton pipeline interface.
+	(queue_to_ready): Ditto.
+	(get_visual_tbl_length):
+	(MD_SCHED_INIT, MD_SCHED_REORDER, MD_SCHED_VARIABLE_ISSUE):
+	(MD_AUTOMATON_SCHED_INIT, MD_AUTOMATON_SCHED_REORDER):
+	(schedule_block): Add code (including code for processing zero
+ 	cost dependencies) for automaton pipeline interface.
+	(debug_dependencies): Add code for automaton pipeline interface.
+	(schedule_region): Remove marks "new cpu cycle" after the first
+ 	insn scheduling when automaton pipeline interface is used.
+	(schedule_insns): Initialize insn_priority, insn_costs by -1 when
+ 	automaton pipeline interface is used.
+	
+Thu Dec  2 12:55:21 1999  Geoff Keating  <geoffk@cygnus.com>
+
+	* dbxout.c (dbxout_symbol_name): range_prefix is not constant.
+
+Wed Dec  1 02:53:28 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (ggc.h): Include.
+	(rel_record_mem): Record auto_inc as ggc root.
+
+1999-11-30  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/pe.c (arm_pe_unique_section):  Ignore relocs when
+	deciding if a section is read only, for EPOC toolchains only.
+
+Tue Nov 30 14:33:02 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c (mcore_unique_section): Ignore relocs when
+	deciding if a section is read only.
+
+Mon Nov 29 15:06:00 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_expand_prologue): Set reg_names for
+	RETURN_ADDRESS_REGNUM.
+	* config/ia64/ia64.h (RETURN_ADDRESS_REGNUM): Rename from RETURN_
+	ADDRESS_POINTER_REGNUM.
+	(GENERAL_REGNO_P, REG_ALLOC_ORDER):  Likewise, change uses.
+	(FIXED_REGISTERS, CALL_USED_REGISTERS, REGISTER_NAMES): Change RAP to
+	RA.
+	(RETURN_ADDR_RTX): Return REG instead of MEM.
+	(ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET): Drop RETURN_ADDRESS_
+	POINTER_REGNUM support.
+	
+Sun Nov 28 23:41:01 1999  Jeffrey A Law  (law@cygnus.com)
+
+
+	* hard-reg-set.h, regclass.c, reload1.c, config/z8k, invoke.texi:
+	Remove all traces of the z8k port.
+
+1999-11-28  Michael Meissner  <meissner@cygnus.com>
+
+	* d30v.c (toplevel): Move include of tree.h before expr.h.
+	(single_reg_memory_operand): Delete unused variable.
+	(cond_exec_operand): Ditto.
+	(d30v_expand_epilogue): Ditto.
+	(d30v_cond_move): Ditto.
+	(reg_or_0_operand): Add default case.
+	(condexec_binary_operator): Ditto.
+	(condexec_shiftl_operator): Ditto.
+	(cond_move_operand): Ditto.
+	(cond_exec_operand): Ditto.
+	(move_output_operand): Add ATTRIBUTE_UNUSED to unused parameter.
+	(signed16_operand): Ditto.
+	(unsigned5_operand): Ditto.
+	(unsigned6_operand): Ditto.
+	(condexec_branch_operator): Ditto.
+	(condexec_unary_operator): Ditto.
+	(condexec_addsub_operator): Ditto.
+	(condexec_binary_operator): Ditto.
+	(condexec_shiftl_operator): Ditto.
+	(branch_zero_operator): Ditto.
+	(d30v_function_arg): Ditto.
+	(d30v_function_arg_partial_nregs): Ditto.
+	(d30v_function_arg_pass_by_reference): Ditto.
+	(d30v_setup_incoming_varargs): Ditto.
+	(d30v_function_prologue): Ditto.
+	(d30v_function_epilogue): Ditto.
+	(d30v_function_profiler): Ditto.
+	(d30v_legitimize_address): Ditto.
+	(d30v_machine_dependent_reorg): Ditto.
+	(d30v_adjust_cost): Ditto.
+	(d30v_expand_builtin_va_arg): Properly scale arg_num when adding
+	it to the arg_ptr field.  Also increment the arg_num field and not
+	arg_ptr if we discover an 8 byte field is not d-word aligned.
+	(d30v_cond_move): Properly quote '%' in format that needs to be
+	printed as is.
+	
+1999-11-28  Diego Novillo <dnovillo@cygnus.com>
+
+	* d30v-protos.h (d30v_expand_builtin_va_start): Define.
+	(d30v_expand_builtin_va_arg): Define.
+	* d30v.c (d30v_build_va_list): New function.
+	(d30v_expand_builtin_va_start): New function.
+	(d30v_expand_builtin_va_arg): New function.
+	* d30v.h (BUILD_VA_LIST_TYPE): Define.
+	(EXPAND_BUILTIN_VA_START): Define.
+	(EXPAND_BUILTIN_VA_ARG): Define.
+
+Wed Nov 24 14:51:38 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm-pe.h (MULTILIB_DEFAULTS): Redefine.
+	* config/arm/epoc-pe.h (MULTILIB_DEFAULTS): Redefine.
+
+Tue Nov 23 17:54:29 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/t-pe (MULTILIB_DIRNAMES): Add apcs-32.
+
+1999-11-23  Kevin Buettner  <kevinb@cygnus.com>
+
+	* config/ia64/ia64.h, config/ia64/ia64.c (ia64_fp_regno): Declare.
+	* config/ia64/ia64.c (ia64_expand_prologue): Set ia64_fp_regno.
+	* config/ia64/sysv4.h (DBX_REGISTER_NUMBER): Redefine to map "in"
+	registers to r32 and up.  Also, map the virtual frame pointer to
+	the actual register chosen for use as the frame pointer.
+
+1999-11-22  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Rename arm/pe.h to arm/arm-pe.h
+	Add arm-wince-pe target.
+	* configure: Regenerate.
+
+	* config/arm/arm-pe.h: New File: Renamed version of pe.h
+	* config/arm/win-ce-pe.h: New File: Definitions specific to the
+	arm-wince-pe target.
+	* config/arm/strongarm-pe.h: Include arm-pe.h.
+	
+	* config/arm/semi.h (LIB_SPEC): Prevent multiple definitions.
+	(STARTFILE_SPEC): Prevent multiple definitions.
+	(USER_LABEL_PREFIX): Prevent multiple definitions.
+
+1999-11-22  Nick Clifton  <nickc@cygnus.com>
+
+	* config/pe.h (LIB_SPEC): Define.
+	(MATH_LIBRARY): Define.
+	(LIBSTDCXX): Define.
+	(DBX_DEBUGGING_INFO): Define.
+	(SDB_DEBUGGING_INFO): Define.
+	(PREFERRED_DEBUGGING_TYPE): Define.
+	(ASM_OUTPUT_LABELREF): Define.
+	(STRIP_NAME_ENCODING): Define.
+
+	* config/mips/mips-pe.h (LIB_SPEC): Delete.
+	(MATH_LIBRARY): Delete.
+	(LIBSTDCXX): Delete.
+	(DBX_DEBUGGING_INFO): Delete.
+	(SDB_DEBUGGING_INFO): Delete.
+	(PREFERRED_DEBUGGING_TYPE): Delete.
+	(ASM_OUTPUT_LABELREF): Delete.
+	(STRIP_NAME_ENCODING): Delete.
+
+	* config/sh/sh-pe.h (LIB_SPEC): Delete.
+	(MATH_LIBRARY): Delete.
+	(LIBSTDCXX): Delete.
+	(DBX_DEBUGGING_INFO): Delete.
+	(SDB_DEBUGGING_INFO): Delete.
+	(PREFERRED_DEBUGGING_TYPE): Delete.
+	(ASM_OUTPUT_LABELREF): Delete.
+	(STRIP_NAME_ENCODING): Delete.
+
+Wed Nov 17 13:01:02 1999  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* config/rs6000/rs6000.c (rs6000_prolog): Set up the 
+	PIC_OFFSET_TABLE_REGNUM for svr4 -fpic.
+	(rs6000_epilog): Use a real (return) insn for the final return.
+	* config/rs6000/rs6000.md (return_internal): Define.
+
+Mon Nov 15 20:07:40 1999  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* config/rs6000/rs6000.h: Don't define rs6000_branch_cost common.
+
+Mon Nov 15 17:45:00 1999  Richard Henderson  <rth@cygnus.com>
+
+	* ia64/t-ia64 (CRTSTUFF_T_CFLAGS): New.
+
+Mon Nov 15 15:14:50 1999  Richard Henderson  <rth@cygnus.com>
+
+	* ia64.md (minsf3, maxsf3): Use correct mnemeonic.
+	(mindf3, maxdf3): Likewise.
+
+Mon Nov 15 14:01:20 1999  Catherine Moore  <clm@cygnus.com>
+ 
+	* config/i386/i386-aout.h (ASM_DECLARE_FUNCTION_NAME): Define.
+	(ASM_DECLARE_FUNCTION_SIZE): Undefine.
+	* config/i386/i386-coff.h: Likewise.
+	* config/i386/win32.h (ENCODE_SECTION_INFO): Encode '+'.
+	(STRIP_NAME_ENCODING): Handle '+'.
+	* config/i386/i386.h (ASM_OUTPUT_ALTERNATE_LABEL): Use ASM_OUTPUT_LABEL.
+
+1999-11-15  Nick Clifton  <nickc@cygnus.com>
+
+	that shorts will not be loaded by potentially misaligned word
+	instructions.
+	* config/arm/epoc-pe.h (CC1_SPEC): 
+
+1999-11-15  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/t-pe (TARGET_LIBGCC2_CFLAGS): Define.
+
+Thu Nov 11 13:12:44 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.h: Tidy up accidental experimental code
+	inclusion from previous delta.
+
+Fri Nov 12 07:39:02 1999  Catherine Moore  <clm@cygnus.com>
+
+	* config/i386/cygwin.h (STRIP_NAME_ENCODING): Support '+'.
+	(FSA_STRIP_NAME_ENCODING): Define.
+	(ASM_OUTPUT_LABEL): Define.
+	* config/i386/winnt.c (i386_pe_encode_section_info): Encode
+	'+' for aligned entry points.
+	(i386_pe_declare_function_type): Use FSA_STRIP_ENCODING.
+
+1999-11-11  Michael Meissner  <meissner@cygnus.com>
+
+	* range.c (range_info_type): Rename from rinfo.  Change all uses.
+	(range_var_type): Rename from var_info.  Change all uses.
+	(range_mark): Use the same algorithm flow.c uses for calculating
+	the refs/defs.  Fix signed/unsigned comparison warnings.
+	(range_basic_mark): Fix signed/unsigned comparison warnings.
+	(live_range_print): Print out the original REFs, SETs, etc.
+	(range_inner): Delete unused variable.  Convert alloca's into
+	xmalloc/xcalloc and free's, varrays or sbitmaps.  Compare SETS and
+	REFS to determine if a variable exists solely within the range
+	instead of testing the LIVE_LENGTH.
+	(range_update_basic_block): Delete unused variable.
+	(range_finish): Convert alloca's to xmalloc/xcalloc and free's.
+	(live_range): Make insn_ruid a varray.  Convert other alloca's to
+	xmalloc/xcalloc and free's.  Start loop_depth at 1, not 0 to match
+	the algorithm flow.c uses.
+
+	* flow.c (mark_set_1): Add comment about calculating SETS/REFS,
+	needing to be consistent between flow.c/range.c.
+
+1999-11-11  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* c-common.c (c_get_alias_set): Put vector types in alias set zero.
+
+	* config/i386/i386.md (movv8qi, movv4hi, movv2si): Rename to
+	movv8qi_internal, movv4hi_internal, movv2si_internal.  Add
+	expanders for these move instructions.
+	(pushv8qi, pushv4hi, pushv2si): New patterns.
+	Add splitters for MMX pushes.
+
+CYGNUS LOCAL always-false/gavin
+1999-11-11  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/mips.c (mips_outpu_conditional_branch):
+	Use nops for branches that are always false.
+
+END CYGNUS LOCAL always-false/gavin
+Wed Nov 10 11:37:12 1999  Catherine Moore  <clm@cygnus.com>
+
+	* config/i386/i386.c (output_pic_addr_const):  Don't
+	add .aligned to name unless operand code is 'P'.
+	(print_operand): Likewise.
+
+Tue Nov  9 19:54:29 1999 Andrew MacLeod  <amacleod@cygnus.com>
+ 
+	* config/i386/i386.c (ix86_expand_prologue_fsa): Enable dwarf2
+	unwinding for prologue.
+
+Sat Nov  6 17:38:45 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* ssa.c (convert_to_ssa): Use compute_flow_dominators.  Do not
+	pass in a pdom array since we do not need pdoms.
+
+Sat Nov  6 07:41:23 1999  Catherine Moore  <clm@cygnus.com>
+
+	* config/i386.c (build_aligned_name): New.
+	(ix86_expand_prologue_fsa): Support aligned entry point.
+	Change to save %ebp first.
+	(ix86_expand_epilogue_fsa): Change %ebp restore.
+	(ix86_encode_section_info): New.
+	(output_pic_addr_const): Handle aligned name.
+	(print_operand): Likewise.
+	(print_operand_address): Likewise.
+	* config/i386.h (ASM_DECLARE_FUNCTION_NAME): Define.
+	(ASM_DECLARE_FUNCTION_SIZE): Define.
+	(SAME_FILE_CHAR): Define.
+	(SAME_FILE_NAME): Define.
+	(STRIP_NAME_ENCODING): Define.
+	(ENCODE_SECTION_INFO): Redefine.
+	(ASM_OUTPUT_LABEL): Redefine.
+	(ASM_OUTPUT_ALTERNATE_LABEL_NAME): Define.
+	(BUILD_ALIGNED_NAME): Define.
+
+Thu Nov  4 23:49:51 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* Merge Snapshot 1999-11-02, except for regclass.c.
+	
+Wed Nov  3 12:12:59 1999  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* config/i386/t-intrin: New file.
+	* config/i386/xmm_utils.h: New file.
+	* config/i386/xmmintrin.h: New file.
+	* config/i386/mmintrin.h: New file.
+	* configure.in: Add t-intrin to tmake_file for i386 targets.
+
+1999-11-02  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add strongarm-pe target.
+	* configure: Regenerate.
+	
+	* config/arm/strongarm-pe.h: New file.  Define strongarm-pe
+	specific macros.
+	* config/arm/t-strongarm-pe: New file.  Makefile fragment for
+	building strongarm-pe targetted toolchain.
+	
+Mon Nov  1 20:37:43 1999  Catherine Moore  <clm@cygnus.com>
+
+	* i386.h (TARGET_SIMD): Enable.
+	(SIMD_ALIGNMENT): Define.
+	(FUNCTION_ARG_BOUNDARY): Define.
+	(TARGET_FORCE_STACK_ALIGNMENT): Define.
+	(SIMD_MODE_P): Define.
+	(ARG_POINTER_REGNUM): Conditionally set.
+	(ELIMINABLE_REGS): Can't always eliminate the arg pointer.
+	(CAN_ELIMINATE): Likewise.
+	(INITIAL_ELIMINATION_OFFSET): Redefine.  Call routines.
+	* i386.c (ix86_compute_frame_size_fsa): New routine.
+	(ix86_expand_prologue_fsa): New routine.
+	(ix86_expand_epilogue_fsa): New routine.
+	(ix86_initial_elimination_offset_fsa): New routine.
+	(ix86_initial_elimination_offset): New routine.
+	(print_reg): Check for NORMAL_ARG_POINTER_REGNUM.
+	* i386.md (prologue): Call simd-specific routine if forcing stack.
+	(epilogue): Likewise.
+	* i386-protos.h (ix86_initial_elimination_offset): New prototype.
+	(ix86_initial_elimination_offset_fsa): New prototype.
+	(ix86_compute_frame_size_fsa): New prototype.
+
+Mon Nov  1 11:58:38 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* toplev.c (compile_file): Rename .ssa -> .033.ssa
+	Rename .ussa -> .037.ussa
+	Rename .range -> .115.range
+	(rest_of_compilation): Ditto.
+
+Fri Oct 29 18:02:35 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md (shift_mix4left, shift_mix4left+1,
+	shift_mix4left+2, mix4left): Use register_operand not reg_or_0_operand.
+
+Thu Oct 28 14:34:10 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64-protos.h (sdata_symbolic_operand,
+	ia64_encode_section_info): New prototypes.
+	* config/ia64/ia64.c: Move tree..h include after rtl.h.  Include
+	tm_p.h and basic-block.h.
+	(ia64_section_threshold): New global variable.
+	(sdata_symbolic_operand, ia64_encode_section_info): New functions.
+	(ia64_expand_prologue): New locals epilogue_p, e.  Set epilogue_p if
+	there is an epilogue.  Only save b0 if epilogue_p true.
+	(ia64_override_options): Set ia64_section_threshold.
+	* config/ia64/ia64.h (ENCODE_SECTION_INFO): Call
+	ia64_encode_section_info.
+	(SDATA_NAME_FLAG_CHAR, IA64_DEFAULT_GVALUE, STRIP_NAME_ENCODING): New
+	macros.
+	(ASM_NAME_TO_STRING): Call STRIP_NAME_ENCODING.
+	(PREDICATE_CODES): Add sdata_symbolic_operand.
+	* config/ia64/ia64.md (movdi): Call gen_load_gprel.
+	(load_gprel): New pattern.
+	* config/ia64/sysv4.h (ASM_OUTPUT_ALIGNED_LOCAL): Call sbss_section.
+	(ASM_OUTPUT_LABELREF): Call STRIP_NAME_ENCODING.
+	(SELECT_SECTION, EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS,
+	SDATA_SECTION_ASM_OP, SDATA_SECTION_FUNCTION, SBSS_SECTION_ASM_OP,
+	SBSS_SECTION_FUNCTION): New.
+
+Thu Oct 28 12:28:48 1999  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+
+	* rtl.texi (Vector Operations): New node.
+	(Arithmetic): Add ss_plus, us_plus, ss_minus, us_minus.
+	(Comparisons): Add unord.
+	(Conversions): Add ss_truncate, us_truncate.
+	* tm.texi (VECTOR_MODE_SUPPORTED_P): Document.
+	(MD_INIT_BUILTINS): Document.
+	(MD_EXPAND_BUILTIN): Document.
+
+1999-10-28  Fred Fish  <fnf@be.com>
+
+	* config/i386/beos-elf.h (CC1PLUS_SPEC): Remove fields that duplicate
+	what are in CC1_SPEC.  Everything in CC1_SPEC already gets passed
+	to cc1plus.
+
+1999-10-23  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* c-common.c: Fix unterminated END CYGNUS LOCAL comment.
+
+Thu Oct 21 12:40:20 1999  Jonathan Larmour  <jlarmour@cygnus.co.uk>
+
+	* config/arm/t-arm-elf (MULTILIB_OPTIONS): Add -mcpu=arm7 multilib...
+	(MULTILIB_DIRNAMES): ...in directory nofmult...
+	(MULTILIB_EXCEPTIONS): ...but don't need to build it with
+	thumb-interwork
+	(MULTILIB_MATCHES): And make sure it matches all the relevant CPUs
+
+	* config/arm/elf.h (MULTILIB_DEFAULTS): include
+	-fno-leading-underscore to prevent unnecessary multilib
+
+Wed Oct 20 17:27:03 1999  Richard Henderson  <rth@cygnus.com>
+
+	* d30v.md (addsi3_set_carry): Add mode to unspec source.
+	(addsi3_use_carry): Likewise.
+	(return_internal): New.
+	* d30v.c (d30v_expand_epilogue): Use return_internal.
+
+Wed Oct 20 16:15:50 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64-protos.h: Use PARAMS instead of PROTO.
+	(ia64_va_start, ia64_va_arg): New.
+	* config/ia64/ia64.c (ia64_expand_prologue): Call
+	gen_prologue_allocate_stack.
+	(ia64_expand_epilogue): Call gen_epilogue_deallocate_stack.
+	(ia64_va_start, ia64_va_arg): New.
+	* config/ia64/ia64.h (EXPAND_BUILTIN_VA_START, EXPAND_BUILTIN_VA_ARG):
+	New.
+	* config/ia64/ia64.md (prologue_allocate_stack,
+	epilogue_deallocate_stack): New.
+	
+Fri Oct 22 12:18:14 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* range.c (range_mark): Make fmt const char *.
+	(range_basic_mark): Ditto.
+
+
+Thu Oct 21 20:18:12 1999  Jim Wilson <wilson@cygnus.com>
+			  Jeff Law <law@cygus.com>
+
+	* range.c: Include ggc.h.
+	(init_live_range): Call ggc_add_rtx_root for live_range_list.
+	* Makefile.in (range.o): Update dependencies.
+
+1999-10-21  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* i386.md (mmx_pinsrw): Accept a SImode value as arg 2, and put a
+	truncate around it.
+	Fix generated assembly to have operands in right order.
+	(mmx_pextrw): Fix generated assembly to have operands in right order.
+	(mmx_pshufw): Likewise.
+	(mmx_packuswb): Fix generated opcode name.
+	* i386.c (bdesc_2arg): Generate MMX pack insn builtins by hand.
+	Remove MMX pshufw from this table.
+	(ix86_init_builtins): Initialize v4sf_ftype_v4sf_v2si properly.
+	Likewise for v4sf_ftyp_v4sf_v4sf_int.
+	Delete some unused types.
+	Define MMX pack buitlins by hand.
+	Fix generation of MMX pinsrw builtin.
+	(ix86_expand_builtin): Return const0_rtx, not zero, if failing due to
+	a user error.
+	Handle MMX pshufw specially, not by normal binop code.
+
+Wed Oct 20 14:29:15 1999  Geoff Keating  <geoffk@cygnus.com>
+
+	* config/rs6000/sysv4.h (CPP_OS_VXWORKS_SPEC): Always handle 740/750.
+
+Tue Oct 19 16:35:47 1999  Andrew Haley  <aph@cygnus.com>
+
+	* config/rs6000/rs6000.md: (extendhisi2+2) Add missing splitter.
+
+Tue Oct 19 13:04:06 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64-protos.h (ia64_compare_op1): Delete '*' from decl.
+	* config/ia64/ia64.c (ia64_expand_prologue): Add ifdefed out code to
+	Handle syscall_linkage attribute.
+	(ia64_add_gc_roots): Move definition before first use.
+	* config/ia64/ia64.md: Add missing = constraints.  Add modes to unspec
+	used in set source.
+ 	(insv): Call gen_shift_mix4left instead of gen_mix4left.
+	(shift_mix4left): New pattern.
+	(shift_mix4left+1, shift_mix4left+2): New splits.
+	
+Mon Oct 18 22:59:13 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* config/d10v/d10v.c (emit_move_word): Fixed the 10/12/1999 bogus
+	patch.
+
+1999-10-19  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-pe.h: (SUPPORTS_ONE_ONLY): Define.
+	(ASM_OUTPUT_SECTION_NAME): Define.
+
+Mon Oct 18 22:19:38 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/rs6000/rs6000.md (extzv+5, extzv+10): Use match_operand
+	not match_dup.
+	(loadsi_svr4_relocatable_toc, loaddi_svr4_relocatable_toc,
+	loadsi_nonsvr4_toc, loaddi_nonsvr4_toc): Add = constraints to clobbers.
+
+	* config/d30v/d30v.md (addsi3_internal, subsi3_internal): Add missing
+	= constraints to clobbers.
+	* config/sh/sh.md (mulsidi3, umulsidi3): Add missing = constraints
+	on output operands.
+
+Mon Oct 18 17:20:27 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/v850/v850.md (return_internal+3): Add missing = constraint
+ 	on operand 2.
+
+Sun Oct 17 20:33:25 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* convert.h (convert_to_vector): Declare.
+
+1999-10-15  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* i386.c (bdesc_comi, bdesc_2arg, bdesc_1arg): Avoid uninitialized
+	structure element warnings.
+	(ix86_init_builtins): Add __builtin_ia32_mmx_zero; change type of
+	__builtin_ia32_setzerops.
+	(safe_vector_operand): New function.
+	(ix86_expand_binop_builtin, ix86_expand_store_builtin,
+	ix86_expand_unop_builtin, ix86_expand_unop1_builtin,
+	ix86_expand_sse_compare, ix86_expand_sse_comi): Use it.
+	Renumber arg1/arg2 variables to arg0/arg1 to match op0/op1.
+	(ix86_expand_builtin): Renumber arg variables.
+	Expand __builtin_ia32_mmx_zero.  Change type of
+	__builtin_ia32_setzerops.
+	* i386.h (enum ix86_builtins): Add IX86_BUILTIN_MMX_ZERO.
+	* i386.md (sse_clrti3, mmx_clrdi3): New pattern.
+	(cvtps2pi, cvttps2pi, cvtss2si, cvttss2si): Fix operand numbers.
+	
+	* rtl.def (vec_reorder): Delete rtx code.
+	* i386.md: Replace vec_reorder with vec_select in all patterns that
+	use it.
+
+Wed Oct 13 14:21:42 MDT 1999	Diego Novillo <dnovillo@cygnus.com>
+
+	* config/d10v/d10v.h (GPR_P): Include AP in the set of general
+	purpose registers.
+	* config/d10v/d10v.h: Close several comments to avoid compiler
+	warnings when compiling with -Wall. 
+
+Wed Oct 13 19:43:32 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/v850/v850.md (shift): Delete SImode from label_ref operand.
+
+Tue Oct 12 22:52:36 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (install-common): Install fixinc.sh in CYGNUS LOCAL
+	binary installation support code.
+
+Tue Oct 12 08:34:21 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* config/d10v/d10v.c (emit_move_word): Have symbol+constant loads
+ 	followed by `@word'.
+
+Mon Oct 11 21:09:41 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/d30v/d30v-protos.h: Rewrite.
+	* config/d30v/d30v.c: Include tm_p.h, toplev.h.  Change all uses of
+	int mode to be enum machine_mode mode instead.  Change Rtx to rtx.
+	(d30v_add_gc_roots): Declare.
+
+Mon Oct 11 20:12:44 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/d10v/d10v.c: Include tm_p.h, toplev.h.  Change uses of Rtx and
+	struct rtx_def * to rtx.
+	(d10v_add_gc_roots): Declare.
+	(minmax_parallel_operator): Add missing arg to gpr_operand and
+	accum_operand calls.
+	* config/d10v/d10v.h: Delete extern declarations.
+	* config/d10v/d10v-protos.h: New file.  Move extern declarations here.
+	
+Mon Oct 11 12:11:36 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/lib1funcs.asm (udivdi3, umoddi3): Rewrite.
+	* config/ia64/t-ia64 (LIBGCC1): Define.
+	* config/ia64/xm-ia64.h (HOST_BITS_PER_LONGLONG): Define.
+
+Mon Oct 11 12:05:17 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* ia64.h (enum reg_class): Move PR_REGS and BR_REGS to beginning.
+	(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Likewise.
+	(JUMP_TABLES_IN_SECTION): Add comment.
+	* ia64.md (movcc): Add comment.
+
+1999-10-10  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* config/mips/mips-protos.h: Prototype mips_expand_epilogue with
+ 	extra parameter.
+	* config/mips/mips.md (epilogue): Pass parameter to
+ 	mips_expand_epilogue.
+
+	* config/mips/mips.h: Don't declare language_string.
+
+1999-10-07  Brendan Kehoe  <brendan@cygnus.com>
+
+	* rs6000.h (EXPAND_BUILTIN_SAVEREGS): Delete, since
+	rs6000_expand_builtin_saveregs is also gone.
+
+	* d10v/d10v.c (d10v_expand_builtin_saveregs):
+	Remove unused argument.
+	* d10v/d10v.h (EXPAND_BUILTIN_SAVEREGS): Likewise.
+	* d30v/d30v.c (d30v_expand_builtin_saveregs):
+	Likewise.
+	* d30v/d30v.h (EXPAND_BUILTIN_SAVEREGS): Likewise.
+
+Wed Oct  6 23:02:34 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* gcc.c (default_compilers, @cpp-output case): Fix a typo.
+
+Tue Oct  5 20:53:59 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d30v.c (cond_move_operand): Make sure MEMs have legitimate addresses.
+
+Tue Oct  5 11:29:56 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* jump.c (jump_optimize_1): Change a nested comment.
+
+Mon Sep 27 13:28:26 PDT 1999 Don Lindsay <dlindsay@cygnus.com>
+
+	* toplev.c - moved init_printf_formats() call out. Broke non-C links.
+	* c-lang.c - moved init_printf_formats() call in to lang_init().
+
+Fri Sep 24 17:19:05 PDT 1999  Don Lindsay  <dlindsay@hound.cygnus.com>
+
+	* Added extensions to allow "-fprintf-formats=<file>", which parses a
+	file in and allows it to override normal printf format codes.
+	* invoke.texi: Give semantics for use of new features.
+	* c-tree.h: Add an extern so toplev.c can call the format file parser.
+	* flags.h: Get cc1 to accept new flag, with attached pathname.
+	* gcc.c: gcc accepts new flag, restamps filename to pathname
+	using the -B path.  Done by new routine check_flag_for_restamp()
+	called from give_switch().
+	* toplev.c: Changed documented_lang_options[] so the help
+	printout prints the new flag.  Added call to init_printf_formats()
+	to compile_file().  Added flag recognizer to decode_f_option().
+	* c-common.c: Minor cleanups, such as using ISDIGIT consistently
+	instead of sometimes.  Use switch on table type consistently, ditto.
+	Extended type format_char_info with more flags and types, extended all
+	three static variables of this type with nuls.  Added
+	init_printf_formats() and supporting tables and routines
+	char_to_string(), upto_semi(), string_to_type(),
+	read_printf_format_file().  They collectively parse a printf-format
+	file.  Added ptr_print_char_table which by default points to
+	print_char_table[], but can be swung to a dynamically allocated table
+	containing the results of parsing the printf-format file.  Changes to
+	check_format_info() to use the new table and check the new class of
+	inputs.  Portions of check_format_info() split out into new routines
+	name_of_actual_type() and compare_format_types().
+
+Thu Sep 23 21:01:27 1999  Andrew Haley  <aph@cygnus.com>
+
+	* config/sh/sh.md: Guard insn splits against illegal registers.
+	* config/sh/sh.h: Correct comment about macros.
+
+Mon Sep  6 10:23:10 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.h (MD_SCHED_REORDER): Update definition to use
+	new parameters to this macro.
+
+Wed Aug 25 12:55:08 1999  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* c-decl.c (c_decode_option): Add -Wparentheses-else.
+	(warn_parentheses_else): New variable to track it.
+	* c-common.c (c_expand_start_else): Honour it.
+	* c-tree.h (warn_parentheses_else): Declare it.
+
+	* toplev.c (W_options): Add -Wlongjmp-clobbers.
+	(main): Warn about it without -O.
+	* function.c (uninitialized_vars_warning): Honour it.
+
+Wed Aug 11 18:28:07 EDT 1999    Diego Novillo <dnovillo@cygnus.com>
+
+	* config/mips/mips.c (mips_move_2words): Emit two li insns for
+	32-bit targets.
+
+Tue Sep 28 18:10:53 PDT 1999    Diego Novillo <dnovillo@cygnus.com>
+
+	* config/d30v/d30v-protos.h: New file. Move prototypes from
+	d30v.h.
+
+Tue Sep 28 18:27:55 PDT 1999    Michael Meissner <meissner@cygnus.com>
+
+	* config/d30v/d30v.c (gpr_operand): Check for invalid subreg
+	operands.
+	(accum_operand): Idem.
+	(gpr_or_accum_operand): Idem.
+	(cr_operand): Idem.
+	(repeat_operand): Idem.
+	(flag_operand): Idem.
+	(br_flag_operand): Idem.
+	(br_flag_or_constant_operand): Idem.
+	(gpr_or_br_flag_operand): Idem.
+	(f0_operand): Idem.
+	(f1_operand): Idem.
+	(carry_operand): Idem.
+	(gpr_or_signed6_operand): Idem.
+	(gpr_or_unsigned5_operand): Idem.
+	(gpr_or_unsigned6_operand): Idem.
+	(gpr_or_constant_operand): Idem.
+	(gpr_or_dbl_const_operand): Idem.
+	(gpr_or_memory_operand): Idem.
+	(move_input_operand): Idem.
+	(move_output_operand): Idem.
+	(condexec_branch_operator): Idem.
+
+Tue Sep 28 19:21:04 PDT 1999    Diego Novillo <dnovillo@cygnus.com>
+
+	* config/d30v/d30v.h: Move prototypes to d30v-protos.h.
+
+Fri Oct  1 17:59:45 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d30v.md (*bra_true, *bra_false): Fix operand number for sanity test.
+
+Fri Oct  1 17:51:54 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d30v.c (d30v_stack_info, d30v_expand_epilogue):
+	Take current_function_pretend_args_size into account.
+	* d30v.h (INITIAL_ELIMINATION_OFFSET): Likewise.
+
+1999-09-30  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* i386.md (movsi_1, movsi_2): Separate MMX alternatives from
+	the others.
+
+Wed Sep 29 15:00:10 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mips/mips.c: Rename make_temp_file to
+	mips_make_temp_file to avoid conflict with prototype in
+	include/libiberty.h.
+	(mips_fill_delay_slot): Add const qualifier to return type and
+	first parameter to match prototype in mips-proto.h
+	Perform some simple text merges with respect to EGCS.
+	* config/mips/mips.h: Add const qualifier to return type of
+	mips_fill_delay_slot.
+	Perform some simple text merges with respect to EGCS.
+	* config/mips/mips.md (fix_truncdfdi2): Delete third parameter
+	to invocation of mips_move_2words.
+	(fix_truncsfdi2): Delete third parameter to invocation of
+	mips_move_2words.
+	(epilogue): Delete spurious argument to invocation of
+	mips_expand_epilogue. 
+
+1999-09-29  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* i386.md (movsi_1, movsi_2, movdi_1, movdi_2): Mark MMX
+	alternatives as unwanted.
+	(mmx_anddi3, mmx_xordi3, mmx_iordi3, mmx_nanddi3): Put an UNSPEC
+	around the operation.
+
+1999-09-29  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	Add SIMD insns and builtins for Pentium III.
+	* i386-protos.h (ix86_init_builtins, ix86_expand_builtin,
+	sse_comparison_operator): Declare.
+	* i386.c (sse_comparison_operator): New function.
+	(ix86_attr_length_default): Handle TYPE_SIMD.
+	(def_builtin): New macro.
+	(struct builtin_description): New.
+	(bdesc_comi, bdesc_2arg, bdesc_1arg): New arrays.
+	(ix86_init_builtins, ix86_expand_builtin, ix86_expand_binop_builtin,
+ 	ix86_expand_unop_builtin, ix86_expand_store_builtin,
+	ix86_expand_sse_compare, ix86_expand_sse_comi): New functions.
+	* i386.h (VECTOR_MODE_SUPPORTED_P): New macro.
+	(enum ix86_builtins): New.
+	(MD_INIT_BUILTINS, MD_EXPAND_BUILTIN): New macros.
+	(PREDICATE_CODES): Add sse_comparison_operator.
+	* i386.md (attr "type"): Add "simd".
+	(attr "memory"): Handle "simd" without a crash.
+	(movsi_1, movsi_2, movdi_1, movdi_2): Allow MMX regs.
+	(movdi splits): Don't split moves involving MMX regs.
+	(setcc_4): Remove '*' from pattern name so we get a gen_setcc4.
+	(call value patterns): Allow MMX and SIMD return registers.
+	(movv4sf_internal, movv4si_internal, movv8qi, movv4hi, movv2si,
+	movv4sf, movv4si, pushv4sf, pushv4si, vector push splitters,
+	sse_movaps, sse_movups, sse_movmskps, mmx_pmovmskb, mmx_maskmovq,
+	sse_movntv4sf, sse_movntdi, sse_movhlps, sse_movlhps, sse_movhps,
+	sse_movlps, sse_loadss, sse_movss, sse_storess, sse_shufps,
+	addv4sf3, vmaddv4sf3, subv4sf3, vmsubv4sf3, mulv4sf3, vmmulv4sf3,
+	divv4sf3, vmdivv4sf3, rcpv4sf2, vmrcpv4sf2, rsqrtv4sf2, vmrsqrtv4sf2,
+	sqrtv4sf2, vmsqrtv4sf2, sse_andti3, sse_nandti3, sse_iorti3,
+ 	sse_xorti3, maskcmpv4sf3, maskncmpv4sf3, vmmaskcmpv4sf3,
+ 	vmmaskncmpv4sf3, sse_comi, sse_ucomi, sse_unpckhps, sse_unpcklps,
+	smaxv4sf3, vmsmaxv4sf3, sminv4sf3, vmsminv4sf3, cvtpi2ps, cvtps2pi,
+	cvttps2pi, cvtsi2ss, cvtss2si, cvttss2si, addv8qi3, addv4hi3,
+	addv2si3, ssaddv8qi3, ssaddv4hi3, usaddv8qi3, usaddv4hi3, subv8qi3,
+	subv4hi3, subv2si3, sssubv8qi3, sssubv4hi3, ussubv8qi3, ussubv4hi3,
+	mulv4hi3, smulv4hi3_highpart, umulv4hi3_highpart, mmx_pmaddwd,
+	mmx_iordi3, mmx_xordi3, mmx_anddi3, mmx_nanddi3, mmx_uavgv8qi3,
+	mmx_uavgv4hi3, mmx_psadbw, mmx_pinsrw, mmx_pextrw, mmx_pshufw,
+	eqv8qi3, eqv4hi3, eqv2si3, gtv8qi3, gtv4hi3, gtv2si3, umaxv8qi3,
+	smaxv4hi3, uminv8qi3, sminv4hi3, ashrv4hi3, ashrv2si3, lshrv4hi3,
+	lshrv2si3, mmx_lshrdi3, ashlv4hi3, ashlv2si3, mmx_ashldi3,
+	mmx_packsswb, mmx_packssdw, mmx_packuswb, mmx_punpckhbw,
+	mmx_punpckhwd, mmx_punpckhdq, mmx_punpcklbw, mmx_punpcklwd,
+	mmx_punpckldq, emms, sfence, ldmxcsr, prefetch, stmxcsr): New patterns.
+
+1999-09-28  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	Add MMX registers in i386 machine description.
+	* freebsd-elf.h (DBX_REGISTER_NUMBER): Add MMX regs.
+	* i386elf.h (DBX_REGISTER_NUMBER): Likewise.
+	* linux.h (DBX_REGISTER_NUMBER): Likewise.
+	* ptx4-i.h (DBX_REGISTER_NUMBER): Likewise.
+	* rtemself.h (DBX_REGISTER_NUMBER): Likewise.
+	* sco5.h (DBX_REGISTER_NUMBER): Likewise.
+	* unix.h (VALUE_REGNO): VECTOR_MODE values go to FIRST_SIMD_REG.
+	* i386.h (TARGET_CMOVE): Use ix86_arch, not CPUMASK.
+	(TARGET_SIMD): Likewise.
+	(MAX_INTEGER_COMPUTATION_MODE): Delete some superfluous code.
+	(BIGGEST_ALIGNMENT): 128 if TARGET_SIMD.
+	(ALIGN_MODE_128): New macro.
+	(CONSTANT_ALIGNMENT): Use it to determine which values need to be
+	128 bit aligned.
+	(DATA_ALIGNMENT): Likewise.
+	(LOCAL_ALIGNMENT): Likewise.
+	(FIRST_PSEUDO_REG): Increase by 8.
+	(FIXED_REGISTERS): Add entries for MMX regs.
+	(CALL_USED_REGS): Likewise.
+	(REG_ALLOC_ORDER): Likewise.
+	(HI_REGISTER_NAMES): Likewise.
+	(CONDITIONAL_REGISTER_USAGE): Make MMX/SIMD regs fixed if not
+	TARGET_SIMD.
+	(HARD_REGNO_NREGS): 1 for MMX regs.
+	(VALID_SIMD_REG_MODE, VALID_MMX_REG_MODE): New macros.
+	(HARD_REGNO_MODE_OK): Better checks for SIMD/MMX regs.
+	(FIRST_MMX_REG, LAST_MMX_REG, MMX_REGNO_P, MMX_REG_P): New macros.
+	(RETURN_IN_MEMORY): For now, return MMX vectors in memory.
+	(enum reg_class): Add MMX_REGS.
+	(REG_CLASS_NAMES): Likewise.
+	(REG_CLASS_CONTENTS): Likewise.
+	(REG_CLASS_FROM_LETTER): 'y' for MMX regs.
+	(SECONDARY_MEMORY_NEEDED): Be conservative about copying between
+	SIMD/MMX regs and something else.
+	(CLASS_MAX_NREGS): 1 for SIMD and MMX regs.
+	(REGISTER_MOVE_COST): 10 if trying to move between MMX and SIMD regs,
+	3 if moving between MMX regs and something else.
+	* i386.c (mmx_reg_name): Delete.
+	(regclass_map): Add MMX registers.
+	(override_options): Add missing P3 entry in processor_target_table.
+	(print_reg): Use code 5 only for MMX_REG_P values, and print
+	hi_reg_name for mmx regs.
+	(print_operand): Add code to print XMMWORD as appropriate.
+	(ix86_split_movdi): Abort for MMX regs.
+	* dwarf2out.c (expand_builtin_dwarf_reg_size): Increase maximum number
+	of ranges by one.
+
+	* c-common.c (type_for_mode): Handle vector modes.
+	* c-convert.c (convert): Likewise.
+	* convert.c (convert_to_integer): Handle vector modes.
+	(convert_to_vector): New function.
+	* expr.c (convert_move): Handle vector modes.
+	* expmed.c (extract_bit_field): Don't abort for vector modes.
+	* tree.c (finish_vector_type): New function.
+	(build_common_tree_nodes_2): Use it rather than layout_type for
+	vector types.
+	* tree.h (TYPE_REPRESENATION_TYPE): New macro.
+	(TYPE_VECTOR_SUBPARTS): New macro.
+
+	* dbxout.c (dbxout_type): Handle VECTOR_TYPEs.
+	* dwarf.h (enum dwarf_fundamental_type): Add 128 bit integers.
+	* dwarf2out.c (lookup_type_die): Handle VECTOR_TYPEs.
+	(gen_type_die): Likewise.
+	* dwarfout.c (dwarf_fund_type_name): Handle 128 bit integers.
+	(fundamental_type_code): Likewise.
+	(type_is_fundamental): VECTOR_TYPEs aren't.
+	(output_type): Handle VECTOR_TYPEs.
+
+1999-09-27  Nick Clifton  <nickc@cygnus.com>
+
+	* config/d30v/d30v.h: Only define .md prototypes if
+	NO_MD_PROTOTYPES is not defined.
+
+Thu Sep 23 17:39:23 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64-protos.h: New file.
+	* config/ia64/ia64.c (IN_IA64_C): Delete.
+	* config/ia64/ia64.h: Delete all prototypes and associated macros.
+
+Wed Sep 22 11:30:45 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (JUMP_TABLES_IN_TEXT_SECTION): Define.
+	(ASM_OUTPUT_ADDR_VEC_ELT): Define to call abort.
+	(ASM_OUTPUT_CASE_END, ADDR_VEC_ALIGN, CASE_VECTOR_PC_RELATIVE): Define.
+	* config/ia64/ia64.md (tablejmp): New pattern.
+	(tablejmp_internal): Renamed from tablejmp.
+	* config/ia64/sysv4.h (ASM_OUTPUT_BEFORE_CASE_LABEL): Define to empty.
+
+Wed Sep 22 15:17:30 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-pe.h (UNIQUE_SECTION_P): Define.
+	* config/mcore/mcore.c (mcore_unique_Section): New function.
+	* config/mcore/mcore.h (UNIQUE_SECTION): Redefine.
+	(REDO_SECTION_INFO): Define.
+	(MULTIPLE_SYMBOL_SPACES): Define.
+	(SUPPORTS_ONE_ONLY): Define.
+
+Wed Sep 22 15:06:52 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-pe.h: Include svr3.h.
+	(SDB_DEBUGGING_INFO): Undefine.
+	(DBX_DEBUGGING_INFO): Redefine.
+	(SUBTARGET_SWITCH_SECTIONS): Add rdata_section.
+	(RDATA_SECTION_ASM_OP): Define.
+	(SUBTARGET_EXTRA_SECTIONS): Add in_rdata.
+	(SUBTARGET_EXTRA_SECTION_FUNCTIONS): Add RDATA_SECTION_FUNCTION.
+	(RDATA_SECTION_FUNCTION): Define.
+	(READONLY_DATA_SECTION): Redefine.
+	(SELECT_SECTION): Redefine.
+	(SELECT_SECTION_RTX): Redefine.
+	(CTORS_SECTION_ASM_OP): Redefine.
+	(DTORS_SECTION_ASM_OP): Redefine.
+	(INIT_SECTION_ASM_OP): Undefine.
+
+Wed Sep 22 11:11:22 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c: Synchronise with EGCS.
+
+Wed Sep 22 10:13:55 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.c: Suynchronise with sources contribuited
+	  to EGCS.    
+	* config/fr30/fr30.h: Suynchronise with sources contribuited
+	  to EGCS.
+	* config/fr30/fr30.md: Suynchronise with sources contribuited 
+	  to EGCS.
+	* config/fr30/crti.asm: Suynchronise with sources contribuited
+	  to EGCS.
+	* config/fr30/xm-fr30.h: Suynchronise with sources
+	  contribuited to EGCS.
+
+Sep 20 10:28:50 1999  Catherine Moore  <clm@cygnus.com>
+ 
+	* config/i386/i386.c (TARGET_PENTIUMIII): Check ix86_cpu.
+ 
+1999-09-15  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* tree.h (enum tree_index): Add vector type nodes.
+	Add accessor macros for them.
+	* tree.c (build_common_tree_nodes_2): Build these nodes.
+	* tree.def (VECTOR_TYPE): New node type.
+	* stor-layout.c (layout_type): Handle VECTOR_TYPE.
+
+Tue Sep 14 20:24:12 1999  Richard Henderson  <rth@cygnus.com>
+
+	* m32r/m32r.md (small_sequence small_parallel long_group): Replace
+	match_insn2 with match_insn.
+
+Mon Sep 13 00:32:43 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* function.c (purge_addressof): Unshare any shared rtl created by
+	purge_addressof and its children.
+
+Fri Sep 10 15:55:03 1999 Stan Cox <scox@cygnus.com>
+
+	* configure.in (i[456]86-*-*): Set target_requires_64bit_host_wide_int
+	so the x86 can define TImode.
+	* configure: Regenerate.
+
+	* dwarf2out.c (expand_builtin_dwarf_reg_size): Don't abort for
+	targets that define SImode registers in a different order.
+
+	* expr.c (check_max_integer_computation_mode): Check
+	MAX_INTEGER_COMPUTATION_OK.
+	(expand_expr): Likewise.
+
+	* tm.texi (MAX_INTEGER_COMPUTATION_OK): New
+
+	* i386/{freebsd-elf.h, i386elf.h, linux.h, ptx4-i.h,
+	rtemself.h, sco5.h, sysv4.h} (DBX_REGISTER_NUMBER): Added SIMD_REGS. 
+
+	* i386/unix.h (VALUE_REGNO): Added FIRST_SIMD_REG..
+
+	* i386.c (m_PIII, x86_simd, mmx_reg_name): New
+	(reg_class): Added SIMD_REGS
+	(processor_alias_table): Added pentiumiii
+	(ix86_valid_type_attribute_p): Added fastcall attribute
+	(init_cumulative_args): Also allow fastcall and SIMD_REGS
+	(function_arg_advance, function_arg): Likewise
+	(print_reg): Add 'm' to allow mmx registers to alias float registers.
+	Add case for TImode.
+	(ixx86_issue_rate, ix86_adjust_cost, ix86_sched_reorder,
+	ix86_variable_issue): Add PROCESSOR_PENTIUMIII.
+
+	* i386.h (TARGET_PENTIUMIII, x86_simd, TARGET_SIMD): New
+	(TARGET_SWITCHES, processor_type, ix86_arch): Add pentiumiii
+	(MAX_INTEGER_COMPUTATION_MODE, MAX_INTEGER_COMPUTATION_OK): New
+	for TImode.
+	(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS, CALL_USED_REGISTERS,
+	REG_ALLOC_ORDER, HARD_REGNO_NREGS, HARD_REGNO_MODE_OK,
+	reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS,REG_CLASS_FROM_LETTER,
+	HI_REGISTER_NAMES): Added simd registers
+	(FIRST_SIMD_REG, LAST_SIMD_REG, SIMD_REGNO_P): New
+	(RETURN_IN_MEMORY): TImode is returned in xmm0
+	(REG_PARM_STACK_SPACE): Added so the first three TImode parameters
+	also get stack space.
+	(MUST_PASS_IN_STACK): Added TImode to the default definition.
+	(CUMULATIVE_ARGS): Added decrement_regno for fastcall.
+	Added simd_* for SIMD_REGS.
+	(ADDITIONAL_REGISTER_NAMES): Added MMX register names
+	(MMX_REGISTER_NAMES): New
+
+	* i386.md (movti, *pushti, movti_internal): New for TImode.
+	(call_value+1): Added 'x' constraint
+
+Thu Sep  9 12:21:40 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_input_regs): Re-enable.
+	(ia64_expand_prologue): Set reg_names only if ! TARGET_REG_NAMES.
+	Re-enable code setting ia64_input_regs.  Emit sched blockage after
+	computing stack pointer when frame_pointer_needed.
+	(ia64_expand_prologue): Emit sched blockage before moving fp to sp.
+	(ia64_function_prologue): Re-enable ia64_input_regs code.
+	(rtx_needs_barrier): Don't force group end after sched blockage.
+	Alloc writes CFM.
+	* config/ia64/ia64.h (MASK_REG_NAMES, TARGET_REG_NAMES): New.
+	(TARGET_SWITCHES): Add -mregister-names option.
+	(RTX_COSTS): Make DIV, UDIV, MOD, UMOD expensive.
+	(ADDITIONAL_REGISTER_NAMES): Add sp.  Add all inX, outX, locX names.
+	* config/ia64/ia64.md (addsi3, subsi3, mulsi3, negsi2, abssi2, sminsi3,
+	smaxsi3, uminsi3, umaxsi3, one_cmplsi2): Implement.
+	(addsi3_internal, addsi3_plus1, subsi3_internal, subsi3_minus1,
+	mulsi3_internal, negsi2_internal, one_cmplsi2_internal,
+	cmovnesi_internal, cmovnesi_internal+1, abssi2_internal,
+	abssi2_internal+1): New.
+	(mulsidi3, smulsi3_highpart, umulsidi3, umulsi3_highpart, ffsi2):
+	Delete.
+
+1999-09-09  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* rtl.def (UNORD, VEC_MERGE, VEC_SELECT, VEC_CONCAT, VEC_REORDER,
+	VEC_CONST, VEC_DUPLICATE, SS_PLUS, SS_MINUS, SS_TRUNCATE,
+	US_TRUNCATE): New rtx codes.
+	* machmode.def: Add vector modes.
+	* machmode.h (enum mode_class): Add MODE_VECTOR_INT and
+	MODE_VECTOR_FLOAT.
+	(INTEGER_MODE_P): Check for MODE_VECTOR_INT.
+	(FLOAT_MODE_P): Check for MODE_VECTOR_FLOAT.
+	(VECTOR_MODE_P): New.
+
+Fri Sep  3 11:29:43 1999  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* config/mips/mips.c: Remove branch-alignment stuff, superceded
+	by changes to generic code (marked CYGNUS LOCAL law).
+	* config/mips/mips.h: Likewise.
+
+Mon Sep  6 18:32:59 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-pe.h: Import g++ ctor/dtor support from
+	arm-pe sources:
+	(INT_ASM_OP): Define.
+	(ASM_OUTPUT_CONSTRUCTOR): Define.
+	(ASM_OUTPUT_DESTRUCTOR): Define.
+	(CTORS_LISTS_DEFINED_EXTERNALLY): Define.
+	(DO_GLOBAL_CTORS_BODY): Undefine.
+	(DO_GLOBAL_DTORS_BODY): Undefine.
+
+Mon Sep  6 10:23:10 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.h (MD_SCHED_REORDER): Update definition to use
+	new parameters to this macro.
+Fri Sep  3 16:38:22 1999  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* config/sparc/sparc.c (SF_MODES64): New variable, don't
+	allow SI modes in FP registers (there's a problem with subregs).
+	(hard_64bit_mode_classes): Use it.
+	* config/sparc/sparc.md (floatsisf2): Turn into a define_expand,
+	work around not allowing SI modes in FP registers.
+	(floatsidf2): Likewise.
+	(floatsitf2): Likewise.
+	(fix_truncsfsi2): Likewise.
+	(fix_truncdfsi2): Likewise.
+	(fix_trunctfsi2): Likewise.
+
+1999-09-02  Richard Henderson  <rth@cygnus.com>
+
+	* stmt.c (expand_asm_operands): Remove CYGNUS LOCAL p2 markers.
+	* tm.texi (MD_ASM_CLOBBERS): Likewise.
+
+Wed Sep  1 15:10:11 1999  Richard Henderson  <rth@cygnus.com>
+
+	* flags.h, flow.c, genattrtab.c: Remove peep2 CYGNUS LOCAL markers.
+	* gencodes.c, genconfig.c, genemit.c, genextract.c: Likewise.
+	* genoutput.c, genpeep.c, genrecog.c, output.h, recog.c: Likewise.
+	* recog.h, rtl.h, toplev.c: Likewise.
+
+Tue Aug 31 14:55:51 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/t-pe (MULTILIB_DIRNAMES): Add interworking
+	mutlilibs. 
+
+Fri Aug 27 15:19:48 1999  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* rs6000.md: Add missing arg to rs6000_output_load_toc_table.
+
+Thu Aug 26 20:58:43 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (MASK_DWARF2_ASM, TARGET_DWARF2_ASM): New.
+	(TARGET_SWITCHES): Add -m[no-]dwarf2-asm options.
+	(TARGET_DEFAULTS): Add MASK_DWARF2_ASM.
+	(LABEL_ALIGN_AFTER_BARRIER): Ifdef out.
+	(DWARF2_ASM_LINE_DEBUG_INFO): Define.
+
+Wed Aug 25 12:34:39 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_epilogue_uses, ia64_valid_type_attribute):
+	New functions.
+	* config/ia64/ia64.h (IN_REGNO_P, EPILOGUE_USES,
+	VALID_MACHINE_TYPE_ATTRIBUTE): Define.
+	(ia64_epilogue_uses, ia64_valid_type_attribute): Declare.
+
+Wed Aug 25 13:59:44 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>
+
+	* gcse.c (alloc_gcse_mem): Clear modify_mem_list when allocated.
+	(free_gcse_mem): Re-cache any LIST nodes in modify_mem_list.
+	(record_last_mem_set_info): Use alloc routine instead of gen_rtx.
+	(compute_hash_table): Re-cache nodes in modify_mem_list instead 
+	of freeing them.
+	(next_set): Re-cache nodes in modify_mem_list instead of freeing.
+	(pre_delete): Use alloc routine instead of gen_rtx.
+	(pre_gcse): Re-cache EXPR_LIST nodes not needed.
+
+Tue Aug 24 14:29:27 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (struct ia64_frame_info): Add pretend_pad_size.
+	(ia64_compute_frame_size): New local pretend_pad_size.  Compute it,
+	include it in total_size, save it in current_frame_info.
+	(save_restore_insns): Subtract pretend_pad_size from offset.
+
+	* config/ia64/ia64.c (ia64_rp_regno): New.
+	(ia64_compute_frame_size): Don't save RP.  Eliminate scratch area only
+	if RP not live.
+	(ia64_expand_prologue): Increment locals.  Save RP in second to last
+	local register.  Save FP in third from last local register.  Set
+	ia64_rp_regno.
+	(ia64_expand_epilogue): Restore RP from ia64_rp_regno.
+	* config/ia64/ia64.h (FIXED_REGISTERS, CALL_CLOBBERED_REGISTERS):
+	Mark third from last local register as fixed.
+	(REG_ALLOC_ORDER): Deprecate R_GR (109) which is now fixed.
+	(RETURN_ADDR_RTX): Comment as broken now.
+	
+1999-08-24  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Change v850e and v850ea targets to use v850.h
+	header file.  Add code to allow cpu to be selected by
+	--with-cpu= command line switch to configure.
+
+	* configure: Regenerate
+
+	* config/v850/v850.h: Merge in contents of v850e.h and
+	v850ea.h.
+	(TARGET_CPU_generic, TARGET_CPU_v850e, TARGET_CPU_v850ea): Define.
+	(GO_IF_LEGITIMATE_ADDRESS): Insist that SImode and larger constant
+	addresses are 4 byte aligned.
+
+	* config/v850/v850e.h: Delete.
+	* config/v850/v850ea.h: Delete.
+
+	* config/v850/v850.c (print_operand): Cope with 'R' format DFmode
+	addresses.
+
+Fri Aug 20 16:36:59 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (IN_IA64_C): Define.
+	(call_operand): Accept SUBREG of REG.
+	(setjmp_operand): Add mode parameter.
+	(save_restore_insns): Use GR_REG (N) instead of N.
+	(ia64_print_operand): For 'P', handle POST_DEC.  Adding missing
+	closing brace.  For 'S', 'T', 'U', reindent.  For 'U', delete misplaced
+	closing brace.
+	(ia64_print_operand): Accept POST_DEC.
+	* config/ia64/ia64.h: Finish major cleanup.  Delete unnecessary
+	comments.  Add more useful comments.
+	Add prototypes for all ia64.c functions.
+	(STDIO_PROTO, Rtx, Tree, ia64_setup_incoming_varargs,
+	ia64_print_operand, ia64_print_operand_address): Move to end of file.
+	(Mode): New.
+	(CLEAR_INSN_CACHE, DIVDI3_LIBCALL, MODDI3_LIBCALL, UDIVDI3_LIBCALL,
+	UMODDI3_LIBCALL, SLOW_ZERO_EXTEND, ASM_FILE_START, ASM_OUTPUT_SKIP,
+	DBX_REGISTER_NUMBER): Delete.
+	(HAVE_POST_DECREMENT, GO_IF_MODE_DEPENDENT_ADDRESS, ADDRESS_COST,
+	PIC_OFFSET_TABLE_REGNUM, PIC_OFFSET_TABLE_REG_CALL_CLOBBERED,
+	ASM_COMMENT_START, ASM_OUTPUT_LONG_DOUBLE, ASM_OUTPUT_DEF,
+	LABEL_ALIGN_AFTER_BARRIER, ASM_NO_SKIP_IN_TEXT, REAL_ARITHMETIC,
+	PREDICATE_CODES, IMPLICIT_FIX_EXPR): Define.
+	(GO_IF_LEGITIMATE_ADDRESS): Add subreg support.
+	(CONST_COSTS): Add CONST_DOUBLE, CONST, SYMBOL_REF, LABEL_REF.
+	(RTX_COSTS): Comment out bogus definition.
+	(ASM_APP_ON, ASM_APP_OFF): Use # instead of //.
+	(ASM_OUTPUT_DOUBLE): Change %l to %08l.
+	(ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT): Delete spurious parens.
+	* config/ia64/ia64.md (call, call_value): Add missing argument to
+	symbolic_operand call.  Add new argument to setjmp_operand call.
+	(setjmp_call_pic, setjmp_call_value_pic, nonlocal_goto_receiver):
+	Use GR_REG (N) instead of N.
+	* config/ia64/linux.h (LINK_SPEC): Define.
+	* config/ia64/sysv4.h (ASM_OUTPUT_ALIGNED_DECL_LOCAL): Rename from
+	ASM_OUTPUT_ALIGNED_LOCAL.  Call ASM_DECLARE_OBJECT_NAME.
+	(ASM_IDENTIFY_GCC, ASM_DECLARE_FUNCTION_NAME,
+	ASM_DECLARE_FUNCTION_SIZE): Define.
+	(ASM_FILE_START): Add ifdefed out definition.
+	
+Sun Aug 15 12:02:55 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (call_multiple_values_operation,
+	ia64_rap_fp_offset, ia64_return_in_memory): New.
+	(ia64_compute_frame_size): Only set fr_pad_size if fr_size non-null.
+	(save_restore_insns): If frame_pointer_needed, use FP instead of SP.
+	(ia64_expand_prologue): Allocate output regs for profiling calls.
+	Check leaf_function before optimizing away alloc instruction.
+	(hfa_element_mode): Change abort to return VOIDmode.
+	(ia64_function_value): Rewrite to match ABI.
+	* config/ia64/ia64.h: Partial major cleanup.  Delete unnecessary
+	comments.  Add more useful comments.
+	(FIRST_PSEUDO_REGISTER): Increment.
+	(GENERAL_REGNO_P): Add return address pointer register.
+	(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER,
+	REG_CLASS_CONTENTS, ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET,
+	REGISTER_NAMES): Likewise.
+	(CONDITIONAL_REGISTER_USAGE, CAN_ELIMINATE): Delete.
+	(INCOMING_REGNO, OUTGOING_REGNO): Eliminate magic numbers.
+	(INDEX_REG_CLASS): Change from GENERAL_REGS to NO_REGS.
+	(RETURN_ADDR_RTX, INCOMING_RETURN_ADDR_RTX, INCOMING_FRAME_SP_OFFSET,
+	RETURN_ADDRESS_POINTER_REGNUM, MAX_INT_RETURN_SLOTS,
+	FUNCTION_ARG_BOUNDARY): Define.
+	(LIBCALL_VALUE): Handle MODE_COMPLEX_FLOAT.
+	(RETURN_IN_MEMORY): Reimplement to match ABI.
+	(STRUCT_VALUE): Delete.
+	(DEFAULT_PCC_STRUCT_RETURN, STRUCT_VALUE_REGNUM): Define.
+	(EPILOGUE_USES): Delete.
+	(EXIT_IGNORE_STACK): Define.
+	(ASM_OUTPUT_MI_THUNK, FUNCTION_PROFILER, FUNCTION_BLOCK_PROFILER,
+	BLOCK_PROFILER, FUNCTION_BLOCK_PROFILER_EXIT): Implement.
+	* config/ia64/ia64.md (movdi_internal): Add comment.
+	(movsf_internal): Add r/r alternative.
+	(setjmp_call_pic, call_pic, setjmp_call_value_pic, call_value_pic):
+	Change gp clobber to use.
+	(call_internal2, call_two_values_pic, call_value_internal2,
+	call_two_values_internal2): Delete.
+	(call_value): Call gen_call_multiple_values_pic instead of
+	gen_call_two_values_pic.
+	(call_multiple_values_pic, call_multiple_values_internal1): New.
+	
+Fri Aug 13 14:26:27 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* tree.c (lang_safe_for_unsave): New.
+	(save_for_usave): Call lang_save_for_unsave.
+	* tree.h (lang_safe_for_unsave): New.
+
+Thu Aug 12 15:00:51 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md: Append %B0 to all FP arithmetic and logical
+	instructions.
+	(movsf, movdf): Remove %B0.
+
+	* config/ia64/ia64.md (extendsidi2): Add type F attribute for fsxt.
+
+Tue Aug 10 09:40:24 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c: Include function.h
+
+	* config/mcore/mcore-elf.h (CTORS_SECTION_ASM_OP): Override
+	definition in svr4.h.
+	(DTORS_SECTION_ASM_OP): Override definition in svr4.h.
+
+Mon Aug  9 16:21:40 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h: Partial major cleanup.  Delete unnecessary
+	comments.  Add more useful comments.
+	(TARGET_SWITCHES): Add -mlittle-endian option.
+	(TARGET_VERSION): Define.
+	(BIGGEST_ALIGNMENT): Change from 64 to 128.
+	(MAX_FIXED_MODE_SIZE, INCOMING_REGNO, OUTGOING_REGNO): Define.
+	(REG_ALLOC_ORDER): Add frame pointer.  Reorder some registers.
+	* config/ia64/linux.h (CPP_PREDEFINES): Change duplicate __linux to
+	__linux__.
+
+Mon Aug  9 10:08:50 1999  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* dbxout.c: Include "function.h".
+	* expr.h (current_function_uses_expect): Delete declaration.
+	* function.c (current_function_uses_expect): Delete variable.
+	* function.h (current_function_uses_expect): New macro.
+	* range.c (live_range): Replace skip_flags mechanism with simpler
+	if statements.
+
+Fri Aug  6 11:11:40 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* t-generic: Update with recommended method to build software
+	floating point libraries.
+
+Thu Aug  5 21:07:37 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* ginclude/va-ia64.h: Change DEC Alpha to Intel ia64.
+	* config/ia64/ia64.h (CPP_SPEC): Add comment about __LONG_MAX__ define.
+
+Thu Aug  5 20:52:03 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_print_operand_address, case B): New.
+	* config/ia64/ia64.h (MASK_A0_BUGS, TARGET_A0_BUGS): New.
+	(TARGET_SWITCHES): Add -ma0-bugs option.
+	* config/ia64/ia64.md (movsf, movdf): Append %B0 to fp loads.
+
+Thu Aug  5 20:12:24 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md (rotrdi3_internal): Renamed from rotrdi3.
+	(rotrdi3): New define_expand.
+
+Thu Aug  5 17:22:24 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_input_regs): Ifdef out.
+	(ia64_reg_numbers, ia64_input_reg_names, ia64_local_reg_names,
+	ia64_output_reg_names): New arrays.
+	(ia64_expand_prologue): Set input, local, and output register names.
+	Ifdef out code setting ia64_input_regs.
+	(ia64_function_prologue): Ifdef out code using ia64_input_regs.
+	(hfa_element_mode): Add support for complex types.
+	(ia64_function_value): Add support for complex types.
+	(rtx_needs_barrier, case CALL): Handle pattern with multiple CALL rtx.
+	* config/ia64/ia64.md (call_value): Handle PARALLEL return values.
+	(call_two_values_pic, call_two_values_internal2): New patterns.
+
+Thu Aug  5 13:10:58 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/elf.h (ENDFILE_SPEC, STARTFILE_SPEC): Define.
+	* config/ia64/ia64.c (ia64_secondary_reload_class): Handle PR_REGS with
+	MEM operand.
+	* config/ia64/ia64.h (TARGET_SWITCHES): Correct help string for
+	-mno-gnu-as and -mno-gnu-ld options.
+	(HARD_REGNO_NREGS): Add PR_REGNO_P check to CCmode case.
+	(CLASS_MAX_NREGS): Rewrite patterned after HARD_REGNO_NREGS.
+	(NO_DOT_IN_LABEL): Comment out definition.
+	* config/ia64/ia64.md (movcc, movcc_internal, movcc_internal+1): New
+	patterns.
+	(sne_internal+1, seq_internal+1, cmovne_internal+1, cmoveq_internal+1,
+	absdi2_internal+1): Add reload_completed to condition.
+	* config/ia64/sysv4.h (ASM_OUTPUT_CONSTRUCTOR, ASM_OUTPUT_DESTRUCTOR):
+	Define.
+	* config/ia64/t-ia64 (LIBGCC2_DEBUG_CFLAGS): Disable definition.
+
+Wed Aug  4 11:57:29 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (REG_VOLATILE): New.
+	(NUM_REGS): Increment by one.
+	(rws_access_reg): Add explicit check for REG_AR_PFS.
+	(rtx_needs_barrier): Add ASM_INPUT case.  If asm is volatile, then
+	record write to REG_VOLATILE and return 1.
+	(emit_insn_group_barriers): Check if previous insn set REG_VOLATILE.
+	Only emit barrier if prev_insn non-NULL.
+	* config/ia64/ia64.h (MASK_VOL_ASM_STOP, TARGET_VOL_ASM_STOP): New.
+	(TARGET_SWITCHES): Add -mvolatile-asm-stop and -mno-volatile-asm-stop.
+	(REGNO_REG_CLASS): Add check for BR_REGNO_P.  Add default case
+	returning NO_REGS.
+
+Mon Aug  2 16:02:11 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (enable_haifa): Set for ia64*-*.
+	* configure: Regenerate.
+
+	* config/ia64/ia64.c (shift_32bit_count_operand): New.
+	(shladd_operand): Use explicit INTVAL tests instead of CONST_OK_FOR_P.
+	(ia64_print_operand_address, case E): New.
+	(rtx_needs_barrier): Delete unspec volatile 7 support.  Add unspec 4
+	support.
+	* config/ia64/ia64.h (CONST_OK_FOR_*): Clean up comments.
+	(CONST_OK_FOR_P): Redefine from shladd immediate to dep immediate.
+	(ISSUE_RATE): Define.
+	* config/ia64/ia64.md: Major cleanup.  Delete unnecessary comments.
+	Add more useful comments.
+	(attr length): Delete.
+	(attr type): New.  Add definition for all define_insn patterns.
+	(function units alu, integer, memory, floating_point, branch,
+	long_immediate): New.
+	(insv_internal): Use P constraint instead of i.
+	(mix4right_3op): New.
+	(divsi3, modsi3, udivsi3, umodsi3, divmodsi4, udivmodsi4): Delete.
+	(absdi3, smindi3, smaxdi3, umindi3, umaxdi3): Implement.
+	(divsf3, divdf3, rotlsi3): Delete.
+	(ashlsi3, ashrsi3, lshrsi3, rotrsi3): Implement.
+	(ashlsi3_internal, ashrsi3_internal, lshrsi3_internal): New.
+	(ashldi3, ashrdi3, lshrdi3, rotrdi3): Use DImode not SImode for shift
+	count.
+	(shladd, shladd_elim): Use n constraint instead of P.
+	(andsi3, iorsi3, xorsi3): Delete.
+	(absdi2_internal, absdi2_internal+1, absdi3_not_internal): New.
+	(pfs_restore): Use unspec_volatile 7 instead of unspec 4.
+
+1999-08-02  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850e.h (STRICT_ALIGNMENT): Only define if the
+	target is the v850.
+	
+1999-07-31  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* d10v.h (d10v_expand_builtin_saveregs): Renamed from
+	expand_builtin_saveregs.
+	* d10v.c: Likewise.
+
+Wed Jul 28 11:50:20 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (setjmp_operand): Delete mode parameter.
+
+	* config/ia64/ia64.c (setjmp_operand): New.
+	* config/ia64/ia64.md (call, call_value): If addr is a setjmp_operand,
+	then call setjmp_call_pic or setjmp_call_value_pic respectively.
+	(setjmp_call_pic, setjmp_call_value_pic): New.
+
+Tue Jul 27 14:16:15 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.md: Fix typo in new TARGET_LONG_CALLS tests. 
+
+Fri Jul 23 16:54:45 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_regstack_size): Delete.
+	(ia64_arpfs_regno): Renamed from ia64_arpfs_saved.
+	(ia64_input_regs): New.
+	(ia64_compute_frame_size): Add 8 to gr_size for unat.
+	(save_restore_insns): Add code to save/restore unat.
+	(ia64_expand_prologue): Rewritten to optimize input/output reg usage.
+	(ia64_expand_epilogue): Use ia64_arpfs_regno.  Delete local arpfs.
+	(ia64_function_prologue): Emit .regstk directive if no alloc insn.
+	(ia64_setup_incoming_varargs): Call gen_gr_spill instead of
+	move_block_from_reg.
+	(hfa_element_mode): New.
+	(ia64_function_arg, ia64_function_arg_partial_nregs,
+	ia64_function_arg_advance): Rewritten for better ABI compliance.
+	(rtx_needs_barrier): Handle unat moves.
+	* config/ia64/ia64.h (FIRST_PSEUDO_REGISTER): Decrease by 8.
+	(AR_REGNO_P, AR_REG): Delete.
+	(OUT_REG, IN_REG, LOC_REG): New.
+	(GENERAL_REGNO_P): Delete AR_REGNO_P call.
+	(FIXED_REGISTERS, CALL_USED_REGISTERS): Delete 8 output registers at
+	end.  Mark 8 general registers as fixed.
+	(REG_ALLOC_ORDER): Move 18 fixed registers to near end.
+	(REG_CLASS_CONTENTS): Delete 8 output registers at end.
+	(FRAME_POINTER_REGNUM): Decrease by 8.
+	(GR_ARG_FIRST): Use IN_REG (0).
+	(AR_ARG_FIRST): Use OUT_REG (0).
+	(struct ia64_args): Add prototype field.  Rename fregno field to
+	fp_regs.
+	(INIT_CUMULATIVE_ARGS, INIT_CUMULATIVE_INCOMING_ARGS): Set new fields.
+	(REGISTER_NAMES): Use in/out/loc for stacked general registers.  Delete
+	8 output registers near end.
+	* config/ia64/ia64.md (insv): Emit mix4 instructions.
+	(mix4left, mix4right): Enable.
+	(unat_spill, unat_restore): New.
+	* ginclude/va-ia64.h (__va_padded_size): New.
+	(va_arg): Call __va_padded_size.
+
+1999-07-21  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* arm.h (ARM_FLAG_LONG_CALLS, TARGET_LONG_CALLS): New macros.
+	(TARGET_SWITCHES): Add support for -mlong-calls.
+	* arm.md (call, call_value expanders): Force called address into
+	register if TARGET_LONG_CALLS.
+	(call_symbol, call_value_symbol): Disable if TARGET_LONG_CALLS.
+
+1999-07-17  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.md: Remove some CYGNUS LOCAL stuff, bringing
+	source into line with EGCS sources.
+
+Fri Jul 16 19:25:19 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md (madddi3_elim+1, shladd_elim+1): Modify these
+	define_splits to emit stop bit insns.
+
+	* config/ia64/ia64.c (save_restore_insns): Use tmp2_reg not tmp_reg
+	in gen_pr_restore call.
+	(rtx_needs_barrier, case USE): Ifdef out.
+	* config/ia64/ia64.md (floatdidf): Emit stop bit.
+	* config/ia64/lib1funcs.asm (__ia64_nonlocal_goto): Add explicit nop
+	before flushrs.  Emit stop bit before ar.bspstore write.
+
+1999-07-15  Nick Clifton  <nickc@cygnus.com>
+
+	* mcore.c: Add support for naked attribute.
+	* mcore.md: Add support for naked attribute.
+	
+	* mcore.h: Default to: -fno-exceptions -fno-rtti.
+
+Wed Jul 14 17:25:46 1999  Richard Henderson  <rth@cygnus.com>
+
+	* ia64/lib1funcs.asm (__ia64_nonlocal_goto): Use predicted
+	mov instead of brp.
+
+1999-07-14  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* config/mcore/mcore.c (layout_mcore_frame): Properly handle
+	functions with both varargs and nonzero pretend_args_size.
+	(setup_incoming_varargs): Don't clobber
+	current_function_pretend_args_size.
+	(mcore_expand_prolog): Don't copy incoming registers to the frame
+	for args that are partially passed in regs.
+
+Tue Jul 13 13:46:42 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md (ffsdi2): Emit one cmov insn instead of two.
+	Add :DI postfix to if_then_else operator.
+	(seq, sne, slt, sle, sgt, sge, sltu, sleu, sgtu, sgeu): Emit NE insn
+	instead of two cmov insns.
+	(sne_internal, seq_internal): Rewritten as NE/EQ instead of cmov insns.
+	(sne_internal+1, seq_internal+1): Add :DI postfix to if_then_else.
+	(sne_not_internal, seq_not_internal): Delete.
+	(cmovne_internal, cmoveq_internal): New.
+	(cmovne_internal+1, cmoveq_internal+1): Add :DI postfix to
+	if_then_else.
+
+Fri Jul  9 15:44:15 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (ia64*-*-linux*): Add t-linux to tmake_file.
+	Add posix thread support.
+	* configure: Regenerated.
+
+	* config/ia64/ia64.c (reg_or_8bit_and_adjusted_operand): New.
+	(normal_comparison_operator, adjusted_comparison_operator): Swap
+	non-equality comparison operators.
+	(save_restore_insns, ia64_expand_prologue, ia64_expand_epilogue,
+	ia64_setup_incoming_varargs, ia64_function_arg, ia64_function_value):
+	Change gen_rtx (FOO to gen_rtx_FOO.
+	* config/ia64/ia64.h (LIBCALL_VALUE, INITIALIZE_TRAMPOLINE): Likewise.
+	* config/ia64/ia64.md (call, call_value, save_stack_nonlocal,
+	nonlocal_goto, nonlocal_goto_receiver): Likewise.
+	(movqi_internal): Use nonimmediate_operand and move_operand instead
+	of general_operand.
+	(movhi_internal): Likewise.
+	(movsi): Use general_operand instead of nonimmediate_operand.
+	(movsi_internal): Use move_operand instead of general_operand.
+	(movsf_internal): Use nonimmediate_operand instead of general_operand.
+	Combine f/f and f/G alternatives.  Add m/G and r/G alternatives.
+	Use %F where 'G' is accepted.
+	(movdf_internal): Likewise.
+	(addsf3, subsf3, minsf3, maxsf3, maddsf3, msubsf3, nmaddsf3): Change
+	register_operand to reg_or_fp01_operand.  Add 'G' constraints and %F
+	operand print specifiers.
+	(addsf3, subsf3, minsf3, maxsf3, maddsf3, msubsf3, nmaddsf3): Likewise.
+	(cmpsi, cmpdi): Use reg_or_8bit_and_adjusted_operand.
+	* config/ia64/xm-ia64.h: Cleanup.
+	(HOST_WORDS_BIG_ENDIAN, HOST_BITS_PER_CHAR, HOST_BITS_PER_SHORT,
+	HOST_BITS_PER_INT, HOST_BITS_PER_LONG): Define.
+	
+1999-07-09  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* jump.c (delete_insn): When deleting a CALL_PLACEHOLDER, make sure
+	no NOTE_INSN_BLOCK_{BEG,END} notes are lost.
+
+Thu Jul  8 11:25:15 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (reg_or_8bit_adjusted_operand, ia64_direct_return,
+	reg_or_fp01_operand, normal_comparison_operator,
+	adjusted_comparison_operator): New.
+	(const_14bit_operand): Delete.
+	(ia64_print_operand): Add support for 'C' and 'D'.  Modify 'F' support
+	to also handle registers.
+	(ia64_secondary_reload_class): Return GR_REGS for moving DImode MEM
+	to FR_INT_REGS class.
+	(rtx_needs_barrier): For conditional move, complement is_complemented
+	when dest matches first operand of if_then_else.
+	* config/ia64/ia64.h (FIXED_REGISTERS): Make last 10 general registers
+	fixed.
+	(CALL_USED_REGISTERS): Likewise.
+	(CONST_OK_FOR_L): Change to 8 bit adjusted signed immediate.
+	* config/ia64/ia64.md (madddi3): Delete condition.  Add clobber.
+	(madddi3_elim, madddi3_elim+1): New patterns.
+	(shladd_elim): Use nonmemory_operand instead of	const_14bit_operand.
+	(shladd_elim+1): Use reg_or_14bit_operand not const_14bit_operand.
+	(lshrdi3): Use reg_or_6bit_operand not nonmemory_operand.
+	(cmpsi, cmpdi): Use reg_or_8bit_operand not nonmemory_operand.
+	(cmpsf, cmpdf): Use reg_or_fp01_operand not register_operand.
+	(cmpxf): New disabled pattern.
+	(eqsi_internal, nesi_internal, ltsi_internal, lesi_internal,
+	gtsi_internal, gesi_internal, ltusi_internal, leusi_interal,
+	gtusi_internal, geusi_internal, eqdi_internal, nedi_internal,
+	ltdi_internal, ledi_internal, gtdi_internal, gedi_internal,
+	ltudi_internal, leudi_interal, gtudi_internal, geudi_internal
+	eqsf_internal, nesf_internal, ltsf_internal, lesf_internal,
+	gtsf_internal, gesf_internal, eqdf_internal, nedf_internal,
+	ltdf_internal, ledf_internal, gtdf_internal, gedf_internal): Delete.
+	(cmpsi_normal, cmpsi_adjusted, cmpdi_normal, cmpdi_adjusted,
+	cmpsf_internal, cmpdf_internal): New.
+	(ffsdi2): Emit two conditional moves instead of one.
+	(seq, sne, slt, sle, sgt, sge, sltu, sleu, sgtu, sgeu): Likewise.
+	(seq_internal, sne_internal, cmovne, cmoveq): Convert to define_splits.
+	(sne_not_internal, sne_internal, seq_internal, seq_not_internal): New.
+	(untyped_call): New.
+	(return, eq_return, eq_not_return, ne_return, ne_not_return): New.
+	
+Thu Jul  8 10:27:44 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/mips.c (reg_or_mem_or_0_operand): Renamed to 
+	movti_operand.  Allow any CONST_INT and integer CONST_DOUBLEs.
+	(print_operand) : Add 'L' and 'M' for const_double.
+	* config/mips/mips.h (reg_or_mem_or_0_operand): Renamed.
+	(PREDICATE_CODES): Rename reg_or_mem_or_0_operand.  Add CONST_DOUBLE
+	to the list of codes for movti_operand.
+	* config/mips/mips.md (movti): Don't force TImode constants into
+	memory.
+	(movti_internal): Rename reg_or_mem_or_0_operand.  Handle various
+	kinds of CONST_INTs and integer CONST_DOUBLEs.
+
+Wed Jul  7 13:14:11 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* range.c (range_inner): Add comment about REG_LIVE_LENGTH problem.
+
+Wed Jul  7 10:37:16 1999  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* global.c (global_alloc): After calling undo_live_range, also
+	call regclass again.
+
+1999-07-01  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.c: Remove CYGNUS LOCAL markers around thumb-pe
+	code.
+	* config/arm/pe.c: Remove CYGNUS LOCAL marker.
+	* config/arm/pe.h: Remove CYGNUS LOCAL marker.
+	* config/arm/tpe.h: Remove CYGNUS LOCAL marker.
+	* config/arm/t-pe-thumb: Remove CYGNUS LOCAL marker.
+	
+	* configure.in: Move arm-pe and thumb-pe targets out of CYGNUS
+	LOCAL section.
+	* configure: Regenerate.
+
+Wed Jun 30 12:16:01 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/sysv4.h (ASM_OUTPUT_ALIGNED_LOCAL): Emit .type and
+	.size directives.
+
+Tue Jun 29 14:11:03 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_fixed_range_string): Add const.
+	(ia64_secondary_reload_class): Handle CONST_INT reloads into FP regs.
+	(REG_GP, REG_RP, REG_AR_PRS, REG_AR_CFM, REG_AR_EC, NUM_REGS,
+	struct reg_write_state, rws_sum, rws_insn, struct reg_flags,
+	rws_update, rws_access_reg, rtx_needs_barrier,
+	emit_insn_group_barriers, ia64_reorg): New.
+	* config/ia64/ia64.h (ia64_fixed_range_string): Add const.
+	(INITIALIZE_TRAMPOLINE): Change UNSPEC_VOLATILE 1 to 3.
+	(MACHINE_DEPENDENT_REORG): Define.
+	* config/ia64/ia64.md (maddi3): Add condition to disallow eliminable
+	frame pointer as operand 3.
+	(blockage): Change unspec number from 0 to 1.
+	(insn_group_barrier): New.
+	(flush_cache): Change unspec number from 1 to 3.
+	* config/ia64/lib1funcs.asm (__divdf3, __divsf3): Use p6 not p1.
+	Predicate divide sequence on p6.  Add mov to put result in f8.
+	(__divdi3, __moddi3): Use p6 not p1.  Predicate divide sequence on p6.
+	(__udivdi3, __umoddi3, __divsi3, __modsi3, __udivsi3, __umodsi3): Use
+	p6 not p1.
+
+Tue Jun 29 07:46:53 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (optimize_related_values_1): When deciding whether to
+	add a REG_DEAD or REG_UNUSED note, also check for a REG_INC notes
+	we might have created.
+
+	* integrate.c (copy_rtx_and_substitute): Handle NOTE_INSN_DELETED_LABEL
+	notes.  Don't handle 'n' rtx_format case.  
+
+Mon Jun 28 11:07:17 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* dbxout.c (dbxout_live_range_parms): Do not output aliases for
+	a parameter passed in memory, but which lives in a pseudo.
+
+1999-06-22  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (reg_or_0_operand, reg_or_6bit_operand,
+	reg_or_8bit_operand, reg_or_22bit_operand, shift_count_operand,
+	shladd_operand, const_14bit_operand): New.
+	(ia64_secondary_reload_class): Handle HImode and QImode MEM reloads
+	to FP registers.
+	* config/ia64/ia64.h (ADDL_REGNO_P): New.
+	(struct reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS,
+	REGNO_REG_CLASS, REG_CLASS_FROM_LETTER): Add ADDL_REGS.
+	* config/ia64/ia64.md (extendhidi2): Use 'r' not 'g' constraint.
+	(extendsidi2, zero_extendsidi2, anddi3, andnot, iordi3, xordi3): Add
+	support for operations in FP registers.
+	(insv, insv_internal): Simplify condition.
+	(mix4left, mix4right): New patterns, disabled for now.
+	(adddi3): Add support for addl instruction.
+	(subdi3, ashldi3, shladd, shladd_elim, ashrdi3, rotrdi3, anddi3,
+	andnot, iordi3, xordi3): Use more restrictive predicate.
+	(muldi3, smuldi3_highpart, umuldi3_highpart): Use real instruction
+	instead of macro instruction.
+	(divdi3, moddi3, udivdi3, umoddi3, divmoddi4, udivmoddi4, rotldi3):
+	Delete.
+	(ffsdi2): Implement.
+	(popcnt, cmovne, cmoveq): New patterns.
+	(one_cmpl): Use andcm instead of sub.
+	
+	* config/ia64/ia64.h (REG_CLASS_CONTENTS): Correct GR_AND_FR_INT_REGS
+	and GR_AND_FR_FP_REGS to match earlier FR_INT_REGS/FR_FP_REGS change.
+	(REGISTER_MOVE_COST): Make FR_INT_REGS <-> FR_FP_REGS moves expensive.
+
+1999-06-21  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (FR_FP_REGNO_P): Remove regs 16 to 23.
+	(FR_INT_REGNO_P): Add regs 16 to 23.
+	(REG_CLASS_CONTENTS): Likewise for FR_FP_REGS and FR_INT_REGS.
+	(HARD_REGNO_NREGS): Handle XFmode values in FP registers.
+	* config/ia64/ia64.md (fr_spill, fr_restore): Add *e constraint.
+
+Mon Jun 21 18:29:08 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* gcc.c (split_directories): Add appropriate const's.
+	(make_relative_prefix): Ditto.
+
+Mon Jun 21 12:27:17 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>
+
+	* config/d10v/d10v.h (BSS_SECTION_ASM_OP, ASM_OUTPUT_ALIGNED_BSS):
+	Add the macros.
+
+	* config/i386/i386elf.h (BSS_SECTION_ASM_OP, ASM_OUTPUT_ALIGNED_BSS):
+	Ditto.
+
+1999-06-21  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c: Merge in PIC changes from EGCS.
+	* config/arm/arm.h: Merge in PIC changes from EGCS.
+	* config/arm/arm.md: Merge in PIC changes from EGCS.
+
+	* config/mcore/mcore.c (emit_new_cond_insn): Only copy reg notes
+	if they exist.
+
+1999-06-18  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (CONDITIONAL_REGISTER_USAGE): Ifdef out.
+	(EPILOGUE_USES): Define.
+	(DIVDI3_LIBCALL, MODDI3_LIBCALL, UDIVDI3_LIBCALL, UMODDI3_LIBCALL):
+	Ifdef out.
+	(ADDITIONAL_REGISTER_NAMES): Define.
+	* config/ia64/lib1funcs.asm (L__divdf3): Renamed from L_divdf3.
+	(L__divsf3): Likewise.
+	(L__divdi3, __divdi3): Renamed from L_ia64_divdi3, __ia64_divdi3
+	respectively.
+	(L__moddi3, __moddi3, L__udivdi3, __udivdi3, L__umoddi3, __umoddi3,
+	L__divsi3, L__modsi3, L__udivsi3, L__umoddi3, L__save_stack_nonlocal,
+	L__nonlocal_goto): Likewise.
+	(__moddi3): Use .endp instead of .size.
+	* config/ia64/t-ia64 (LIB1ASMFUNCS): Likewise.
+	
+	* config/ia64/sysv4.h (SIZE_TYPE): Move unsigned after long.
+
+	* config/ia64/ia64.c (ia64_fixed_range_string): Define.
+	(ia64_print_operand, case 'r'): New.
+	(fix_range, ia64_override_options): New.
+	* config/ia64/ia64.h (TARGET_OPTIONS, OVERRIDE_OPTIONS): Define.
+	(CONST_OK_FOR_O, CONST_OK_FOR_P): Switch.
+	* config/ia64/ia64.md (subdi3_minus1): Delete 'K' constraint.
+	Use register_operand instead of nonmemory_operand.
+	(shladd, shladd_elim, shladd_elim+1): Use P instead of O.
+	(ltudi_internal): Change gru to gtu.  Change %2 to %1.
+	* config/ia64/sysv4.h (SIZE_TYPE, PTRDIFF_TYPE, WCHAR_TYPE,
+	WCHAR_TYPE_SIZE): Define.
+	
+	* config/ia64/linux.h (CPP_PREDEFINES): Define.
+	(ASM_SPEC): Undef.
+
+1999-06-18  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/elf.h: Move most of file contents to ia64.h or sysv4.h
+	as appropriate.  Include sysv4.h.
+	* config/ia64/ia64.h (CONDITIONAL_REGISTER_USAGE): Define.
+	(DIVDIE_LIBCALL, MODDI3_LIBCALL, UDIVDI3_LIBCALL, UMODDI3_LIBCALL,
+	INIT_TARGET_OPTAB): Move here from elf.h.
+	* config/ia64/linux.h: Include sysv4.h.
+	* sysv4.h: New file.
+	
+Fri Jun 18 10:09:06 1999  Ulrich Drepper  <drepper@cygnus.com>
+
+	* config/ia64/linux.h: Use <linux.h> instead of "linux.h" to avoid
+	infinite recursion.
+
+Fri Jun 18 09:43:29 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.h (CPP_PREDEFINES): Fix typo in defintion of
+	declspec. 
+
+1999-06-17  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (function_operand, move_operand,
+	reg_or_14bit_operand): New.
+	* config/ia64/ia64.h (MASK_NO_PIC, TARGET_NO_PIC): New.
+	(TARGET_SWITCHES): Add "no-pic".
+	(TRAMPOLINE_TEMPLATE): Put data (function descriptor) at start.
+	(INITIALIZE_TRAMPOLINE): Adjustments for TRAMPOLINE_TEMPLATE change.
+	(NO_FUNCTION_CSE, ENCODE_SECTION_INFO): Define.
+	(ASM_OUTPUT_DOUBLE_INT): Emit @fptr when PIC for functions.
+	* config/ia64/ia64.md (movdi): Add PIC support.
+	(movdi_internal): Use move_operand instead of general_operand.
+	(load_fptr, load_fptr_internal1, load_symptr, load_symptr_internal1):
+	New.
+	(zero_extendqidi2, zero_extendhidi2, zero_extendsidi2): Use
+	nonimmediate_operand instead of general_operand.
+	(adddi3): Use reg_or_15bit_operand instead of nonmemory_operand.
+	(call, call_value): Add PIC support.
+	(indirect_call_pic, call_pic, call_internal1, call_internal2,
+	indirect_call_value_pic, call_value_pic, call_value_internal1,
+	call_value_internal2): New.
+
+	* config/ia64/lib1funcs.asm (__divsf3): Fix typo from 1999-06-14
+	change.
+	
+Wed Jun 16 19:53:25 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (BRANCH_COST): Fix unterminated comment.
+
+Thu Jun 17 01:48:57 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* sh.md (mulsi3_highpart): Add REG_EQUAL note to last insn.
+
+Wed Jun 16 14:43:46 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* expr.c (expand_builtin, BUILT_IN_EXPECT): New local stripped_arg1.
+	Check arg0 not arg1 in first arg check.  Call STRIP_NOPS before
+	checking for INTEGER_CST.  Use const0_rtx instead of op0 for error
+	returns.  Add comments to document bugs.
+
+1999-06-15  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_function_value): Delete ununsed argument
+	outgoing.
+	* config/ia64/ia64.h (PROMOTE_MODES): Change SImode to DImode.
+	(FUNCTION_VALUE): Drop third argument to ia64_function_value.
+	(FUNCTION_OUTGOING_VALUE): Delete definition.
+	(CLEAR_INSN_CACHE): Document as unused.
+	* config/ia64/ia64.md (movsf_internal): Add r/m alternative.
+	* config/ia64/lib1funcs.asm: Document remaining problems.
+
+Tue Jun 15 19:41:43 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c (handle_structs_in_regs): Rewritten to
+	conform to MCore ABI.
+
+	* ginclude/va-mcore.h (va_arg): Rewritten to conform to MCore
+	ABI. 
+
+Tue Jun 15 09:54:09 1999  Richard Henderson  <rth@cygnus.com>
+
+	* ia64.h (GR_RET_LAST): Fix typo last change.
+
+Tue Jun 15 11:42:34 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>
+
+	* fold-const.c (fold_truthop): Make the result of comparison
+ 	optimization a signed.  Check that conditions necessary for correct
+ 	comparison optimizations are always true.
+
+1999-06-14  Richard Henderson  <rth@cygnus.com>
+
+	* ia64/elf.h (ASM_BYTE_OP): Don't conditionalize on gnu as.
+	(STRING_ASM_OP, SKIP_ASM_OP, COMMON_ASM_OP): Likewise.
+	(ASCII_DATA_ASM_OP): Likewise.
+	(LOCAL_COMMON_ASM_OP, ASM_OUTPUT_ALIGNED_LOCAL_COMMON): Delete.
+	(LIB_SPEC): Recognize -mhpsim.
+	* ia64.c (ia64_function_value): Use GR_RET_FIRST.
+	* ia64.h (TARGET_SWITCHES): Recognize -mhpsim.
+	(GR_RET_FIRST, GR_RET_LAST): New.
+	(FR_RET_FIRST, FR_RET_LAST): New.
+	(FUNCTION_VALUE_REGNO_P): Use them.
+	(LIBCALL_VALUE): Use GR_RET_FIRST.
+	(CLEAR_INSN_CACHE): Define.
+	(TRANSFER_FROM_TRAMPOLINE): Delete.
+	* ia64/lib1funcs.asm: Use .proc/.endp; use in?, ret?, farg?, fret?.
+	(__divdf3, __divsf3): Replace with correct algorithms.
+	(__ia64_save_stack_nonlocal, __ia64_nonlocal_goto): New functions.
+	* ia64/t-ia64 (LIB1ASMFUNCS): Add _save_stack_nonlocal, _nonlocal_goto.
+
+1999-06-11  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (ia64*-*-elf*): Add MASK_GNU_AS to target_cpu_default
+	if --with-gnu-as.  Likewise for MASK_GNU_LD.
+	(ia64*-*-linux*): Put MASK_GNU_AS|MASK_GNU_LD in target_cpu_default.
+	* configure: Regenerate.
+	* config/ia64/ia64.h (TARGET_SWITCHES): Use TARGET_CPU_DEFAULT.
+	(TARGET_CPU_DEFAULT): Define.
+	(LINK_SPEC): If -misim and GNU ld, add -m elf64_ia64_isim.
+	* config/ia64/ia64.md (call, call_value): Add initial broken and
+	ifdefed out indirect call support.
+
+1999-06-09  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (symbolic_operand): New.
+	(ia64_asm_output_external): Exclude __builtin_args_info.
+	* config/ia64/ia64.h (STACK_SAVEAREA_MODE, TRAMPOLINE_TEMPLATE,
+	TRAMPOLINE_SECTION, TRAMPOLINE_SIZE, TRAMPOLINE_ALIGNMENT,
+	INITIALIZE_TRAMPOLINE, TRANSFER_FROM_TRAMPOLINE): New.
+	(ASM_OUTPUT_ADDR_VEC_ELT): Delete spurious "data8".
+	* config/ia64/ia64.md (save_stack_nonlocal, nonlocal_goto,
+	nonlocal_goto_receiver, flush_cache): New.
+	* ginclude/va-ia64.h (va_dcl): Change int to long long.
+	(va_start): Rewrite using builtin_next_arg.
+
+1999-06-08  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/elfb5000.h, config/mips/elfl5000.h 
+	(MIPS_ENABLE_EMBEDDED_O32): Define.
+	(SUBTARGET_CPP_SIZE_SPEC): Replace.
+	(SUBTARGET_CPP_SPEC): Improve.
+
+Tue Jun  8 13:06:54 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/aout.h (ASM_OUTPUT_ASCII): Fix typo.
+
+1999-06-07  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_secondary_reload_class): Add checks for
+	FR_INT_REGS and FR_FP_REGS.
+	* config/ia64/ia64.h (GR_REGNO_P, FR_REGNO_P, PR_REGNO_P, BR_REGNO_P,
+	AR_REGNO_P): Add missing parentheses.
+	(FR_FP_REGNO_P, FR_INT_REGNO_P): New.
+	(HARD_REGNO_MODE_OK): Handle FR_RP_REGS, FR_INT_REGS, and PR_REGS.
+	(enum reg_class): Add FR_INT_REGS, FR_FP_REGS, GR_AND_FR_INT_REGS,
+	GR_AND_FR_FP_REGS, GR_AND_FR_REGS).
+	(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Likewise.
+	(REGNO_REG_CLASS, REG_CLASS_FROM_LETTER): Add FR_FP_REGS and
+	FR_INT_REGS.
+	(REGISTER_MOVE_COST): Handle BR_REGS to non-GENERAL_REGS moves.
+	* config/ia64/ia64.md (movqi_internal, movhi_internal, movsi_internal,
+	movdi_internal, floatdidf2, fix_truncsfdi2, fix_truncdfdi2,
+	floatunsdisf2, floatunsdfdi2, fixuns_truncsfdi2, fixuns_truncdfdi2,
+	muldi3, madddi3, smuldi3_highpart, umuldi3_highpart): Use 'e'
+	constraint.
+	(movdf_internal): Add r/G alternative.
+	
+Mon Jun  7 15:34:14 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* d30v.h (DEFAULT_VTABLE_THUNKS): Define as 0 to work around C++
+	front problem.
+
+1999-06-06  Richard Henderson  <rth@cygnus.com>
+
+	* ia64.h (TARGET_SWITCHES): Add no-gnu-as/no-gnu-ld.
+	(LINK_SPEC): Fix typo.
+	(ASM_APP_ON, ASM_APP_OFF): Don't distinguish gnu as.
+	(UNALIGNED_SHORT_ASM_OP, UNALIGNED_INT_ASM_OP): Likewise.
+	(UNALIGNED_DOUBLE_INT_ASM_OP): Likewise.
+	(ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT): Likewise.
+	(ASM_OUTPUT_SHORT, ASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT): Likewise.
+	(ASM_GLOBALIZE_LABEL, ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.
+	(ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ALIGN): Likewise.
+	(DEBUG_INFO_SECTION, ABBREV_SECTION, ARANGES_SECTION): Likewise.
+	(DEBUG_LINE_SECTION, PUBNAMES_SECTION): Likewise.
+
+	* ia64/lib1funcs.asm: Add group end markers.
+
+1999-06-04  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (STRICT_ARGUMENT_NAMING): Define.
+	* config/ia64/ia64.md (floatdidf2): Emit fnorm.d instruction.
+	(fix_truncsfdi2, fix_truncdfdi2, fixuns_truncsfdi2, fixuns_truncdfdi2):
+	Append .trunc to opcode.
+	* config/ia64/lib1funcs.asm (__divdf3, __divsf3): Rework to fix
+	precision problems.
+
+Fri Jun  4 16:40:01 1999  Richard Henderson  <rth@cygnus.com>
+
+	* ia64.h: Move `Driver configuration' section after MASK_FOO
+	flags have been defined.
+
+1999-06-04  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/mips-pe.h, config/sh/sh-pe.h (LIBSTDCXX): Define to dummy.
+	* config/sh/sh-pe (MATH_LIBRARY): Define to empty.
+
+1999-06-04  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/mips-pe.h (PE_SUBTARGET_CPP_SPEC): Add 
+	__builtin_alignof=__alignof__.
+	(MATH_LIBRARY): Define.
+	(WCHAR_TYPE): Correct.
+
+1999-06-02  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/pe.c (pe_mark_dllimport): Better handling of 
+	user_label_prefix.
+
+Tue Jun  1 14:39:01 1999  Catherine Moore  <clm@cygnus.com>
+ 
+	* config/arm/thumb.c (thumb_print_operand): Process 'c' type
+	operands for selective linking support.
+	* config/arm/telf.h (MAKE_DECL_ONE_ONLY): Define.
+	(UNIQUE_SECTION_P): Define.
+	(UNIQUE_SECTION): Define.
+ 
+1999-06-01  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/sh/t-shpe (TARGET_LIBGCC2_CFLAGS): Don't include the 
+	standard headers.
+
+1999-05-28  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/elf.h (LIB_SPEC): Define.
+	* config/ia64/ia64.h (TARGET_SWITCHED): Add -misim option.
+	(HARD_REGNO_MODE_OK): Delete accidently CCmode handling.
+	(HARD_REGNO_NREGS): Move it here.
+
+1999-05-28  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/pe.c (pe_mark_dllimport): Mark with "__imp_".
+
+1999-05-28  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/mips-pe.h (LIB_SPEC): Include -lcoredll.
+
+1999-05-28  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/pe.h (SUBTARGET_CPP_SPEC): Add '_int64' and '_inline'.
+	* config/mips/mips-pe.h (PE_SUBTARGET_CPP_SPEC): Add -DMIPS.
+
+1999-05-27  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (USER_H): Add va-ia64.h.
+	* ginclude/stdarg.h: Include va-ia64.h.
+	* ginclude/varargs.h: Include va-ia64.h.
+	* ginclude/va-ia64.h: New file.
+
+	* config/ia64/elf.h (STRING_ASM_OP): Use stringz not string.
+	(ASM_OUTPUT_ALIGNED_LOCAL_COMMON): Undef and redefine to use explicit
+	.bss.
+	(ASM_OUTPUT_ALIGNED_LOCAL): Don't call ASM_OUTPUT_ALIGNED_LOCAL_COMMON
+	when TARGET_GNU_AS.
+	* config/ia64/ia64.c (struct ia64_frame_info): Add pretend_size.
+	(ia64_compute_frame_size): Set it and use it.
+	(save_restore_insns): Use it.
+	(ia64_setup_incoming_varargs): Write body.  Add new argument
+	second_time.
+	* config/ia64/ia64.h (CPP_SPEC): Define __LONG_MAX__.
+	(LIBGCC2_WORDS_BIG_ENDIAN): Check __little_endian__ not __BIG_ENDIAN__.
+
+1999-05-27  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c (handle_structs_in_regs): Use SImode not
+	PSImode for the second word of 7 byte structures.
+
+1999-05-26  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/t-mipspe (USER_H): Add stddef.h.
+	* config/sh/t-shpe (USER_H): Same.
+
+1999-05-26  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* configure.in (sh-*-pe): Add pe.o to extra_objs.
+	* configure: Rebuild.
+	* config/sh/sh-pe.h: Include pe.h.
+	(TARGET_IS_SH_PE): Removed.
+	(SWITCH_TO_FUNCTION): New.
+	(VALID_MACHINE_TYPE_ATTRIBUTE,MERGE_MACHINE_DECL_ATTRIBUTES): Define.
+	(ENCODE_SECTION_INFO): Define.
+	(ASM_DECLARE_OBJECT_NAME): Define.
+	(ASM_OUTPUT_LABELREF): Define.
+	(STRIP_NAME_ENCODING): Define.
+	(CPP_SPEC): Remove.
+	(PE_SUBTARGET_CPP_SPEC): Add the SH/PE specific specs.
+	(ASM_OUTPUT_COMMON): Redefine to use DLL_ATTR_OUTPUT_COMMON.
+	(TARGET_DLL_ATTR_OUTPUT_COMMON): New.
+	* config/sh/sh.c (mips_valid_machine_decl_attribute): Add dllexport 
+	and dllimport.  
+	(sh_valid_machine_type_attribute): New.
+	(sh_merge_machine_decl_attributes): New.
+	* config/sh/sh.h (ctors_section,dtors_section): Declare.
+	(DLL_ATTR_P,DLL_ATTR_ENCODE,
+	DLL_ATTR_DECLARE_OBJECT_NAME,
+	DLL_ATTR_DECLARE_FUNCTION_NAME,DLL_ATTR_EXTRA_SECTIONS,
+	DLL_ATTR_EXTRA_SECTION_FUNCTIONS): Define to defaults.
+	(CPP_SPEC): Use subtarget_cpp_spec.
+	(SUBTARGET_CPP_SPEC): Add default definition.
+	(EXTRA_SPECS): Define to include SUBTARGET_CPP_SPEC
+	and SUBTARGET_EXTRA_SPECS.
+	(SUBTARGET_EXTRA_SPECS): Define to default.
+	(EXTRA_SECTIONS): USE DLL_ATTR_EXTRA_SECTIONS.
+	(EXTRA_SECTION_FUNCTIONS): Use DLL_ATTR_EXTRA_SECTION_FUNCTIONS.
+	(ASM_DECLARE_FUNCTION_NAME): Use DLL_ATTR_DECLARE_FUNCTION_NAME.
+	* config/sh/t-shpe: Build rule for pe.o.
+
+1999-05-26  DJ Delorie  <dj@cygnus.com>
+
+	* config/mips/mips-pe.h: use dbxcoff debugging (stabs+)
+
+Wed May 26 07:29:27 1999  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* configure.in (mips-*-pe): Add pe.o.
+	* configure: Rebuild.
+
+Tue May 25 17:37:33 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/mips-pe.h : Include pe.h.
+	(SWITCH_TO_FUNCTION): New.
+	(VALID_MACHINE_TYPE_ATTRIBUTE,MERGE_MACHINE_DECL_ATTRIBUTES): Define.
+	(STRIP_NAME_ENCODING): Define.
+	(ASM_OUTPUT_LABELREF): Define.
+	(MIPS_DISABLE_GPOPT): New.
+	(ASM_OUTPUT_COMMON): Use DLL_ATTR_OUTPUT_COMMON.
+	(DLL_ATTR_OUTPUT_COMMON): Define.
+	* config/mips/mips.c (override_options): Use MIPS_DISABLE_GPOPT.
+	(mips_valid_type_attribute_p): Add dllexport and dllimport.
+	Remove decl attributes to mips_valid_decl_attribute_p.
+	(mips_valid_decl_attribute_p): Add dllexport and dllimport.
+	Add decl attributes from mips_valid_type_attribute_p.
+	(mips_merge_decl_attributes): New.
+	* config/mips/mips.h (DLL_ATTR_P,DLL_ATTR_ENCODE,
+	DLL_ATTR_DECLARE_OBJECT_NAME,DLL_ATTR_OUTPUT_COMMON,
+	DLL_ATTR_DECLARE_FUNCTION_NAME,DLL_ATTR_EXTRA_SECTIONS,
+	DLL_ATTR_EXTRA_SECTION_FUNCTIONS): New.
+	(VALID_MACHINE_DECL_ATTRIBUTE): Change to use 
+	valid_decl_attribute_p.
+	(ENCODE_SECTION_INFO): Add DLL_ATTR_ENCODE.
+	(ASM_DECLARE_OBJECT_NAME): Add DLL_ATTR_DECLARE_OBJECT_NAME.
+	(ASM_DECLARE_FUNCTION_NAME): Use DLL_ATTR_DECLARE_FUNCTION_NAME.
+	(EXTRA_SECTIONS): USE DLL_ATTR_EXTRA_SECTIONS.
+	(EXTRA_SECTION_FUNCTIONS): Use DLL_ATTR_EXTRA_SECTION_FUNCTIONS.
+	* config/mips/t-mipspe: Build rule for pe.o.
+
+Tue May 25 17:37:33 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/pe.h: New file. 
+	(pe_dllimport_name_p,pe_dllexport_name_p,pe_dll_attr_encode,
+	drectve_section): Declare.
+	(SUBTARGET_CPP_SPEC): Define.
+	(PE_SUBTARGET_CPP_SPEC): Define to default.
+	(SUBTARGET_EXTRA_SPECS): Define, adding PE_SUBTARGET_CPP_SPEC.
+	(PE_SUBTARGET_EXTRA_SPECS): Define to default.
+	(TARGET_NOP_FUN_DLLIMPORT,PE_STRIP_ENCODING,
+	DLL_ATTR_P,DLL_ATTR_ENCODE,DLL_ATTR_DECLARE_OBJECT_NAME,
+	DLL_ATTR_OUTPUT_COMMON,DLL_ATTR_DECLARE_FUNCTION_NAME,
+	DLL_ATTR_EXTRA_SECTIONS,DLL_ATTR_EXTRA_SECTION_FUNCTIONS): New.
+	* config/pe.c: New file.
+	(associated_type,pe_dllexport_p,pe_dllimport_p,pe_dllexport_name_p,
+	pe_mark_dllexport,pe_mark_dllimport,pe_dll_attr_encode): New.
+
+Tue May 25 14:50:41 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* toplev.c (main): Enable LRS support again.
+
+Tue May 25 10:35:41 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcse.c (compute_transp): Use note_stores to and
+	mems_conflict_for_gcse_p to determine when memory is
+	killed.
+
+1999-05-24  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_function_arg_partial_nregs): Compare
+	cum->words against MAX_ARGUMENT_SLOTS not 0.
+	(ia64_print_operand, case 'U'): Only emit 0xffffffff if negative.
+	* config/ia64/intel-setup: Add "during build" to initial message.
+	* config/ia64/install-intel-setup: New file.
+	* config/ia64/t-ia64 (intel-setup): Set and use srcdir.
+	(install-intel-setup): New rule.
+
+Sun May 23 09:28:11 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-pe.h (ASM_OUTPUT_SOURCE_LINE): Remove
+	extraneous backslash. 
+
+1999-05-22  Nick Clifton  <nickc@cygnus.com>
+
+	* ginclude/va-mcore.h (va_arg): Only non aggregates with 8 byte
+	alignment are forced onto 8 byte boundaries.
+	* config/mcore/mcore.h (TRAMPOLINE_TEMPLATE): Recode.
+	* config/mcore/mcore.c (handle_structs_in_regs): Do nothing
+	special if the structure is partially in registers and partially
+	on the stack.
+	(mcore_function_arg_partial_nregs): Delete bogus code aligning
+	structures in argument registers.
+
+1999-05-20  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/elf.h (INIT_SECTION_ASM_OP, FINI_SECTION_ASM_OP,
+	CTORS_SECTION_ASM_OP, DTORS_SECTION_ASM_OP): Define.
+	* config/ia64/ia64.c (ia64_print_operand): Add 'T' and 'U'.
+	(ia64_asm_output_external): New function.
+	* config/ia64/ia64.h (ASM_APP_ON, ASM_APP_OFF): Add Intel assembler
+	support.
+	(ASM_OUTPUT_EXTERNAL): Call new function.
+	* config/ia64/ia64.md (movqi_internal, movhi_internal): Add f/r
+	alternative.
+	(insv): Tighten tests to handle non-CONST_INT constants.
+	(ltusi_internal, leusi_internal, gtusi_internal, geusi_internal): Use
+	new 'T' operand modifier.
+	(ltudi_internal, leudi_internal, gtudi_internal, geudi_internal): Use
+	new 'U' operand modifier.
+	* config/ia64/t-ia64 (EXTRA_PARTS): Define.
+	(intel-setup): Define.
+	* config/ia64/intel-setup: New file.
+	
+1999-05-20  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/elf.h (DIVDI3_LIBCALL, MODDI3_LIBCALL, UDIVDI3_LIBCALL,
+	UMODDI3_LIBCALL, INIT_TARGET_OPTABS): Define.
+	* config/ia64/ia64.c (struct ia64_frame_info): New field fr_pad_size.
+	(ia64_compute_frame_size): New local tmp.  Compute fr_pad_size.
+	(save_restore_insns): Use fr_pad_size.
+	* config/ia64/ia64.h (INITIAL_ELIMINATION_OFFSET): Set AP->FP offset
+	to 0.
+	(LIBCALL_VALUE): Use AR_ARG_FIRST instead of GR_ARG_FIRST.
+	* config/ia64/ia64.md (insv_internal): Add checks to verify operands.
+	(ashldi3, ashrdi3, lshrdi3, rotrdi3): Change i constraint to M.
+	(eqsi_internal, nesi_internal, eqdi_internal, nedi_internal): Eliminate
+	unnecessary alternative.
+	(nop): Add argument.
+	* config/ia64/lib1funcs.asm (divdi3, moddi3, udivdi3, umoddi3): Mostly
+	rewritten to fix bugs.
+	* config/ia64/t-ia64 (LIB1ASMFUNCS): Adjust names of lib1funcs.asm
+	functions.
+	(LIBGCC2_DEBUG_CFLAGS): Define.
+	
+Thu May 20 05:31:52 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-elf.h (CTORS_SECTION_ASM_OP): Define.
+	(DTORS_SECTION_ASM_OP): Define.
+	* config/mcore/mcore-pe.h (CTORS_SECTION_ASM_OP): Define.
+	(DTORS_SECTION_ASM_OP): Define.
+
+1999-05-19  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.md (bgtu): Cathc the case where comparing
+	against 0 and reverse the sense of the branch so that a NE
+	operator can be used.
+	
+	* config/mcore/mcore.c (mcore_gen_compare_reg): Add comment
+	describing actions taken by bgtu pattern in mcore.md.
+
+	* config/mcore/mcore.h (TARGET_8ALIGN): Always enabled.
+	* config/mcore/t-mcore (MULTILIB_DIRNAMES): Disable
+	8align/4align multilibs.
+
+
+Tue May 18 16:08:42 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-elf.h (ENDFILE_SPEC): Add support for
+	-mno-lsim command line switch.
+	* config/mcore/mcore-pe.h (ENDFILE_SPEC): Add support for
+	-mno-lsim command line switch.
+
+	* config/mcore/mcore.h (CPP_PREDEFINES): Define __MCORE__ to 1.
+	(CPP_SPEC): Define __MCORE_ALIGN_8__ or __MCORE_ALIGN_4__
+	(TARGET_SWITCHES): Add -mno-lsim switch.
+	(FUNCTION_ARG_BOUNDARY): Define.
+	(MUST_PASS_IN_STACK): Call mcore_must_pass_on_stack.
+	(FUNCTION_ARG_PASS_BY_REFERENCE): Redefine.
+	(SETUP_INCOMING_VARARGS): Pass pointer to pretend_arg_size.
+
+	* config/mcore/mcore.c (current_function_anonymous_args): Make
+	static.
+	(last_named_size): Delete.
+	(number_of_regs_before_varargs): New variable.
+	(layout_mcore_frame): Improve computation of number of vararg
+	pushes required.
+	(mcore_setup_incoming_varags): Initialise pretend_args_size and
+	number_of_regs_before_varargs.
+	(mcore_dependent_reorg): Reinitialise
+	current_function_anonymous_args to zero.
+	(mcore_must_pass_on_stack): New function: determine when a
+	parameter must be passed on the stack.
+
+	* config/mcore/t-mcore: Add multilib support for -m8align vs
+	-m4align.
+
+	* ginclude/va-mcore.h (__va_aligned_double): New macro: Handle
+	alignment of doubles passed as varargs.
+	(va_arg): Special case handling of doubles and long longs.
+	
+Tue May 18 11:34:12 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* Makefile.in (USER_H): Add va-mcore.h
+
+Mon May 17 23:44:31 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (cexp.c): Fix argument order for BISON.
+
+1999-05-17  DJ Delorie  <dj@cygnus.com>
+
+	* config/mips/mips-pe.h: Specify stabs debug.
+	* config/mips/t-mipspe: Don't install gcc's headers.
+	* config/sh/t-shpe: don't install gcc's headers.
+	* config/sh/sh-pe.h (REG_PARM_STACK_SPACE): move from sh.h
+	* config/sh/sh.h (REG_PARM_STACK_SPACE): move to sh-pe.h
+
+Mon May 17 15:10:56 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* ginclude/va-ppc.h: Revert to pre-merge state.  See Apr 15 rs6000
+	change.
+
+1999-05-17  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.h (TARGET_SWITCHES): Add -lsim.
+	(ENDFILE_SPEC): DO not link in sym library if -mno-lsim has been
+	specified. 
+
+	* ginclude/va-mcore.h: New file: Vararg definitions for mcore.
+	* ginclude/varargs.h: Include va-mcore.h
+	* ginclude/stdargs.h: Include va-mcore.h
+
+	* config/mcore/mcore.c (mcore_dllimport_name_p): New function:
+	Return true if the symbol has been marked as being dllimport'ed. 
+	(mcore_mark_dllimport): New function: Mark a decl as being
+	dllimport'ed.
+	(mcore_dllimport_p): New function: Return true of the decl has
+	been marked as being dllimport'ed.
+	(mcore_encode_section_info): Cope with dllimport'ed decls.
+	(mcore_valid_machine_decl_attribute): Allow dllimport.
+	(mcore_merge_machine_decl_attributes): New function: Cope with
+	a new declaration overrding the status of an old, dllimport
+	declaration.
+
+	* config/mcore/mcore.h (MERGE_MACHINE_DECL_ATTRIBUTE): Define.
+	(ASM_OUTPUT_ALIGNED_COMMON): Do not emit the symbol if it has
+	been marked as beign dllimport'ed.
+
+	* config/mcore/mcore.md (cmpgeusi_0): New pattern.
+
+1999-05-17  DJ Delorie  <dj@cygnus.com>
+
+	* config/sh/sh-pe.h: Add defines for stabs debugging and CE
+	runtime configuration (cpp, ld)
+
+1999-05-15  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* c-decl.c (redeclaration_error_message): Remove handling of
+	redefining typedefs.
+	(duplicate_decls): Add it here.
+
+Thu May 13 22:51:52 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* fixincludes: Make sure the header directory exists before trying to
+	cd into it.
+
+1999-05-13  Jim Wilson  <wilson@cygnus.com>
+
+	* elf.h, ia64.c, ia64.h, ia64.md, lib1funcs.asm, t-ia64: Checkpoint.
+	Changes necessary to build gcc and newlib using Intel assembler and
+	linker.
+
+1999-05-11  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c: Fix enum prototype dependencies.
+	(handle_structs_in_regs): Fix off by one error.
+	* config/mcore/mcore.h: Fix enum prototype dependencies.
+	* config/mcore/reg-class.h: Delete.
+	* config/mcore/mcore-elf.h: Rename a.exports => .exports
+	(DWARF_DEBUGGING_INFO): Define.
+
+1999-05-11  DJ Delorie  <dj@cygnus.com>
+
+	* configure.in, configure: add sh-pe and mips-pe support (Windows CE)
+	* config/sh/sh.h: if sh-pe, add space on stack for caller-saved regs
+	* config/mips/t-mipspe,mips-pe.h: new
+	* config/sh/sh-pe.h,t-shpe: new
+
+1999-05-10  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.h (VALID_MACHINE_DECL_ATTRIBUTE): Define.
+	(CPP_PREDEFINES): Convert __declspec into __attribute__.
+	(REGISTER_NAMES): Rename 'r0' to 'sp'.
+	(MUST_PASS_IN_STACK): Pass addressable arguments on the stack.
+	(FUNCTION_ARG_ADVANCE): Use mcore_num_arg_regs.
+	(FUNCTION_ARG_PARTIAL_NREGS): Call mcore_function_arg_partial_nregs. 
+	(CTORS_SECTION_ASM_OP): Define.
+	(DTORS_SECTION_ASM_OP): Define.
+	(EXTRA_SECTIONS): Define.
+	(EXTRA_SECTION_FUNCTIONS): Define.
+	(CTORS_SECTION_FUNCTION): Define if needed.
+	(DTORS_SECTION_FUNCTION): Define if needed.
+	(SWITCH_SECTION_FUNCTION): Define.
+	(ASM_OUTPUT_LABELREF): Define.
+	(MCORE_STRIP_NAME_ENCODING): Define.
+	(STRIP_NAME_ENCODING): Define.
+	(ASM_OUTPUT_ALIGNED_COMMON): Handle dllexported names.
+	(ASM_OUTPUT_COMMON): Undefine.
+	(ENCODE_SECTION_INFO): Define.
+
+	* config/mcore/mcore.c (mcore_num_arg_regs): New function:  Return
+	the number of registers needed to hold a function argument.
+	(handle_structs_in_regs): Code with a 5-8 byte sized structure
+	being passed partially in registers and partially on the stack.
+	(mcore_function_arg): Tidy up.
+	(mcore_function_arg_partial_nregs): New function:  Compute the
+	number of registers needed to hold part of a function argument.
+	
+	(mcore_dllexport_name_p): New function:  Return true if the given
+	name is a dllexported name.
+	(mcore_mark_dllexport): New function: Mark a DECL as being
+	dllexport'ed.
+	(mcore_dllexport_p): New function: Returns true if the DECL has
+	the dllexport attribute.
+	(mcore_encode_section_info): New function:  If a decl has the
+	dllexport attribute then mark it for special handling.
+	(mcore_valid_machine_decl_attribute): New Function:  Accept
+	'dllexport' as a valid machine decl attribute.
+	
+	* config/mcore/mcore-elf.h (AEXPORTS_ASM_OP): Define.
+	(SUBTARGET_EXTRA_SECTIONS): Define.
+	(SUBTARGET_EXTRA_SECTION_FUNCTIONS): Define.
+	(AEXPORT_SECTION_FUNCTION): Define.
+	(SUBTARGET_SWITCH_SECTIONS): Define.
+	(MCORE_EXPORT_NAME): Define.
+	(ASM_DECLARE_FUNCTION_NAME): Handle dllexport'ed function names.
+	(ASM_DECLARE_OBJECT_NAME): Handle dllexport'ed object names.
+
+	* config/mcore/mcore-pe.h (SUBTARGET_CPP_PREDEFINES): Remove
+	__declspec to __attribute__ transformation.
+	(CTORS_SECTION_ASM_OP): Undefine.
+	(DTORS_SECTION_ASM_OP): Undefine.
+	(EXTRA_SECTIONS): Undefine.
+	(SUBTARGET_EXTRA_SECTIONS): Define.
+	(SUBTARGET_EXTRA_SECTION_FUNCTIONS): Define.
+	(DRECTVE_SECTION_FUNCTION): Define.
+	(SUBTARGET_SWITCH_SECTIONS): Define.
+	(MCORE_EXPORT_NAME): Define.
+	(DRECTVE_SECTION_ASM_OP): Define.
+	(ASM_DECLARE_FUNCTION_NAME): Handle dllexport'ed function names.
+	(ASM_DECLARE_OBJECT_NAME): Handle dllexport'ed object names.
+	
+Sun May  9 17:43:21 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (ia64*-*-elf*, ia64*-*-linux*): New.
+	* configure: Rebuilt.
+	* config/ia64/QUESTIONS, config/ia64/elf.h, config/ia64/ia64.c,
+	config/ia64/ia64.h, config/ia64/ia64.md, config/ia64/lib1funcs.asm,
+	config/ia64/linux.h, config/ia64/t-ia64, config/ia64/xm-ia64.h: New
+	files.
+	
+Sat May  8 14:57:35 1999  Jeffrey A Law  (law@cygnus.com)
+
+1999-05-07  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Seperate make script templates for mcore-pe and
+	mcore-elf.
+	* configure: Regenerate.
+	* config/mcore/t-mcore-pe: New file: make script template for
+	mcore-pe.
+
+	* config/mcore/mcore.h (FUNCTION_VALUE): Change definition to call
+	mcore_function_value.
+	(FUNCTION_ARG): Change definition to call mcore_function_arg.
+	
+	* config/mcore/mcore.c (mcore_output_call): Change second
+	parameter to be index into array passed as first parameter.
+	(handle_structs_in_regs): New function.  Generate an RTX to
+	describe how a structure is held in registers.  Special case for a
+	structure between 5 and 8 bytes long.
+	(mcore_function_value): New function: Call handle_structs_in_regs
+	to generate the appropriate RTX.
+	(mcore_function_arg): New function: Call handle_structs_in_regs to
+	generate the appropriate RTX.
+	* config/mcore/mcore.md (call_value_struct): New pattern.
+	Fix use of mcore_output_call().
+
+1999-05-06  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Remove extra_parts for mcore-elf.
+	* configure: Regenerate.
+	* config/mcore/mcore.h: Add -mslow-bytes
+	* config/mcore/mcore.c: Improve assembler output.  Remove memory
+	width support.
+	
+
+1999-05-05  Alastair Houghton <ajh8@doc.ic.ac.uk>
+
+	* c-parse.in: Allow anonymous structures and unions inside
+	structs and unions.
+
+1999-05-04  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* c-decl.c (redeclaration_error_message): Allow typedefs to
+	be redefined to the same type.
+	* extend.text: Document the extension: Redefining Typedefs.
+
+Mon May  3 19:59:11 1999  Vladimir Makarov  <vmakarov@tofu.to.cygnus.com>
+
+	* alpha.c (alpha_expand_unaligned_load_words): Clear
+	MEM_UNALIGNED_P flag for aligned addresses.
+	(alpha_expand_unaligned_store_words): Ditto.
+
+Thu Apr 29 15:59:44 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c (mcore_arith_K_operand_not_0): New
+	function, same as mcore_arith_K_operand except that 0 is not
+	accepted.
+	(mcore_dependent_simplify_rtx): Function suppressed (for now).
+	(mcore_dependent_reorg): Disable this pass if optimsation is not
+	enabled. 
+	
+	* config/mcore/mcore.h: Add prototype for
+	mcore_arith_K_operand_not_0.
+
+	* config/mcore/mcore.md (rotlsi3, ashli3, ashrsi3, lshrsi3): Use
+	mcore_arith_K_operand_not_0 as predicate.
+
+	* config/mcore/mcore-pe.h (STARTFILE_SPEC): Define.
+	(ENDFILE_SPEC): Define.
+
+Wed Apr 28 16:35:13 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* sh.md (udivsi3, divsi3): Emit the move of the function address
+	to a pseudo outside of the libcall.
+
+Tue Apr 27 17:57:09 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/abi64.h (LONG_MAX_SPEC): Handle mlong64.
+
+1999-04-23  Michael Meissner  <meissner@cygnus.com>
+
+	* d30v.md ({inc,dec}scc): Require output to be the same register
+	as the input.
+
+1999-04-22  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore-elf.h (FORCE_INIT_SECTION_ALIGN): Define.
+	(FORCE_FINI_SECTION_ALIGN): Define.
+
+1999-04-21  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c (emit_new_cond_insn): Fix deletion of
+	labels at end of conditional block.
+
+1999-04-20  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c (mcore_output_inline_const_forced): Use
+	lsli not lsl.
+
+1999-04-19  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.md: Disable relaxed tst instruction.
+
+1999-04-18  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.md: Fix typos in insn patterns.
+
+	* config/mcore/mcore.c (conditionalize_block): Skip deleted
+	instructions. 
+	(is_cond_candidate): Use an enum for the return type.
+
+	* config/mcore/crti.asm: New file.  Prologues for .init and .fini
+	sections.
+	* config/mcore/crtn.asm: New file.  Epilogues for .init and .fini
+	sections.
+	* config/mcore/t-mcore: Add rules to build crti.o and crtn.o.
+	* config/mcore/mcore-el.h (STARTFILE_SPEC): Define.
+	(ENDFILE_SPEC): Define.
+	
+1999-04-16  Nick Clifton  <nickc@cygnus.com>
+
+	* config/mcore/mcore.c: New file: C support code for mcore ports. 
+	* config/mcore/gfloat.h: New file: Floating point constnts.
+	* config/mcore/lib1.asm: New file: Assembler support routines for
+	mcore. 
+	* config/mcore/mcore.md: New file: Machine description for mcore.
+	* config/mcore/mcore.h: New file: General header file for mcore
+	ports. 
+	* config/mcore/mcore-pe.h: New file: Header file for mcore-pe
+	port. 
+	* config/mcore/t-mcore: New file: Makefile fragment for mcore
+	ports. 
+	* config/mcore/xm-mcore.h: New file: mcore specific macro
+	defintions. 
+	* config/mcore/mcore-elf.h: New file: Header file for mcore-elf
+	port.
+	* config/mcore/reg-class.h: New file: Header fragment defining
+	enum reg_class.
+
+	* configure.in: Add mcore-elf and mcore-pe targets.
+	* configure: Regenerate.
+	
+Thu Apr 15 16:15:08 1999  Richard Henderson  <rth@cygnus.com>
+
+	* alpha.c (alpha_expand_unaligned_load): Clear MEM_UNALIGNED_P
+	from ANDed addresses.
+	(alpha_expand_unaligned_store): Likewise.
+
+Thu Apr 15 03:18:57 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* config/rs6000: Revert to pre-merge state.  Needs major
+	cleaning up before we can start merging again.
+
+Wed Apr 14 14:46:57 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/mips.h (ABI_GAS_ASM_SPEC): Correct for abi.
+
+Tue Apr 13 21:12:31 1999  Catherine Moore  <clm@cygnus.com>
+
+	* config/arm/thumb.c (thumb_function_prologue):  Strip @e
+	from the names of labels which are exported.
+
+Mon Apr 12 18:50:29 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* fixincludes: Make sure the header directory exists before trying to
+	cd into it.
+
+Fri Apr  9 13:41:04 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (check-consistency): Use 'cd' to find the library
+	directory logically rather than physically.  Add cd .. to
+	TCL_LIBRARY command.
+
+Thu Apr  8 12:25:00 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.c: Prevenyt warnings about non-void naked
+	functions not returning a value.
+
+Wed Apr  7 01:14:17 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* fixinc/mkfixinc.sh: Force the use of the old fixincludes
+	script for now.
+	* fixincludes: Update for new calling interface.
+
+1999-03-31  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/epoc-pe.h (USER_LABEL_PREFIX): Define.
+	(TARGET_DEFAULT): Define.
+	* config/arm/t-epoc-pe.h (USER_LABEL_PREFIX): Define. 
+	(TARGET_DEFAULT): Define.
+
+Wed Mar 31 12:47:51 1999  Richard Henderson  <rth@cygnus.com>
+			  Jim Wilson  <wilson@cygnus.com>
+
+	* range.c (range_update_basic_block): Update find_basic_blocks call.
+	Always call allocate_bb_life_data.  Skip initial NOTE_INSN_BASIC_BLOCK.
+
+1999-03-29  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config.sub (mips64vr4111,mips64vr4111el) Add.
+	* configure.in (mips64vr4111-*-elf*,mips64vr4111el-*-elf*): Add.
+	* configure: Update.
+	* config/mips/elfbvr4111.h: New file.
+	* config/mips/elflvr4111.h: New file.
+	* config/mips/t-vr4111: New file.
+
+Sat Mar 27 10:03:34 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/t-epoc-pe.h (CC1_SPEC): Do not enable -fno-rtti or
+	-fno-exceptions when building GCC.
+
+	* config/arm/epoc-pe.h (CC1_SPEC): Do not enable -fno-rtti or
+	-fno-exceptions when building GCC.
+
+Fri Mar 26 16:02:37 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in (arm-epoc-pe): New target.
+	(thumb-epoc-pe): New target.
+	* configure: Regenerate.
+
+	* config/arm/coff.h: Prevent multiple inclusion.
+	* config/arm/epoc-pe.h: New file.  ARM-EPOC specific definitions.
+	* config/arm/t-epoc-pe.h: New file.  THUMB-EPOC specific definitions.
+	* config/arm/epoc-pe.h: New file.  ARM-EPOC specific definitions.
+
+1999-03-26  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/t-strongarm-elf (MULTILIB_MATCHES): Define.
+	(EXTRA_MULTILIB_PARTS): Define.
+	(MULTILIB_OPTIONS): Remove mapcs-32/mapcs-26.
+	
+	* config/arm/t-strongarm-coff (MULTILIB_OPTIONS): Remove
+	mapcs-32/mapcs-26. 
+
+	* config/arm/t-thumb-elf (EXTRA_MULTILIB_PARTS): Define.
+	
+Thu Mar 25 14:04:54 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>
+
+	* config/fr30/fr30.c (fr30_expand_prologue): Set RTX_FRAME_RELATED_P 
+	on prologue insns.
+
+1999-03-23  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/pe.c (arm_pe_valid_machine_decl_attribute): Do not
+	pass attributes on the arm_valid_machine_decl_attribute.
+
+Tue Mar 23 09:00:39 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/pe.h (SUBTARGET_SWITCHES): Add doc string.
+	* config/arm/tpe.h (SUBTARGET_SWITCHES): Add doc string.
+
+1999-03-22  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c (can_tail_call_optimise): Rename to
+	arm_can_tail_call_optimise.
+	(arm_valid_machine_decl_attribute): Add code to suppress value of
+	'warn_return_type' variable for naked functions.
+	(arm_reorg): Add code to restore value of 'warn_return_type'
+	variable for naked functions. 
+	
+	* config/arm/arm.h: Add prototype for arm_can_tail_call_optimise. 
+
+
+Sun Mar 21 10:42:13 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>
+
+	* gcse.c (hash_scan_set): If there is a call in the libcall_block,
+	add all call clobbered registers to the depandant list for the expr.
+		                      
+Wed Mar 17 12:26:28 1999  Richard Henderson  <rth@cygnus.com>
+
+	* stmt.c (expand_asm_operands): Call MD_ASM_CLOBBERS if present.
+	* tm.texi (MD_ASM_CLOBBERS): Document it.
+
+1999-03-17  Jeffrey Law <law@cygnus.com>
+
+	* calls.c (expand_call): Initialize arg_block before each
+	iteration of the call expansion loop.
+
+1999-03-17  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/mips.c (override_options): Allow -mabi=32
+	for certain embedded processors.
+
+1999-03-16  Nick Clifton  <nickc@cygnus.com>
+
+	* dbxout.h: Add prototype for dbxout_live_range.
+	* rtl.h: Add prototypes for replace_insns.
+
+	* config/arm/arm.c: Fix compile time warnings.
+	* config/arm/arm.h: Fix compile time warnings.  Add prototypes for
+	exported functions.
+	* config/arm/arm.md: Fix compile time warnings.
+	* config/arm/aout.h: Fix compile time warnings.
+	
+1999-03-16  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/elfbvr4xxx.h (MIPS_ENABLE_EMBEDDED_O32): Define.
+	(MULTILIB_DEFAULTS): Include newmultilib options.
+	(SUBTARGET_CPP_SPEC): Redefine to handle new multilibs.
+	(SUBTARGET_CPP_SIZE_SPEC): Redefine to handle more ABIs,
+	and more options.
+	* config/mips/elflvr4xxx.h: Same.
+	* config/mips/t-vr4xxx: MULTILIB more options.
+
+1999-03-16  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/mips.c (simple_memory_operand): Re-enable
+	checking for non-mips16 SYMBOL_REF's.
+
+1999-03-12  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.h: Add prototype for
+	arm_handle_bad_signed_byte_address().
+
+	* config/arm/arm.md (extendqisi_insn, extendqihi_insn): Add
+	call to arm_handle_bad_signed_byte_address() if operands[1]
+	contains an invalid MEM.
+	
+	* config/arm/arm.c (arm_override_options): Change meaning of
+	-mtune= command line options, so that is possible to tune for a
+	cpu other than the target cpu.
+	(arm+split_constant): Only allow the pushing of constants into
+	memory if arm_reorg() has not already started.
+	(arm_reorg_started): New function: Returns true if arm_reorg()
+	has been called for the current function.
+	(arm_handle_bad_signed_byte_address): New function: Generate
+	assembler to cope with a bad MEM for a signed byte load.
+	
+	* invoke.texi: Document -mtune= command line option for ARM
+	toolchains. 
+	
+Fri Mar 12 11:00:47 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* flags.h (flag_optimize_comparisons): Add new flag.
+
+	* toplev.c (flag_optimize_comparisons): Add new global.
+	(f_options): Add -foptimize-comparisons.
+
+	* fold-const.c (fold_truthop): Add optimizing sequence of comparsions
+	opreations.
+	(simple2_operand_p): New function like simple_operand_p, but
+	allows some simple arithmetic as well.
+
+	* jump.c (jump_optimize): Don't do branch elimination on single
+	insns setting ints larger than the word size.
+
+	* invoke.texi: Update documentation.
+
+Wed Mar 10 19:56:20 1999  Jeff Johnston  <jjohnstn@cygnus.com>
+
+	* config/d10v/d10v.h (LIB_SPEC): Added -lnosys to default libraries
+	to include stubs for OS routines not provided by newlib.
+
+1999-03-10  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/t-strongarm-elf (LIB1ASMFUNCS): Add _bb_init_func.
+	* config/arm/t-strongarm-coff (LIB1ASMFUNCS): Add _bb_init_func.
+	* config/arm/lib1funcs.asm: New function __bb_init_func.
+
+	* config/arm/aout.h (DBX_OUTPUT_MAIN_SOURCE_FILENAME): Use
+	output_quoted_string() to ensure correct name quoting.
+
+Tue Mar  9 23:58:32 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* gcse.c (insert_insn_end_bb): Copy insn bodies of insns in
+	libcall sequences to form new instructions, rather than sharing rtl.
+
+Mon Mar  8 16:00:35 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* regmove.c (optimize_related_values): Add bounds check for b before
+	BLOCK_HEAD check.
+
+Sun Mar  7 11:08:21 1999  Bob Manson  <manson@charmed.cygnus.com>
+
+	* recog.c (recog_next_insn): Added new parameter.
+
+	* recog.h: Add parameter to declaration.
+
+	* genrecog.c (write_tree_1): Only set _last_insn if we're
+ 	processing the first insn.
+	(change_state): Pass _last_insn to recog_next_insn (), and pass
+ 	insn instead of x0.
+
+Sun Mar  7 02:38:04 1999  Richard Henderson  <rth@cygnus.com>
+
+	* genemit.c (max_scratch_opno): New variable.
+	(max_operand_1, max_operand_vec): Set it.
+	(gen_expand): Test it.
+	(gen_split): Likewise.
+	
+Fri Mar  5 12:35:30 1999  Richard Henderson  <rth@cygnus.com>
+
+	* toplev.c (main): Disable live range splitting.
+
+	* integrate.c (save_for_inline_copying): Discard bb notes.
+	(save_for_inline_nocopy): Likewise.
+
+
+Wed Mar  3 19:09:11 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* sparc/liteelf.h (LONG_DOUBLE_TYPE_SIZE, WIDEST_HARDWARE_FP_SIZE,
+	STDC_0_IN_SYSTEM_HEADERS, MULDI3_LIBCALL, DIVDI3_LIBCALL,
+	UDIV3_LIBCALL, MODDI3_LIBCALL, UMODDI3_LIBCALL): Delete.
+	* sparc/sp86x-elf.h: Likewise.
+
+Mon Mar  1 14:06:36 1999  Catherine Moore  <clm@cygnus.com>
+
+	* toplev.c (compile_file):  Disable -ffunction-sections and
+	debugging warning if the object format is elf.
+
+1999-02-28  Jim Lemke  <jlemke@cygnus.com>
+
+	* invoke.texi: Added two corrections for -mmpc860c0.
+
+Sun Feb 28 02:20:00 1999  Geoffrey Noer  <noer@cygnus.com>
+
+	* config.sub: Check for "cygwin*" rather than "cygwin32*"
+
+Sat Feb 27 18:02:47 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md: Fix typo: Use %%# in sprintf strings to
+	pass %# on to print_operand.
+	* config/fr30/fr30.h: Fix spelling typo.
+
+1999-02-25  Jim Lemke  <jlemke@cygnus.com>
+
+	* config/rs6000/sysv4.h: Move badly placed CYGNUS LOCAL markers.
+
+Wed Feb 24 23:35:37 1999  Bob Manson  <manson@cygnus.com>
+
+	* Makefile.in (STAGESTUFF, mostlyclean): Add .peephole2.
+	* flags.h (flag_peephole2): New declaration.
+
+	* genattrtab.c (main): Count and ignore peephole2.
+	* gencodes.c (main): Likewise.
+	* genconfig.c (main): Likewise.
+	* genextract.c (main): Likewise.
+	* genoutput.c (main): Likewise.
+	* genpeep.c (main): Likewise.
+	* genemit.c (gen_exp): Take new `subroutine_type' argument.
+	Update all callers.
+	(gen_rtx_scratch): New function.
+	(output_peephole2_scratch): New function.
+	(gen_split): Update to handle peephole2.
+	(main): Include hard-reg-set.h and resource.h.  Issue peephole2.
+	* genrecog.c (enum routine_type): Add peephole2.
+	(IS_SPLIT): Likewise.
+	(make_insn_sequence): Strip outer parallel for peephole2.
+	(add_to_sequence): Add INSN_TYPE and TOP arguments.  Update callers.
+	Handle top-level parallel for peephole2.
+	(write_subroutine): Handle peephole2.
+	(write_tree, write_tree_1): Likewise.
+	(change_state): Add AFTERWARD argument.  Update callers.
+	Handle peephole2 insn `depths'.
+	(main): Issue peephole2.
+
+	* recog.c (recog_next_insn): New function.
+	(peephole2_optimize): New function.
+	* recog.h: Add prototypes for them.
+
+	* rtl.def (DEFINE_PEEPHOLE2): New.
+	* toplev.c: Add peephole2 dump as -dz.
+	(rest_of_compilation): Invoke peephole2_optimize.
+
+	* flow.c (split_hard_reg_notes): Handle non-REG_DEAD notes, or
+	simple REG_DEAD notes.
+	(maybe_add_dead_note, maybe_add_dead_note_use,
+	find_insn_with_note): New routines.
+	(new_insn_dead_notes): Handle replacement of multiple insns.
+	(maybe_remove_dead_notes): New routine.
+	(update_life_info): Renamed from update_flow_info; enhanced to
+	allow replacement of multiple insns.
+	(prepend_reg_notes, replace_insns): New routines.
+	* output.h (update_life_info): Add proto.
+
+Thu Feb 25 12:43:55 1999  Jeffrey A Law  (law@cygnus.com)
+	
+	* tree.c (safe_for_unsave): Properly handle CALL_EXPRs.
+
+1999-02-24  Jim Lemke  <jlemke@cygnus.com>
+
+	* config/rs6000/sysv4.h: Add -mmpc860c0[=num] option.
+	* invoke.texi: Add -mmpc860c0[=num] option.
+
+1999-02-23  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/crti.asm (_fini, _init): Push 4 bytes so that the
+	saved frame pointer will not be overwritten. 
+
+Mon Feb 22 17:12:40 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>
+
+	* gcse.c (struct expr): Add insn and extra_expr fields.
+	(struct extra_list): New data structure for unobvious dependancies.
+	(delete_libcalls): List of libcalls that have been commoned.
+	(oprs_anticipatable_p): Process up insns up to the LIBCALL part 
+	of a RETVAL insn.
+	(insert_expr_in_table): Return an expr struct ptr.
+	(hash_scan_set): Return an expr struct pointer, if commonable.
+	Add extra param to force commoning of some expressions. Process
+	libcall blocks. Copy propagate doubles.
+	(cprop_insn): Propagate doubles. Make CONST_INT code more generic.
+	(insert_insn_end_bb): Handle copying libcalls.
+	(force_dependant_expressions): New function to check extra_exprs list
+	to make sure all dependants are actually being commoned too
+	before commiting this one.
+	(pre_delete): Don't change REG_RETVAL, but rather add a register
+	copy afterwards and duplicate the REG_EQUAL note. Add libcall to
+	list to be deleted.
+	(pre_gcse): Initialize delete_libcalls list, delete pending libcalls
+	after pre_gcse is finished.
+
+Fri Feb 19 23:10:32 1999  Richard Henderson  <rth@cygnus.com>
+
+	* regmove.c (optimize_related_values): Use insn modes rather than
+	sets_cc0_p.  Watch basic block heads and ends rather than insn types.
+
+Wed Feb 17 09:20:30 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/elf5900.h (ASM_OUTPUT_ALIGNED_LOCAL): Choose output
+	section based on object size and mips_section_threshold.
+
+Mon Feb 15 14:21:11 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* rs6000.md (andsi3): Fix pattern so it is generated properly.
+	Don't support splitting an andi into li/and combinations, allowing
+	cr0 not to be clobbered.
+
+	* rs6000.c (and{,64}_operand): If the user did -ffixed-cr0, don't
+	allow andi. or andis. which always set cr0.
+
+Sun Feb 14 09:24:27 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* rs6000.md (iorsi3_internal3): Emit `#' for case where operand3
+	is not CR0 so it is properly split.
+
+1999-02-12  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.md (zeroextractqi_compare0_scratch): Cope with
+	bitfields than span a byte boundary.
+
+Thu Feb 11 17:51:24 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* rs6000.md (movdf_hardfloat32): Add support for non-offsetable
+	LO_SUMs in addition to register+register addresses.
+
+1999-02-10  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/strongarm-coff.h (SUBTARGET_CPU_DEFAULT): Define.
+	(TARGET_VERSION): Define.
+
+	* config/arm/t-strongarm-elf (TARGET_LIBGCC2_CFLAGS): Add
+	-fno-inline as a workaround for scheduling bug.
+	
+	* config/arm/t-strongarm-coff (TARGET_LIBGCC2_CFLAGS): Add
+	-fno-inline as a workaround for scheduling bug.
+	
+1999-02-08  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md: Replace \\n\\t with \\;.
+
+	* configure.in: Add support for StrongARM target.
+	* configure: Regenerate.
+	* config/arm/arm.c: Add support for -mcpu=strongarm1100.
+	* config/arm/arm.h: Add support for -mcpu=strongarm1100.
+	* config/arm/unknown-elf.h (CPP_APCS_PC_DEFAULT_SPEC): Only define 
+	if not already defined.
+	(SUBTARGET_CPU_DEFAULT): Only define if not already defined.
+	* config/arm/strongarm-elf.h: New file. Define StrongARM specific
+	features. 
+	* config/arm/strongarm-coff.h: New file. Define StrongARM specific
+	features. 
+	* config/arm/t-strongarm-coff: New file: StrongARM COFF specific
+	makefile fragment.
+	* config/arm/t-strongarm-elf: New file: StrongARM COFF specific
+	makefile fragment.
+
+	* config/arm/t-bare (ATRGET_LIBGCC2_CFLAGS): Define
+	-Dinhibit_libc.
+	
+Sat Feb  6 20:37:57 1999  Vladimir N. Makarov  <vmakarov@cygnus.com>
+
+	* config/rs6000/rs6000_output_load_toc_table: Fix the bug (comma
+ 	usage).
+
+Fri Feb  5 16:21:01 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* system.h (abort): Add missing comma to error message so filename
+	is not part of the format string.
+
+	* rs6000.md (movdf_hardfloat32): Add support for non offsetable
+	load of fp value into integer register support.
+
+Fri Feb  5 14:26:48 1999  Michael Meissner  <meissner@cygnus.com>
+
+	* config/rs6000/rs6000.h (TARGET_OPTIONS): Add -mbranch-cost=n
+	support.
+	(BRANCH_COST): Ditto.
+	(rs6000_branch_cost{,_string}): New externals for altering branch
+	costs.
+
+	* config/rs6000/rs6000.c (rs6000_branch_cost{,_string}): New
+	externals for altering branch costs.
+	(rs6000_override_options): Add support for -mbranch-cost=n.
+
+	* invoke.texi (-mbranch-cost=n): New option description.
+	
+Fri Feb  5 13:28:55 1999  Vladimir N. Makarov  <vmakarov@cygnus.com>
+
+	* invoke.texi (-m{no-}sched-{epilog,prolog}): New options
+ 	documentations
+
+	* config/rs6000/rs6000.md (prologue, epilogue,
+ 	move{si,di}_{from,to}_cr, load{si,di}_svr4_relocatable_toc,
+ 	loadsi_svr4_toc, load{si,di}_nonsvr4_toc): New define_expand and
+ 	define_insn for scheduling prologue/epilogue.
+	
+	* config/rs6000/rs6000.h (MASK_SCHED_PROLOG,
+	MASK_SCHED_EPILOG, TARGET_SCHED_PROLOG, TARGET_SCHED_EPILOG):
+	New macros for new options.
+	(TARGET_SWITCHES): Add new options description for scheduling
+	prologue/epilogue.
+	(rs6000_expand_prologue, rs6000_expand_epilogue): New
+	functions defintion.
+
+	* config/rs6000/rs6000.c (rs6000_expand_prologue,
+	rs6000_expand_epilogue, rs6000_output_prolog,
+	rs6000_output_epilog): New functions for scheduling
+	prologue/epilogue.
+
+	(rs6000_output_load_toc_table, rs6000_allocate_stack_space,
+	output_prolog, output_epilog): New cygnus local function
+	implementations.
+
+Fri Feb  5 13:12:13 1999  Vladimir N. Makarov  <vmakarov@cygnus.com>
+
+	* Makefile.in (check-consistency): New makefile entry for
+	GCC compilers consistency testing.
+
+Tue Feb  2 20:29:34 1999  Catherine Moore  <clm@cygnus.com>
+
+	* configure.in (arm-*-oabi):  Support.
+	(thumb-*-oabi):  Support.
+	* configure:  Regenerate.
+	* config/arm/telf-oabi.h:  New file.
+	* config/arm/telf.h (ASM_OUTPUT_DWARF2_ADDR_CONST):
+	Don't use user_label_prefix.
+	* config/arm/thumb.h (ASM_SPEC):  Conditionally define.
+	* config/arm/unknown-elf-oabi.h:  New file.
+
+Mon Feb  1 15:05:57 1999  Dave Brolley  <brolley@cygnus.com>
+
+	* cppfiles.c (find_include_file): Use open_include_file_name instead
+	of calling open directly.
+
+Mon Feb  1 11:39:25 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md: Add attribute 'delay_type'.
+	Add delay slot specification.
+	Add delay_type attributes to insns with non default type.
+	Enable multiplication patterns: mulsidi3 umulsidi3 mulsihi3
+	umulsihi3 mulsi3
+	Add delayed branch print operands.
+
+	* config/fr30/fr30.c (fr30_print_operand): Add codes '#' and 'p'
+	to handle delayed branched and hi/lo register pair respectively. 
+
+	* config/fr30/fr30.h (PRINT_OPERAND_PUNCT_VALID_P): Define for
+	'#'.
+	(DWARF_LINE_MIN_INSTR_LENGTH): Set to 2.
+
+	* config/fr30/t-fr30 (LIB1ASMFUNCS): Remove _mulsi3.
+	* config/fr30/lib1funcs.asm: Remove mulsi3 function.
+
+1999-01-31  Michael Meissner  <meissner@cygnus.com>
+
+	* config/rs6000/t-vxworks: New file to suppress building libc
+	routines under VxWorks.
+
+	* configure (powerpcle-wrs-vxworks): Add new configuration.
+	(powerpc{,le}-*-vxworks*): Include rs6000/t-vxworks.
+
+	* config/rs6000/vxppc.h ({CPP,LIB,LINK,STARTFILE,ENDFILE}_SPEC,
+	CPP_PREDEFINES): Remove definitions.
+	({CPP_OS_DEFAULT,LIB_DEFAULT,STARTFILE_DEFAULT,ENDFILE_DEFAULT,
+	LINK_START_DEFAULT,LINK_OS_DEFAULT,CPP_ENDIAN_BIG,
+	CPP_ENDIAN_LITTLE}_SPEC, CPP_PREDEFINES): Define.
+
+	* config/rs6000/vxppcle.h: New little endian VxWorks support file.
+
+	* invoke.texi (-mvxworks): Document.
+
+	* config/rs6000/sysv4.h (CPP_OS_VXWORKS_SPEC): Define CPU_FAMILY
+	as PPC and define CPU.
+	(TARGET_SWITCHES): Add -mvxworks switch to control whether or not
+	the target is VxWorks.  If EXTRA_SUBTARGET_SWITCHES is defined, it
+	provides additional switches from a subtarget that includes
+	sysv4.h.
+	(SUBTARGET_EXTRA_SPECS, *_SPEC): Add -mvxwork support.
+	(USER_LABEL_PREFIX): Undef before including svr4.h.
+	(ASM_DECLARE_FUNCTION_NAME): Use asm_fprintf to get the current
+	user prefix in front of the name.
+	(ASM_OUTPUT_INTERNAL_LABEL_PREFIX): Use asm_fprintf to get the
+	current internal label prefix in front of the name.
+	(ASM_OUTPUT_LABELREF): Ditto.
+	({USER_LABEL,LOCAL_LABEL,REGISTER,IMMEDIATE}_PREFIX): Define.
+	(SUBTARGET_OVERRIDE_OPTIONS): Don't set rs6000_wchar_type{,_size}.
+	(RELATIVE_PREFIX_NOT_LINKDIR): Disable AIX specific support.
+	(WCHAR_*): Set wchar_t to be an int as per standard, not unsigned
+	short.
+	(CPP_SYSV_SPEC): Define _SOFT_FLOAT on machines that use software
+	floating point.
+	(CC1_SPEC, LINK_TARGET_SPEC): Fix typos.
+
+	* config/rs6000/eabi-ci.asm (___{C,D}TOR_LIST__): Add
+	-fleading-underscore support.
+
+	* config/rs6000/eabi-cn.asm (___{C,D}TOR_END__): Ditto.
+
+	* config/rs6000/eabi.asm (__eabi): Don't use FUNC_START/FUNC_END,
+	always use __eabi, even for libraries compiled with
+	-fleading-underscore.
+
+	* ginclude/ppc-asm.h (FUNC_START): Make sure label for function
+	start uses FUNC_NAME.
+	(FUNC_{START,END,NAME}): Prepend the macro __USER_LABEL_PREFIX__
+	into function names.
+
+	* config/rs6000/t-ppcgas (MULTILIB_{OPTIONS,DIRNAMES}): Add new
+	multilibs that use -fleading-underscore.
+
+	* config/rs6000/rs6000.c (rs6000_wchar_type{,_size}): Remove,
+	variables are no longer used.
+
+	* config/rs6000/sysv4le.h (LINK_TARGET_SPEC): Explicitly pass
+	-oformat elf32-powerpcle if -mcall-i960-old.
+
+1999-01-31  Michael Meissner  <meissner@cygnus.com>
+
+	* config/rs6000/sysv4.h (SUBTARGET_OVERRIDE_OPTIONS): Add
+	support for -mcall-i960-old.  The -mcall-i960-old option now sets
+	-mno-bit-word.  If -mcall-i960-old, make wchar_t be an int.
+	(WCHAR_TYPE{,_SIZE}): If -mcall-i960-old, make wchar_t be an int.
+	(CPP_SYSV_SPEC): Ditto
+	(NO_BUILTIN_WCHAR_TYPE): Define, wchar_t is a variable type.
+	(rs6000_wchar_type{,_size}): New globals to hold type string and
+	size for wchar_t.
+	(ASM_SPEC): If -mcall-i960-old, pass -mlittle.
+	(TARGET_FLAGS): Add -m{,no-}bit-word to control whether bitfields
+	can cross word boundaries or not, independent of whether they
+	cause the structure to take on the base type's alignment.
+	(BITFIELD_NBYTES_LIMITED): Depend on whether -m{,no-}bit-word was
+	passed.
+
+	* config/rs6000/rs6000.c (rs6000_wchar_type{,_size}): Provide
+	externals if NO_BUILTIN_WCHAR_TYPE is defined.
+
+	* cccp.c (toplevel): If NO_BUILTIN_WCHAR_TYPE is defined, do not
+	define wide char support.
+	(main): Ditto.
+	(special_symbol): Ditto.
+	(initialize_builtins): Ditto.
+
+	* cpplib.c (toplevel): If NO_BUILTIN_WCHAR_TYPE is defined, do not
+	define wide char support.
+	(special_symbol): Ditto.
+	(initialize_builtins): Ditto.
+
+	* config/rs6000/t-ppcgas (MULTILIB_*): Add multilib for
+	-mcall-i960-old.
+	
+	* invoke.texi (-mcall-960-old, -m(no-)bit-word): New options
+	description.
+	
+Sat Jan 30 19:40:16 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* fold-const.c (fold): Don't pass MINUS_EXPR to
+	reduce_expression_tree_depth.
+
+Thu Jan 28 01:08:31 1999  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (find_related): Check if a register belonging to a set
+	of related values is clobbered in an insn where it is also used.
+	(optimize_related_values_1): Handle REG_UNUSED notes.
+	(optimize_related_values): Likewise.
+
+
+Fri Jan 22 07:50:33 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (DRIVER_DEFINES): Fix accidental breakage of
+	TOOLDIR_BASE_PREFIX.
+
+Thu Jan 21 18:11:27 1999  Richard Henderson  <rth@cygnus.com>
+
+	* expr.c (emit_push_insn): Fix typo.
+
+Wed Jan 20 15:30:00 1999  Dave Brolley  <brolley@cygnus.com>
+
+	* configure.in: Turn on --enable-c-mchar by default.
+	* configure: Regenerate.
+
+Tue Jan 19 05:40:26 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (libgcc2.a, LIB2FUNCS_EH): Remove -O0.  Resyncs code
+	with net version.
+
+Sat Jan 16 01:06:16 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcse.c (mem_set_in_block): Deleted.
+	(mem_first_set, mem_last_set): Deleted.
+	(modify_mem_list): New variable.
+	(mems_conflict_for_gcse_p): New function.
+	(gcse_mems_conflict_p, gcse_mem_operand): New variables.
+	(load_killed_in_block_p): New function.
+	(oprs_unchanged_p): Use load_killed_in_block_p.
+	(oprs_not_set_p, expr_killed_p): Likewise.
+	(compute_transp): Do not pessimize memory references.
+	(record_last_mem_set_info): Keep a list of all instructions which
+	can modify memory for each basic block.
+	(mark_call, mark_set, mark_clobber): Use record_last_mem_set_info.
+	(gcse_main): Initialize & finalize alias analysis.
+	(alloc_gcse_mem): Allocate space for modify_mem_list array.
+	(free_gcse_mem): Free the modify_mem_list array.
+	(compute_hash_table): Clear modify_mem_list.
+	(reset_opr_set_tables): Likewise.
+
+1999-01-15  Brendan Kehoe  <brendan@cygnus.com>
+
+	* system.h (abort): Adjust where to report bugs as a cygnus-local
+	change.
+
+Fri Jan 15 10:40:37 1999  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Remove inclusion of libgloss.h from fr30 target as
+	it is no longer needed.
+	* configure: Regenerate.
+
+1999-01-14  Vladimir N. Makarov  <vmakarov@cygnus.com>
+
+	* config/i960/i960.h (TARGET_FLAG_MOVE_COALESCENCE,
+	TARGET_MOVE_COALESCENCE, and TARGET_SWITCHES): Definitions for new
+	options `-mmove-coalescence' and `-mno-move-coalescence'.
+	(INIT_EXPANDERS, init_expanders): Definitions for i960 insn
+	expanders.
+
+	* config/i960/i960.c (i960_const0_r12r13, i960_const0_r12r15): New
+	static variables for making move coalescence.
+	(machine_function): New structure describing machine status for
+	expanders.
+	(i960_save_machine_status, i960_restore_machine_status,
+	i960_init_expanders): New functions for work with machine status.
+	(emit_move_sequence, i960_output_move_double_zero,
+	i960_output_move_quad_zero): New code for coalescing move
+	instructions.
+
+	* invoke.texi (-mmove-coalescence, -mno-move-coalescence): New
+	options description.
+	
+1999-01-13  Nick Clifton  <nickc@cygnus.com>
+
+	* ginclude/va-fr30.h (va_arg): Handle structures specially.
+	(va_aggregate_p): New macro: Detect structures based on their
+	type.
+
+	* config/fr30/fr30.h: (MUST_PASS_IN_STACK): Define:  All
+	structures must now be passed on the stack.
+	(DEFAULT_PCC_STRUCT_RETUR): Define.
+
+1999-01-11  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add extra_parts for FR30 target to build C++
+	contructor and destructor code.
+	* configure: Regenerate.
+	* config/fr30/t-fr30: Add rules to build crti.o and crtn.o.
+	* config/fr30/fr30.h (STARTFILE_SPEC): Add crti.o and crtbegin.o.
+	(ENDFILE_SPEC): Add crtend.o and crtn.o.
+	* config/fr30/crti.asm: New file:  Stack frame creation code for
+	.init amd .fini sections.
+	* config/fr30/crtn.asm: New file:  Stack frame removal code for
+	.init and .fini sections. 
+
+Thu Dec 31 16:03:59 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* d10v.c ({gpr,accum}_operand): Rewrite December 17th change to
+	work better during the reload phase if we have run out of
+	registers.
+	(reg_or_0_operand): Call gpr_operand for non-integer constants.
+	(arith16_operand): Ditto.
+	(arith_4bit_operand): Ditto.
+	(arith_nonnegative_operand): Ditto.
+	(arith32_operand): Ditto.
+	(arith64_operand): Ditto.
+	(arith_lower0_operand): Ditto.
+
+1998-12-24  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/mips.c (override_options): For TARGET_MIPS16 force
+	mips_align_loops to 0.
+
+1998-12-23  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.h (FUNCTION_PROFILER): Define.
+
+	* config/arm/arm.c (arm_asm_output_label): Use variable
+	'user_label_prefix' rather than macro USER_LABEL_PREFIX.
+
+	* config/arm/t-thumb-elf: Add multilib option for leading
+	underscores.
+
+	* config/arm/telf.h (USER_LABEL_PREFIX): Default to no leading 
+	underscore.
+	(ASM_OUTPUT_DWARF2_ADDR_CONST): Use variable 'user_label_prefix'
+	rather than macro USER_LABEL_PREFIX.
+
+
+Fri Dec 18 12:09:17 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md: Fix define_expands that were using
+	constraints to work without constraints, since they are not
+	supported.
+
+1998-12-18  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/lib1funcs.asm: Only use 32 division operations, not 33.
+
+1998-12-17  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/lib1funcs.asm: Use macro to generate body of divide
+	and modulo functions.
+
+1998-12-17  Michael Meissner  <meissner@cygnus.com>
+
+	* d10v.c ({gpr,accum}_operand): Always check whether a hard
+	register is valid, instead of just passing the buck to
+	register_operand before the reload pass.
+
+1998-12-17  Gavin Romig-Koch <gavin@cygnus.com>
+
+	* config/mips/abi64.h (LONG_MAX_SPEC): Handle -mabi=eabi.
+
+1998-12-16  Nick Clifton  <nickc@cygnus.com>
+
+	* ginclude/va-fr30.h (va_arg): Fix definition to work with small
+	types and irregularly sized types.
+
+	* config/fr30/fr30.h (FRAME_POINTER_REQUIRED): Use a frame pointer
+	for varags functions.
+	(FUNCTION_ARGS): Also check MUST_PASS_IN_STACK().
+	(FUNCTION_ARGS_PASS_BY_REFERENCE): Define.
+	
+	* config/fr30/fr30.c (fr30_num_arg_regs): Return 0 if the type
+	satisifies MUST_PASS_IN_STACK().
+	
+	* config/fr30/fr30.md (enter_func): Fix pattern to match real
+	behaviour of the insn.
+	
+1998-12-15  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config/mips/mips.h (GAS_ASM_SPEC): Pass mabi to gas.
+	(ABI_GAS_ASM_SPEC,abi_gas_asm_spec): New.
+	(EXTRA_SPECS): Added ABI_GAS_ASM_SPEC,abi_gas_asm_spec.
+
+Mon Dec 14 19:22:58 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* d30v/d30v.c (move_input_operand, move_output_operand): Accept
+	ADDRESSOF as valid memory operand address.
+
+1998-12-14  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.c (print_operand): Fix LTU and GEU opcodes.
+	(print_operand): Add 'A' operator to print a signed byte value as
+	an unsigned byte value.
+	(fr30_notice_update_cc): Function removed.
+
+	* config/fr30/fr30.h (TRAMPOLINE_TEMPLATE): Define.
+	(TRAMPOLINE_SIZE): Define.
+	(INITIALIZE_TRAMPOLINE): Define.
+	(NOTICE_UPDATE_CC): Undefine.
+
+	* config/fr30/fr30.md: Switch over from using cc0 to using reg 16
+	as a fixed condition code register.
+	Remove the "cc" attribute.
+	(movqi_internal): Use 'A' operator to get an unsigned version of a
+	signed byte value. 
+	
+Mon Dec 14 17:08:17 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* regmove.c (REL_USE_HASH): Use unsigned HOST_WIDE_INT instead of
+	unsigned.
+
+1998-12-13  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add inclusion of libgloss.h
+
+
+	* config/fr30/fr30.h (STARTING_FRAME_OFFSET): Change value to 0.
+
+	* config/fr30/fr30.md (movqi_internal): Accept any integer value,
+	not just QI values.
+	(call): Only allows MEMs in REGs.
+
+	* config/fr30/fr30.c (fr30_function_args_partial_nregs): Fix to
+	work properly.
+	
+1998-12-12  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/lib1funcs.asm: Fix divide routines.
+	* config/fr30/fr30.h: Rework frame pointer elimination.
+	* config/fr30/fr30.c: Rework frame pointer elimination.
+	* config/fr30/fr30.md: Rework use of cc0.
+
+1998-12-11  Nick Clifton  <nickc@cygnus.com>
+
+	
+	* config/fr30/fr30.md: Force MEMs for Qi and HI mode moves to be
+	loaded into a reg.
+	Check peephole conversions of push and pop sequences to make sure
+	that the registers are in ascending order.
+
+	* config/fr30/fr30.c (fr30_check_multiple_regs): New function -
+	Check registers are in ascending order.
+	
+	* config/fr30/fr30.h (ENDFILE_SPEC): Add link with simulator library.
+	Add prototype for fr30_check_multiple_regs().
+	
+	* config/fr30/lib1funcs.asm: Basic implemenation of divide and
+	modulo funcitons.
+	
+1998-12-10  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md: Add pattern for "enter" insn.
+	* config/fr30/fr30.c: Use enter insns as part of function
+	prologue. 
+
+
+	* config/fr30/t-fr30: Remove _negsi2 and _one_cmplsi2 functions.
+	* config/fr30/lib1funcs.asm: Remove stubs for negsi2 and
+	one_cmplsi2.  Make other stubs generate an abort.
+
+	* config/fr30/fr30.h: Create a new fake hard register for the
+	argument pointer.
+	(INITIAL_ELIMINATION_OFFSET): Fix to cope with Fr30 frame layout.
+	(SETUP_INCOMING_VARARGS): Define to call fr30_steup_incoming_varargs().
+	(STRICT_ARGUMENT_NAMING); Define as false.
+	(PREDICATE_CODES): Add low_register_operand().
+
+	* config/fr30/fr30.md: Add peephole for va_arg() load insns.  Not
+	working yet.
+	Add peepholes for pushing low registers.
+	Add patterns for: negsi2 and one_cmplsi2
+	Add grunge reload pattern for computing stack addresses.
+
+	* config/fr30/fr30.c: Improve stack layout comment.
+	(MUST_SAVE_FRAME_POINTER): Also save FP if frame_pointer_needed is
+	true.
+	(fr30_expand_prologue): Push arguments into pretend argument area.
+	(fr30_setup_incoming_varags): New function: compute size of
+	pretend argument area.
+	(low_register_operand): New predicate:  Return true if argument is
+	a hard register in the range 0 to 7.
+	
+	* Makefile.in: Export va-fr30.h to gcc's include directory.
+	* ginclude/varargs.h: Include va-fr30.h if __fr320__ is defined.
+	* ginclude/stdarg.h: Include va-fr30.h if __fr320__ is defined.
+	* ginclude/va-fr30.h: Varargs implemenation for the FR30.
+
+	* config/arm/arm.h (TARGET_OPTIONS): Fixup egcs merge problem.
+
+1998-12-08  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md: Add missing (MEM:SI ...) around memory
+	references! 
+	(reload_frame_pointer_add): New pattern to cope with implicit
+	assumption built into reload.
+	(stack_pointer_store, frame_pointer_store): swap order of operands.
+
+	* config/fr30/fr30.c (fr30_expand_epilogue): Pop frame pointer if
+	it was pushed during the prologue.
+
+Sun Dec  6 03:40:07 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* fold-const.c (reduce_expression_tree_depth): Set TREE_CONSTANT on
+	new expressions we create, if applicable.
+
+Fri Dec  4 23:10:36 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* fold-const.c (fold): Call reduce_expression_tree_depth for
+	simple associative operators.
+	(reduce_expression_tree_depth): New function.
+
+1998-12-04  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md: Improve support for small memory model.
+
+	* Fixed branch length calculations.
+
+1998-12-03  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.h: Add -msmall-model command line switch.
+
+	Define r0 as a fixed register for use by the .md patterns.
+
+	Undefine MACHINE_DEPENDENT_REORD.
+
+	* config/fr30/fr30.md: Use r0 as a scratch register for branches and
+	jumps.
+
+	Use LDI:20 instead of LDI:32 to load addresses if TARGET_SMALL_MODEL
+	is enabled.
+
+	* config/fr30/fr30.c: Delete fr30_reorg() function.
+
+1998-12-02  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.h: Undefine STARTFILE_SPEC and ENDFILE_SPEC.
+	* config/fr30/fr30.md: Enable the generation of the LDI:20
+	instruction. 
+
+Tue Dec  1 15:29:17 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md (movsi_register_store): Allow ADDRESSOF
+	stores.
+	(branch_true, branch_false): Use comparision_operator to ensure
+	that an operator is actually present in the RTL.
+	(jump, branch): Reduce distance calculation to cope with
+	inaccuracies in insn length calculations.
+
+	* config/fr30/fr30.c (fr30_print_operand): Add 'R' operand to
+	print a MEM as if it were a REG.
+	Add folding to the file.
+
+	* config/fr30/fr30.h: Add folding to the file.
+	
+Tue Dec  1 11:59:12 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* mips.md (trap_if): Another typo in !GENERATE_BRANCHLIKELY case.
+
+Mon Nov 30 17:05:59 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* mips.md (trap_if): Fix typo in !GENERATE_BRANCHLIKELY case.
+
+Fri Nov 27 18:40:10 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* sh.md (mulsidi3_i, umulsidi3_i): Make rtl describe operation
+	correctly independent of endianness.
+	(mulsidi3, umulsidi3): Now define_insn.  Hide details that
+	confuse the optimizers.
+	(mulsidi3+1, umulsidi3+1): New define_split.
+
+1998-11-25  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/t-fr30 (LIB1ASMFUNCS): Add _one_cmplsi2.
+	
+	* config/fr30/lib1funcs.asm (__one_cmplsi2): New function stub.
+
+	* config/fr30/fr30.h (MACHINE_DEPENDENT_REORG): Define and set to
+	fr30_reorg().
+	
+	* config/fr30/fr30.c (fr30_reorg): New function - detect illegal
+	jump insns created by jump2 pass of gcc and correct them.
+
+Thu Nov 26 00:49:47 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* sh.md (udivsi3_i1, divsi3_i1, umulhisi3_i, mulhisi3_i): Name.
+	(smulsi3_highpart_i): Name.
+	(udivsi3): Wrap emitted insns in REG_LIBCALL / REG_RETVAL notes.
+	(divsi3, mulhisi3, umulhisi3, mulsidi3, umulsidi3): Likewise.
+	(smulsi3_highpart, umulsi3_highpart): Likewise.
+
+Tue Nov 24 17:58:29 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.md (jump): Support jumps to code outside +/-
+	255 byte range.
+
+Tue Nov 24 14:03:17 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.h (TARGET_OPTIONS): Fix merge problem.
+
+Mon Nov 23 17:24:24 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.c (override_options): Use tilde, not minus to
+	invert a bitfield!
+	
+Sun Nov 22 20:33:20 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* mips.md (DImode div and mod insns):Fix typos.
+
+	* mips.md (moddi3): Fix typo.
+
+Fri Nov 20 14:51:42 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/fr30/fr30.h: Make MDL and MDH be fixed until the multiply
+	patterns can be fixed.
+
+	* config/fr30/fr30.c (sp_displacement_operand): Fix range to be
+	0 -> 60 not 0 -> 64.
+	Add %b and %B output operand operators to generate condition
+	codes. 
+
+	* config/fr30/fr30.md: Fix branch patterns to use correct
+	condition mnemonics.
+	Rewrite conditional branches to support both long branches and
+	short branches.
+	
+	* config/fr30/t-fr30: Define mutlipy and divide functions for
+	libgcc1-asm.a 
+
+	* config/fr30/lib1funcs.asm: Assembler code for multiply and
+	divide functions.
+
+Thu Nov 19 13:33:07 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/pe.h: Define USER_LABEL_PREFIX as "_"
+
+Wed Nov 18 14:40:34 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in: Add configury for mips-lsi-elf.
+	* configure: Regenerate.
+	* config/mips/t-lsi: New file.
+
+	* range.c (live_range): Fix size arg to insn_ruid bzero call.
+	Check INSN_UID before storing into insn_ruid array.
+
+Wed Nov 18 10:57:49 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.md: Fix define_split for sasf insns, so that it
+	will not generate bad code if the source and destination registers
+	are the same.
+
+Mon Nov 16 09:46:46 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/d10v/d10v.c (print_operand_memory_reference): Surround
+	user symbols with parentheses in order to distinguish them from
+	register names.
+
+
+Fri Nov 13 10:14:04 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (optimize_related_values_1): Reject optimization if
+	offset for rel_base_reg_user would be to large.
+
+Fri Nov 13 04:36:06 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (rel_record_mem): Don't do anything if the register
+	already has an invalidate_luid.
+
+Thu Nov 12 19:20:57 1998  Geoffrey Noer  <noer@cygnus.com>
+
+    * i386/beos-pe.h: Fix references to cygwin32.h in light of above.
+
+
+Thu Nov 12 23:02:32 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (invalidate_related): Don't do anything if the register
+	already has an invalidate_luid.
+	(optimize_related_values): Don't update death field if
+	invalidate_luid field is set.
+
+Fri Oct 30 14:51:26 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (languages): Add missing ";;" in case statement.
+
+Thu Oct 29 19:08:12 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* d10v/d10v.c (d10v_split_logical_op): If reload_completed, create
+	REGs instead of SUBREGS.
+
+Wed Oct 28 23:05:17 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* invoke.texi: Add new alignment options for MIPS targets.
+	* tm.texi (FUNCTION_BOUNDARY_MAX_SKIP): Document new target macro.
+	* varasm.c (FUNCTION_BOUNDARY_MAX_SKIP): Provide a default value.
+	(assemble_start_function): Use ASM_OUTPUT_MAX_SKIP_ALIGN if defined.
+	* mips.c: Add new variables for alignment and maximum skip support.
+	(override_options): Handle alignment and maximum skip arguments.
+	* mips.h (SUBTARGET_TARGET_OPTIONS): Add new alignment and maximum
+	skip options.
+	(FUNCTION_BOUNDARY, LOOP_ALIGN, LABEL_ALIGN_AFTER_BARRIER): Use
+	alignment and maximum skip values computed in override_options.
+	(FUNCTION_BOUNDARY_MAX_SKIP): Define.
+	(ASM_OUTPUT_MAX_SKIP_ALIGN): Define.
+
+Wed Oct 28 15:29:56 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* c-common.c (c_get_alias_set): Handle ARRAY_REF of union field.
+
+Tue Oct 27 15:09:42 1998  Nick Clifton  (nickc@cygnus.com)
+
+	Merge in arm-elf related changes from EGCS:
+
+	* configure.in: Add arm-*-linux-gnu, armv2-*-linux and arm-*-elf
+	targets. 
+
+	* configure: Regenerated.
+	
+	* config/arm/aout.h: Add default definitions of REGISTER_PREFIX,
+	USER_LABEL_PREFIX and LOCAL_LABEL_PREFIX.  Make other macro
+	definitions conditional on their not having been already defined.
+
+	* config/arm/lin1funcs.asm: Add ELF only macros to generate .size
+	and .type directives, and add "(PLT)" qualification to function
+	calls.
+
+	* config/arm/linux.h: Deleted.  This file is now superceeded by
+	either linux-elf.h or linux-aout.h.
+
+	* config/arm/linux-gas.h: Define `inhibit_libc' if cross-compiling.
+	(CLEAR_INSN_CACHE): New macro, currently disabled (awaiting kernel
+	support).
+	Move definitions from old linux.h file here.
+	
+	* config/arm/elf.h: Now contains only generic ARM/ELF support.
+	
+	* config/arm/linux-aout.h: Support for Linux with a.out.
+	
+	* config/arm/linux-elf.h: New file.  Support for Linux with ELF.
+	
+	* config/arm/linux-elf26.h: New file.  Support for Linux with ELF
+	using the 26bit APCS.
+	
+	* config/arm/unknown-elf.h: New file.  Support for OS'es other
+	than Linux with ELF.
+
+	* config/arm/coff.h: Include aout.h for basic assembler macros.
+	
+	* config/arm/arm.h: Make macro definitions conditional on their
+	not having been already defined. 
+
+Thu Oct 22 16:28:42 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* reload1.c reload.c reload.h: Install Bernd's reload patches on
+	this branch for testing.
+
+
+Wed Oct 21 11:43:46 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850ea.h (MASK_US_BIT_SET): Change value to 0x1000
+	to avoid clash with MASK_NO_APP_REGS.
+	(MASK_US_BIT_SET): Change value to 0x2000 to avoid clash with
+	MASK_NO_DISABLE_CALLT.
+
+	* config/v850/v850.c (construct_dispose_instruction): Obey setting
+	of TARGET_DISABLE_CALLT.
+	(construct_prepare_instruction): Obey setting of TARGET_DISABLE_CALLT.
+
+Mon Oct 19 14:31:56 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add FR30 target.
+	* configure:    Add FR30 target.
+	* config.sub:   Add FR30 target.
+	* config/fr30:  New directory.
+	* config/fr30/fr30.c:    New target specific C source.
+	* config/fr30/fr30.h:    New target specific header file.
+	* config/fr30/fr30.md:   New target specific machine description.
+	* config/fr30/xm-fr30.h: New target specific cross make header.
+	* config/fr30/t-fr30:    New target specific makefile fragment.
+
+	* config/m32r/m32r.h (TARGET_SWITCHES, TARGET_OPTIONS): Document m32r
+	specific command line switches.
+
+Mon Oct 19 07:33:00 1998  Catherine Moore  <clm@cygnus.com>
+ 
+       *  config/rs6000/sysv4.h (CPP_SPEC):  Define _SOFT_FLOAT
+       if -msoft-float.
+    
+Fri Oct 16 10:47:53 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.h (TARGET_SWITCHES): Add --help documentation.
+	(TARGET_OPTIONS): Add --help documentation.
+
+Thu Oct 15 13:44:30 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* d30v/d30v.c (d30v_eh_epilogue_sp_ofs): New variable.
+	(d30v_stack_info): Correct calculation for link_offset.
+	(d30v_function_epilogue): Don't clear d30v_return_addr_rtx here.
+	(d30v_expand_epilogue): Use d30v_epilogue_sp_ofs.
+	(struct machine_function): New type.
+	(d30v_save_machine_status, d30v_restore_machine_status,
+	d30v_init_expanders): New functions.
+	(d30v_return_addr): Call push_topmost_sequence, pop_topmost_sequence.
+	* d30v/d30v.h (INCOMING_RETURN_ADDR_RTX): Change VOIDmode to Pmode.
+	(INIT_EXPANDERS): New macro.
+	(d30v_init_expanders, d30v_eh_epilogue_sp_ofs): Add declarations.
+	* d30/d30v.md (eh_epilogue): New.  Set d30v_eh_epilogue_sp_ofs.
+
+Wed Oct 14 21:38:11 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (optimize_related_values): Check if cc0 is set.
+
+	* regmove.c (optimize_related_values): Fix problem with multiple
+	related values in single insn.
+
+Tue Oct 13 12:25:24 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.c: Synchronised with egcs.
+	
+	* config/v850/v850.md: Synchronised with egcs.
+
+	* config/m32r/m32r.md (sne): Only accept unsigned 16bit integers.
+
+Tue Oct 13 07:55:04 1998  Catherine Moore  <clm@cygnus.com>
+
+	* config/arm/elf.h:  Fix typo.
+	* config/arm/telf.h:  Ditto.
+
+Mon Oct 12 22:57:24 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* sparc.h: Fix minor merge lossage in 64bit sparc support.
+
+Mon Oct 12 14:10:48 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.c: Fix CYGNUS LOCAL markers.
+	
+	* config/arm/arm.c (arm_override_options): Add initialisation of
+	arm_ld_sched boolean. 
+	
+	Fix CYGNUS LOCAL markers.
+
+	* config/arm/arm.md: Add ldsched attribute and use in computing
+	functional units.
+	
+	Fix CYGNUS LOCAL markers.
+
+	Replace (reg 24) with (reg:CC 24).
+
+	* config/arm/arm.h: Add export of arm_ld_sched.
+
+Mon Oct 12 09:21:32 1998  Catherine Moore  <clm@cygnus.com>
+
+	* config/arm/elf.h (MAKE_DECL_ONE_ONLY):  Define.
+	(UNIQUE_SECTION_P):  Define.
+	(UNIQUE_SECTION):  Define.
+	* config/v850/v850.c (print_operand):  Extend meaning
+	of 'c' operands to support .vtinherit.
+
+Thu Oct  8 17:06:15 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/elf.h (DWARF_DEBUGGING_INFO): Define.
+	(ASM_OUTPUT_DWARF2_ADDR_CONST): Define.
+	(ASM_OUTPUT_DWARF_ADDR_CONST): Redfeine to work for Dwarf-1.
+
+	* config/arm/telf.h (DWARF_DEBUGGING_INFO): Define.
+	(ASM_OUTPUT_DWARF2_ADDR_CONST): Define.
+	(ASM_OUTPUT_DWARF_ADDR_CONST): Redfeine to work for Dwarf-1.
+	(ASM_OUTPUT_DEF): Define.
+	
+Thu Oct  8 11:02:06 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* d30v.md (seq, sne, sgt, sge, slt, sle, sgtu, sgeu, sltu, sleu):
+	Add (eq:SI ... (const_int 1)) around operand 1.
+	(setcc_internal): Likewise.
+	(decscc): Likewise for operand 2.
+	(incscc): Switch operands 1 and 2, then likewise for operand 1.
+
+Thu Oct  8 10:59:42 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* d30v.c (d30v_emit_cond_move): Generate pattern that can be
+	matched by the new setcc_internal pattern.
+	
+	* tree.h: Remove (unused) data_area field of struct
+	tree_decl.
+
+	* c-decl.c (duplicate_decls): Remove code to copy data_area 
+	field of struct tree_decl.
+	(start_decl): Remove invocation of SET_DEFAULT_SECTION_NAME.
+	(start_function): Add invocation of SET_DEFAULT_DECL_ATTRIBUTES.
+
+	* tm.texi (SET_DEFAULT_SECTION_NAME): Remove definition of
+	this unused macro.
+
+Tue Oct  6 10:59:15 1998  Catherine Moore  <clm@cygnus.com>
+
+	* config/sparc/sysv4.h (ASM_OUTPUT_SECTION_NAME):  Don't
+	check for flag_function_sections.
+
+Mon Oct  5 09:59:40 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in: Remove CYGNUS LOCAL markers for unlibsubdir changes.
+
+Fri Oct  2 16:58:37 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* dwarf2out.c (gen_subprogram_die): If errorcount nonzero, don't
+	call abort if the function is already defined.
+
+Thu Oct  1 17:59:03 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c: Import changes from egcs.
+
+Wed Sep 30 10:41:21 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.md: Replace 'memory_operand' with
+	'indirect_operand' in set1, not1 and clr1 patterns.
+
+	* config/v850/v850.c (compute_register_save_size): Detect when
+	out-of-line helper functions will be used to create function
+	prologues, and allow for their affect on the frame size.
+
+	* config/v850/v850.h (EXTRA_SWITCHES): Default the contents of this
+	macro to empty.
+
+	* config/v850/lib1funcs.asm: Add type attributes for callt
+	functions. 
+
+Tue Sep 29 09:36:33 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/d30v/libgcc1.asm: Fixinstruction ordering conflicts
+	detected by recent changes in the assembler.
+
+Mon Sep 28 13:20:44 1998  Catherine Moore  <clm@cygnus.com>
+
+       * configure.in: Add CYGNUS LOCAL markers.
+       * config/arm/aout.h: Ditto.
+       * config/arm/arm.h: Ditto.
+       * config/arm/t-arm-elf: Ditto.
+       * config/arm/t-thumb-elf: Ditto.
+
+Fri Sep 15 16:00:00 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* reload1.c (reload): Use reload_address_index_reg_class and
+	reload_address_base_reg_class when setting caller_save_spill_class.
+	* config/arm/arm.md (insv): Add comment.  In CONST_INT case, and
+	operand3 with mask before using it.
+
+Wed Sep 23 16:35:17 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.h (enum reg_class): Add NONARG_LO_REGS
+	support.
+	(REG_CLASS_NAMES, REG_CLASS_CONTENTS, REGNO_REG_CLASS,
+	PREFERRED_RELOAD_CLASS, SECONDARY_RELOAD_CLASS): Likewise.
+	(GO_IF_LEGITIMATE_ADDRESS): Disable REG+REG addresses before reload
+	completes.  Re-enable HImode REG+OFFSET addresses.
+	(LEGITIMIZE_RELOAD_ADDRESS): Define.
+
+Wed Sep 23 20:42:54 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (optimize_related_values_1): Set use->insn when emitting
+	the linking insn before the final 'use' for a register that does not
+	die within the scope of the optimization.
+
+
+Mon Sep 21 15:04:16 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (count_sets): New function.
+	(gen_add3_insn): If single instruction add fails and source and
+	destination register are different, try a move / add sequence.
+	(rel_use_chain): New member match_offset.
+	(optimize_related_values_1): Set it, and use it to avoid linking
+	chains when this requires more than one instruction for the add.
+	(add_limits): New file scope array.
+	(optimize_related_values): Initialize it.
+
+Mon Sep 21 14:55:36 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* regmove.c (optimize_related_values_1): Don't use rel_base->reg
+	for a chain that needs an out-of-range offset.
+	Take setting of rel_base_reg_user into account when deciding
+	if there are enough registers available.
+
+Fri Sep 18 11:54:03 1998  Catherine Moore  <clm@cygnus.com>
+
+	* config/elfos.h:  Modify prefixes for UNIQUE_SECTION_NAME.
+	* config/svr4.h:  Likewise.
+	* config/mips/elf.h:  Likewise.
+	* config/mips/elf64.h:  Likewise.
+
+Fri Sep 18 09:44:55 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.h (m32r_block_immediate_operand): Add to
+	PREDICATE_CODES.
+
+	* config/m32r/m32r.md: Add "movstrsi" and "movstrsi_internal"
+	patterns.
+
+	* config/m32r/m32r.c (m32r_print_operand): Add 's' and 'p'
+	operators.
+	(block_move_call): New function: Call a library routine to copy a
+	block of memory.
+	(m32r_expand_block_move): New function: Expand a "movstrsi"
+	pattern into a sequence of insns.
+	(m32r_output_block_move): New function: Expand a
+	"movstrsi_internal" pattern into a sequence of assembler opcodes.
+
+Wed Sep 16 14:13:38 1998  Stan Cox  <scox@cygnus.com>
+
+	* i386-coff.h (DBX_DEBUGGING_INFO): Added.
+
+Wed Sep 16 12:09:12 1998  Catherine Moore  <clm@cygnus.com>
+
+	* flags.h:  Add flag_data_sections.
+	* toplev.c:  Add option -fdata-sections.  Add flag_data_sections.
+	(compile_file):  Error if flag_data_sections not supported.
+	* varasm.c (assemble_variable):  Handle flag_data_sections.
+
+Tue Sep 15 16:41:00 1998  Michael Tiemann  <michael@impact.tiemann.org>
+
+	* fold-const.c (fold): Fix typo in COND_EXPR handling code.
+	(invert_truthvalue): Enable truthvalue inversion for
+	floating-point operands if -ffast-math.
+
+	* regmove.c (find_related): We also have to track expressions that
+	are just naked registers.  Otherwise, we burn one register to
+	prime the related values, and we'll also miss the second (but not
+	subsequent) opportunities to use related values.
+
+	* libgcc1.c (__abssf2, __absdf2): New libcalls.
+	* Makefile.in (LIB1FUNCS): Add code for new ABS libcalls.
+	* optabs.c (init_optabs): Intialize abs_optabs to use ABS
+	libcalls.
+
+Tue Sep 15 17:09:49 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* sh.h (SECONDARY_INPUT_RELOAD_CLASS): Add special case for FPSCR.
+	(GO_IF_LEGITIMATE_ADDRESS): Allow indexed addressing for PSImode
+	after reload.
+	(LEGITIMIZE_RELOAD_ADDRESS): Don't operate on
+	RELOAD_FOR_INPUT_ADDRESS for PSImode.
+	* sh.md (movpsi): New expander.
+	(fpu_switch): Add r/r and m/r alternatives.  Move r/m before
+	c/m.  Add insn predicate.
+
+Tue Sep 15 09:47:50 1998  Catherine Moore  <clm@cygnus.com>
+
+	* config/arm/aout.h:  Check if ASM_DECLARE_FUNCTION_NAME
+	already declared.
+	* config/arm/elf.h (TYPE_ASM_OP): Define.
+	(SIZE_ASM_OP): Define.
+	(TYPE_OPERAND_FMT): Define.
+	(ASM_DECLARE_RESULT): Define.
+	(ASM_DECLARE_FUNCTION_NAME): Define.
+	(ASM_DECLARE_OBJECT_NAME): Define.
+	(ASM_FINISH_DECLARE_OBJECT): Define.
+	(ASM_DECLARE_FUNCTION_SIZE): Define.
+	(ASM_OUTPUT_SECTION_NAME): Change default to "ax".
+	* config/arm/telf.h (ASM_OUTPUT_SECTION_NAME):  Change
+	default to "ax".
+
+Mon Sep  7 23:50:56 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* rs6000.c (rs6000_override_options): Add -mcpu=740 as a place
+	holder.
+
+Thu Sep  3 18:16:16 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* rs6000.c (rs6000_override_options): Add -mcpu=750 as a place
+	holder.
+
+Thu Sep  3 23:33:57 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* rtl.h (push_obstacks_nochange, end_temporary_allocation): Declare.
+	* regmove.c (obstack.h): Include.
+	(REL_USE_HASH_SIZE, REL_USE_HASH, rel_alloc, rel_new): Define.
+	(struct related, struct related_baseinfo, struct update): New structs.
+	(struct rel_use_chain, struct rel_use): Likewise.
+	(regno_related, rel_base_list, unrelatedly_used): New variables.
+	(related_obstack): Likewise.
+	(regclass_compatible_p, lookup_related): New functions.
+	(rel_build_chain, rel_record_mem, invalidate_related): Likewise.
+	(find_related, chain_starts_earlier, chain_ends_later): Likewise.
+	(optimize_related_values_1, optimize_related_values_0): Likewise.
+	(optimize_related_values): Likewise.
+	(regmove_optimize): Use regclass_compatible_p.
+	Call optimize_related_values.
+
+Tue Sep  1 11:30:33 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Change (reg:CC 17) to (reg:SI 17).
+	* config/m32r/m32r.h: Make register 17 be fixed.
+
+Mon Aug 31 11:29:15 1998  Catherine Moore  <clm@cygnus.com>
+
+	* config/arm/elf.h:  Rework constructor/destructor support.
+	* config/arm/telf.h:  Likewise.
+	* config/arm/t-arm-elf:  New file.
+	* config/arm/t-thumb-elf:  New file.
+	* configure.in:  Change tmake_file to t-arm-elf for
+	arm-elf and to t-thumb-elf for thumb-elf.
+	* configure:  Rebuild.
+
+Mon Aug 31 09:53:24 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* range.c (live_range): Do not perform LRS on phony loops.
+
+	* range.c (range_finish): Start block 0 at the first CODE_LABEL or
+	real insn.
+
+Wed Aug 26 17:13:37 1998  Tom Tromey  <tromey@cygnus.com>
+
+	* gthr.h: Document __GTHREAD_MUTEX_INIT_FUNCTION.
+	* gthr-qt.h: New file.
+	* frame.c (init_object_mutex): New function.
+	(init_object_mutex_once): Likewise.
+	(find_fde): Call it.
+	(__register_frame_info): Likewise.
+	(__register_frame_info_table): Likewise.
+	(__deregister_frame_info): Likewise.
+	* configure.in: Recognize `qt' as a thread package.  Add
+	appropriate -I option to gthread_flags when using qt.
+	* configure: Rebuilt.
+
+Wed Aug 26 16:22:51 1998  Jeffrey A Law  (law@cygnus.com)
+	
+	* toplev.c (rest_of_compilation): Enable LRS at -O2 and higher for
+	systems which prefer stabs debug symbols.
+	* invoke.texi: Restore lost LRS docs.  Note LRS is enabled at -O2
+	and higher for some systems.
+
+	* toplev.c (rest_of_compilation): Run recompute_reg_usage before
+	LRS, not after.
+
+Wed Aug 26 09:30:59 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.c (thumb_exit): Do not move a4 into lr if it
+	already contains the return address.
+
+	* cse.c (equiv_constant): Cope with gen_lowpart_if_possible()
+	returning 0.
+
+Wed Aug 26 11:18:57 1998  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* mips.md (lshrsi3_internal2+2): Fix type-o.
+
+Tue Aug 25 11:38:21 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.c (movsi_source_operand): Treat CONSTANT_P_RTX
+	as an ordinary operand.
+
+Sat Aug 22 00:11:51 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* rs6000.md (movdf_softfloat32): Accept any valid memory
+	address.
+
+Thu Aug 20 15:04:28 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* d30v.h (ASM_GENERATE_INTERNAL_LABEL): Remove definition, svr4.h
+	supplies an appropriate one.
+
+	* d10v.c: Include system.h, not stdio.h to get sys/param.h pulled
+	in before rtl.h in case the system defines MIN and MAX.
+	* d30v.h: Ditto.
+
+Wed Aug 19 11:57:57 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/elf.h (ASM_OUTPUT_INTERNAL_LABEL): Define.
+
+Tue Aug 18 10:02:53 1998  Catherine Moore  <clm@cygnus.com>
+
+	* config/arm/elf.h:  Define ASM_SPEC and LINK_SPEC.
+
+Wed Aug 12 14:12:40 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.md (extendqisi2_insn): Cope with REG +
+	OFFSET addressing.
+
+	* config/arm/m32r.md (sne): Only generate xor insns when the
+	constant is unsigned.
+	
+Wed Aug 12 12:47:50 1998  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* mips/mips.h (ENCODE_SECTION_INFO): Set SYMBOL_REF_FLAG for
+	VAR_DECL's in gp addressable sections.
+
+Wed Aug 12 09:02:55 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.c (m32r_not_same_reg): New function.  Returns
+	true iff its two arguments are rtx's that refer to different
+	registers. 
+
+	* config/m32r/m32r.h (PREDICATE_CODES): Add m32r_not_same_reg().
+
+	* config/m32r/m32r.md (andsi3, iorsi3, xorsi3): Use
+	m32r_not_same_reg() rather than rtx_equal_p().
+	
+Tue Aug 11 09:15:23 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* tm.texi (SET_DEFAULT_SECTION_NAME): Add CYGNUS LOCAL markers.
+
+Mon Aug 10 11:36:04 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.h: Add prototypes for some exported functions.
+
+	Remove spurious CYGNUS LOCAL markers, and add required CYGNUS
+	LOCAL markers.
+
+	Define HANDLE_PRAGMA and SET_DEFAULT_SECTION_NAME macros and the
+	enums used by the code in v850.c that implements them.
+	New enums: v850_pragma_state, v850_pragma_type, GHS_section_kind.
+
+	* config/v850/v850.c: Add prototypes for functions not prototypes
+	in v850.h.
+
+	Add default cases to some switch statements, in order to eliminate
+	warning messages when compiled with -Wall.
+
+	Add support for sda, tda and zda attributes.  Moved here from
+	c-decl.c.  Add code to implement some GHS pragmas.
+	New functions: push_data_area, pop_data_area, v850_handle_pragma,
+	mark_current_function_as_interrupt, parse_ghs_pragma_token,
+	v850_set_default_section_name.
+
+Fri Aug  7 17:25:29 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* c-decl.c (duplicate_decls): Copy data area from old decl into
+	new decl.
+	(start_decl): Add use of SET_DEFAULT_SECTION_NAME, if defined.
+	(start_function): Add use of SET_DEFAULT_SECTION_NAME, if defined.
+
+	* c-lex.c (check_newline):  Call HANDLE_PRAGMA before
+	HANDLE_SYSV_PRAGMA if both are defined.  Generate warning messages
+	if unknown pragmas are encountered.
+	(handle_sysv_pragma): Interpret return code from
+	handle_pragma_token ().  Return success/failure indication rather
+	than next unprocessed character. 
+	
+	* c-pragma.c (handle_pragma_token): Return success/failure status
+	of the parse.
+	
+	* c-pragma.h: Change prototype of handle_pragma_token().
+
+	* tm.texi (HANDLE_PRAGMA): Document the use of HANDLE_PRAGMA when
+	USE_CPPLIB is enabled.
+	(SET_DEFAULT_SECTION_NAME): New macro.  Allows backend to setup
+	the section name of a decl when it is created.
+
+	* tree.h (DECL_DATA_AREA): New macro.  Accesses data_area field of
+	a decl
+	(struct tree_decl): Add new field 'data_area'.
+	
+	* varasm.c: (handle_pragma_weak): Only create this function if
+	HANDLE_PRAGMA_WEAK is defined.
+	
+Mon Aug  3 08:00:00 1998  Catherine Moore  <clm@cygnus.com>
+
+	* configure.in:  Support arm-*-elf and thumb-*-elf.
+	* configure: Regenerate.
+
+Fri Jul 31 16:13:04 1998  Catherine Moore  <clm@cygnus.com>
+ 
+	* config/arm/elf.h: New file.
+	* config/arm/telf.h: New file.
+	* config/arm/aout.h: Check if ASM_FILE_START previously
+	defined.
+	* config/arm/arm.h: Check if STRUCTURE_SIZE_BOUNDARY
+	previously defined.
+ 
+Fri Jul 31 16:00:41 1998  Ken Raeburn  <raeburn@cygnus.com>
+
+	* mips.md (mulsi3_mult3): Add TARGET_MIPS5400 to condition.
+	(muls_r5400, msac_r5400): Don't disparage output-LO alternative.
+	(msac_r5400): Use "*d" for accumulator, to give preference to LO
+	initially but not during reload.
+	(muls_r5400_di, msac_r5400_di, xmulsi3_highpart_5400,
+	xmulsi3_neg_highpart_5400): Fix typo, SIGN_EXTRACT for
+	SIGN_EXTEND.
+	(macc_r5400_di): Absorb into mul_acc_64bit_di.
+	(mul_acc_64bit_di): Don't use match_dup for accumulator, use "0"
+	constraint.
+	* t-vr5000 (MULTILIB_OPTIONS, MULTILIB_DIRNAMES): Add VR5400
+	options.
+
+Fri Jul 31 10:23:55 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* m32r/m32r.h (ASM_OUTPUT_SOURCE_LINE): Always output line number
+	labels with .debugsym if no parallel insns.
+
+Fri Jul 31 09:45:07 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* reload1.c (init_reload): On SMALL_REGISTER_CLASSES machines,
+	when searching for a reload_address_reg_class, avoid fixed
+	registers as well as argument registers.
+
+Wed Jul 29 11:47:10 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.md (extendqisi2_insn): Remove earlyclobber
+	constraint from second alternative.
+
+Tue Jul 28 18:54:28 1998  Stan Cox  <scox@cygnus.com>
+
+	* sp86x-aout.h (HAVE_ATEXIT): New macro.
+	
+Tue Jul 28 11:12:46 1998  Vladimir N. Makarov  <vmakarov@cygnus.com>
+
+	* cse.c (cse_insn): Enable subsitution inside libcall only for REG,
+	SUBREG, MEM.
+	* rtlanal.c (replace_rtx): Prohibit replaces in	CONST_DOUBLE. 
+
+Fri Jul 24 11:17:04 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.c (thumb_print_operand): Decode %_ in asm
+	strings as the insertion of USER_LABEL_PREFIX.
+	* config/arm/thumb.h (PRINT_OPERAND_PUNCT_VALID_P): Accept _ as a
+	valid code.
+	* config/arm/thumb.md: Use %_ as a prefix to gcc library function
+	calls. 
+
+Thu Jul 23 13:16:29 1998  Jim Wilson  <wilson@cygnus.com>
+ 
+	* dwarf2out.c (dwarf2out_finish): Call stripattributes on TEXT_SECTION.
+ 
+Thu Jul 23 11:12:06 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* expr.c (expand_expr): Expand RETURN_EXPR.
+
+Wed Jul 22 21:43:54 1998  Stan Cox  <scox@cygnus.com>
+
+	* longlong.h (count_leading_zeros): Sparclite scan instruction was
+	being invoked incorrectly.
+
+	* i386.c (ix86_prologue): Added SUBTARGET_PROLOGUE invocation.
+	* i386/cygwin32.h (STARTFILE_SPEC, LIB_SPEC, SUBTARGET_PROLOGUE): 
+	Add -pg support. 
+	* i386/win32.h: New file.  Hybrid mingw32.h/cygwin32.h configuration.
+	
+Wed Jul 22 18:40:00 1998  Catherine Moore  <clm@cygnus.com>
+
+	* dwarf2out.c (output_aranges):  Call stripattributes
+	for TEXT_SECTION references.
+	(output_line_info): Likewise.
+
+Mon Jul 20 16:40:31 1998  Dave Brolley  <brolley@cygnus.com>
+
+	* cpplib.c (cpp_handle_option): More fixes for cplusplus_comments.
+
+Mon Jul 20 15:09:54 1998  Ken Raeburn  <raeburn@cygnus.com>
+
+	* mips.md (attribute "type"): Add new value "frsqrt".
+	(function unit specs): Handle frsqrt like fsqrt, except if r5400.
+	(sqrtsf2+1 et al): Use frsqrt type for rsqrt.FMT instructions.
+	(function unit "memory"): Treat r5400 like r5000.
+	(function unit "imuldiv"): Set costs for r5400.  Delete a
+	duplicated entry.
+	(function units "adder", "divide"): Don't use for r5400.
+	(function unit "alu_5400"): Don't use for imul or idiv
+	instructions; do use for arith, darith, move, icmp, nop.  Adjust
+	issue delay.
+
+Tue Jul 14 16:15:13 1998  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in (i?86-*-beos{pe,elf,}*): Recognize.
+	* i386/t-beos, i386/x-beos, i386/xm-beos.h: New files.
+	* i386/beos-elf.h, i386/beos-pe.h: New files.
+
+Tue Jul 14 14:15:30 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* gcc.c: Remove ANSI-C ism from --help code.
+
+	* toplev.c: Support --help with USE_CPPLIB.
+
+Mon Jul 13 21:45:17 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* expr.c (expand_builtin): Do not warn for targets which do not
+	support CONSTANT_P_RTX.  Temporary patch until next merge
+	
+Mon Jul 13 11:10:15 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850ea.h (EXTRA_SWITCHES): Document these switches.
+	* config/v850/v850e.h (EXTRA_SWITCHES): Document these switches.
+	* config/v850/v850.h (TARGET_OPTIONS, TARGET_SWITCHES,
+	EXTRA_SWITCHES): Document these switches.
+
+	* cccp.c (main): Add support for parsing --help.
+	(display_help): New function: display command line switches.
+
+	* cpplib.c (cpp_handle_option): Add support for parsing --help.
+	(display_help): New function: display command line switches.
+
+	* gcc.c (main): Add support for parsing --help, and passing it on
+	to the sub-processes invoked by gcc.
+	(display_help): New function: display comman line switches.	
+
+	* tm.texi (TARGET_SWITCHES and TARGET_OPTIONS): Document
+	'description' field added to structure.  
+
+	* toplev.c: Add support for parsing --help.
+	Add documentation strings to command line option tables.
+	(display_help): New function: display comman line switches.
+
+Mon Jul 13 11:10:15 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/semi.h (USER_LABEL_PREFIX): Change to "" to match
+	FSF sources.
+
+	* config/arm/tcoff.h (USER_LABEL_PREFIX): Change to "" to match
+	change to semi.h
+
+Sun Jul 12 13:34:23 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* jump.c (duplicate_loop_exit_test): Fix typo in last change.
+
+Sat Jul 11 02:59:08 1998  Richard Earnshaw  <rearnsha@arm.com>
+
+	* arm.md (extendhisi2_mem, movhi, movhi_bytes): Propagate the volatile
+	and structure attribute flags to MEMs generated.
+	(splits for sign-extended HI & QI mode from memory):  Also propagate 
+	the volatile flag.
+
+Sat Jul 11 01:18:33 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* jump.c (duplicate_loop_exit_test): Avoid out of bounds access
+	to the reg info virtual array.
+
+Thu Jul  9 10:49:08 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* arm/tpe.h (JUMP_TABLES_IN_TEXT_SECTION): Define with a value.
+	* i386/i386elf.h: Likewise.
+	* i386/rtemself.h: Likewise.
+
+	* Makefile.in: Fix minor merge lossage which caused incorrect
+	dependencies.
+
+Wed Jul  8 23:37:59 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* d30v.h (STDIO_PROTO): Likewise.
+
+Wed Jul  8 16:53:37 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* range.c (range_print_flags): Add static to definition.
+
+1998-07-08  Vladimir N. Makarov  <vmakarov@cygnus.com>
+
+	* config/fp-bit.c (__gexf2, __fixxfsi, __floatsixf): Add function
+	stubs.
+
+	* toplev.c (lang_options): Add -Wlong-long, -Wno-long-long
+	options.
+	* c-decl.c (warn_long_long): Define.
+	(c_decode_option): Parse -Wlong-long, -Wno-long-long options.
+	(grokdeclarator): Add flag `warn_long_long' as guard for
+	warning "ANSI C does not support `long long'".
+	* invoke.texi: Add description of options -Wlong-long,
+	-Wno-long-long.
+	* gcc.1: The same as above.
+	
+Wed Jul  8 09:45:22 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* haifa-sched.c (debug_ready_list): Remove static qualifier, so
+	that it can be called from machine back ends.
+
+	* libgcc1-test.c: Remove duplicate prototype for memcpy().
+
+	* config/arm/arm.c (arm_override_options): Reference 'flags'
+	rather than 'tune_flags'.
+
+Wed Jul  8 03:22:22 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Merge from egcs snapshot 19980707.
+
+Mon Jul  6 09:32:14 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/tpe.h (REDO_SECTION_INFO_P): Define.
+
+	* config/arm/thumb.c (thumb_override_options): Warn about and
+	ignore '-fpic'.
+
+	* config/m32r/m32r.h (MUST_PASS_IN_STACK): Override default
+	version. 
+
+Thu Jul  2 08:11:00 1998  Catherine Moore  <clm@cygnus.com>
+
+	* haifa-sched.c (alloc_EXPR_LIST):  Change to use
+	unused_expr_list.
+
+Mon Jun 29 12:15:00 Catherine Moore  <clm@cygnus.com>
+
+	* config/sparc/lb1spc.asm (.udiv, .div) Replace routines.
+
+1998-06-26  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (LOOP_TEST_THRESHOLD): If loop unrolling and saving
+	space, don't suppress moving the loop test from top to the bottom.
+
+Thu Jun 25 09:53:24 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.h (REG_ALLOC_ORDER): Add ARG_POINTER_REGNUM,
+	noticed by grahams@rcp.co.uk.
+
+Wed Jun 24 10:39:32 1998  Stan Cox  <scox@cygnus.com>
+
+	* sparc.md (sethi_di_sp32): Swap registers if we are
+	compiling in little endian mode.
+	
+	* sparc.h (CPP_ENDIAN_SPEC, LIBGCC2_WORDS_BIG_ENDIAN): Check for
+	mlittle-endian-data in addition to mlittle-endian.
+	
+	* sp86x-aout.h (ASM_SPEC, SUBTARGET_SWITCHES): -mlittle-endian-data
+	
+	* ginclude/va-d30v.h (va_arg): struct args < 4 bytes must be offset.
+
+Tue Jun 23 21:27:27 1998  Ken Raeburn  <raeburn@cygnus.com>
+
+	* reload.c (find_reloads): Fix check for failure to match any
+	alternative, to account for Mar 26 change in initial "best" cost.
+
+Tue Jun 23 14:20:57 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/d30v/d30v.h (FIXED_REGISTERS): Remove reference to return
+	address register.
+	(CALL_USED_REGISTERS): Ditto.
+
+Tue Jun 23 16:42:29 1998  Dave Brolley  <brolley@cygnus.com>
+
+	* cpplib.c (open_include_file_name): Mark as local change.
+
+Mon Jun 22 10:30:00 1998  Catherine Moore  <clm@cygnus.com>
+
+	* varasm.c (assemble_variable): Emit alignment warning.
+
+Sat Jun 20 04:10:50 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (MD_SCHED_{VARIABLE_ISSUE,INIT,REORDER}): Define.
+	(m32r_sched_{variable_issue,init,reorder}): Add declarations.
+
+	* m32r.c (m32r_sched_odd_word_p): New global to keep track of
+	whether we are on an odd word or even word.
+	(m32r_adjust_priority): Optimize slightly.
+	(m32r_sched_init): New function to zero m32r_sched_odd_word_p.
+	(m32r_sched_reorder): New function to reorder the ready list based
+	the instruction sizes.  Move long instructions before short ones,
+	except if we are on an odd word boundary.
+	(m32r_sched_variable_issue): New function to keep track of whether
+	we are on an odd byte boundary.
+
+Fri Jun 19 21:33:21 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (whole file): Align \'s to column 72.
+	(*_SPEC): Use EXTRA_SPECS to move cpu dependent stuff down into
+	{ASM,CPP,CC1,LINK,STARTFILE,ENDFILE}_CPU_SPEC.
+	(TARGET_SWITCHES): Add support for new debug switches
+	-missue-rate={1,2} and -mbranch-cost={1,2}.  Add
+	SUBTARGET_SWITCHES for cpu dependent switches.
+	(TARGET_OPTIONS): Add support cpu dependent switches.
+	(MULTILIB_DEFAULTS): Ditto.
+	(OVERRIDE_OPTIONS): Ditto.
+	(OPTIMIZATION_OPTIONS): Ditto.
+	({FIXED,CALL_USED}_REGISTERS): Ditto.
+	(REG_ALLOC_ORDER): Ditto.
+	(CONDITIONAL_REGISTER_USAGE): Ditto.
+	(REG_CLASS_CONTENTS): Ditto.
+	(GPR_P): Ditto.
+	({,ADDITIONAL_}REGISTER_NAMES): Ditto.
+	(M32R_MODEL_DEFAULT): Wrap inside #ifndef/#endif.
+	(SDATA_DEFAULT_SIZE): Ditto.
+	(IN_RANGE_P): New macro to test if something is in a range of
+	values.
+	(INT8_P): Recode to use IN_RANGE_P.
+	({,CMP_,U}INT16_P): Ditto.
+	(UPPER16_P): Ditto.
+	(UINT{24,5}_P): Ditto.
+	(INT32_P): Ditto.
+	(INVERTED_SIGNED_8BIT): Ditto.
+	({ACCUM,CARRY}_P): New macros for accumulator and carry.
+	(BRANCH_COST): Set to 1/2 depending on -mbranch-cost={1,2}.
+	(ENABLE_REGMOVE_PASS): Delete, no longer used.
+	(ASM_OUTPUT_ALIGNED_LOCAL): Ditto.
+	(ISSUE_RATE): Set to 1/2 depending on -missue-rate={1,2}.
+	(DWARF2_DEBUGGING_INFO): Define.
+	(whole file): Group most of the m32rx specific stuff together
+	using the subtarget support.  Define the various specs
+	{ASM,CPP,CC1,LINK,STARTFILE,ENDFILE}_CPU_SPEC.
+
+Thu Jun 18 09:03:31 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.c ({internal_,}reg_or_eq_int16_operand): New functions to
+	return whether an operand is suitable for == operations.
+	(gen_compare): Remove support for handling S<op> operations, just
+	handle branches.
+
+	* m32r.h (PREDICATE_CODES): Add new predicate functions.
+	({internal_,}reg_or_eq_int16_operand ): Add declarations.
+	(gen_compare): Remove argument saying to produce S<op> operations
+	instead of a branch.
+
+	* m32r.md (b{eq,ne,lt,le,gt,ge,ltu,leu,gtu,geu}): Update
+	gen_compare calls.
+	(s{eq,ne,lt,le,gt,ge,ltu,leu,gtu,geu}): Recode to present the
+	operation as a distinct RTL until splitting so that the
+	optimization passes generate better code.
+	(abs{df,sf}2): Define, so that we can make fabs(-0.0) return 0.0.
+	
+Wed Jun 17 15:12:00 1998  Catherine Moore  <clm@cygnus.com>
+
+	* reload1.c (spill_hard_reg):  Check mode of register when
+	spilling from scratch_list.
+
+Wed Jun 17 14:55:50 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.h (GO_IF_LEGITIMATE_ADDRESS): Disallow REG+REG 
+	addressing when one register is the frame pointer or stack
+	pointer.  Disallow REG+CONST addressing in HI mode.
+
+	* config/arm/arm.h (CANONICALIZE_COMPARISON): Preserve OP1.
+	
+Tue Jun 16 20:50:37 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.c (m32r_adjust_{cost,priority}): New functions to adjust
+	scheduler cost and priority information.
+	(direct_return): Don't test -mdebug any more.
+
+	* m32r.h (m32r_adjust_{cost,priority}): Declare.
+	(m32r_address_cost): Correctly spell function in prototype.
+	(ADJUST_{COST,PRIORITY}): Define to call the appropriate function.
+
+Tue Jun 16 17:36:35 1998  Dave Brolley  <brolley@cygnus.com>
+
+	* cpplib.h (__GCC_CPPLIB__): Add header guard.
+	* cpplib.c (open_include_file_name): New function.
+	(open_include_file): Call open_include_file_name instead of open.
+Fri Jun 12 00:03:23 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (OPTIMIZATION_OPTIONS): Turn on -fregmove if -O1.  If
+	-Os, turn on -fomit-frame-pointer and -fno-strength-reduce.
+	(CAN_DEBUG_WITHOUT_FP): No longer define, so we don't confuse the
+	debugger.
+	(TARGET_FLAGS): Remove -mold-compare support.
+	
+	* m32r.c (gen_compare): Rewrite to be more general.  Take an
+	extra argument to give the output register for scc operations or
+	the label to jump to for bcc operations.  Fix typo for LEU & GTU
+	of constants.
+	(internal_reg_or_{cmp_int16,uint16}_operand): Same as the function
+	without the internal_ prefix, except mode argument is an enum.
+	(internal_reg_or_zero_operand): Ditto.
+	
+	* m32r.h (gen_compare): Add new argument to prototype.
+	(PRESERVE_DEATH_INFO_REGNO_P):  Delete, no longer needed after
+	June 11 regmove.c change.
+
+	* m32r.md (cmp_eqsi_insn): Make a define_expand instead of a
+	define_insn.
+	(cmp_ne_small_const_insn): Delete, no longer used.
+	(b{eq,ne,lt,le,gt,ge,ltu,leu,gtu,geu}): Rework for gen_compare
+	changes.
+	(s{eq,ne,lt,le,gt,ge,ltu,leu,gtu,geu}): Define patterns.
+	(movsicc): Delete, no longer used.
+	(peephole): Delete, no longer needed after June 11 regmove.c
+	change.
+
+Tue Jun  9 14:13:37 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/t-v850 (TCFLAGS): Add assembler options to catch
+	signed and unsigned overflows.
+
+	* config/v850/lib1funcs.asm (__callt_save_interrupt): Use 'addi
+	16,sp,sp' instead of 'add 16,sp'.  Patch cpurtesy of: Biomedin
+	<glctr@abc.it> 
+
+Thu Jun  4 15:14:04 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* jump.c (duplicate_loop_exit_test): Remove May 19th code not
+	duplicating the loop exit test at the bottom, but keep the part
+	about testing LOOP_TEST_THRESHOLD.
+
+	* m32r.h (LOOP_TEST_THRESHOLD): If -Os, use 2 instead of 30.
+	(PREDICATE_CODES): Add extend_operand.
+	(extend_operand): Declare.
+	
+	* m32r.c (extend_operand): New function to return true if an
+	operand can be used in a sign/zero_extend operation.
+
+	* m32r.md (zero_extend*): Use extend_operand.
+	(sign_extend{qisi,qihi,hisi}2): Rewrite so sign_extend is
+	available until after reload is done.
+	
+Tue Jun  2 00:54:38 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* toplev.c (rest_of_compilation): Only perform block merging for
+	-O2 and above.
+
+Mon Jun  1 03:44:03 1998  Catherine Moore <clm@cygnus.com>
+
+	* config/sh/sh.h (MAX_OFILE_ALIGNMENT): Define.
+
+	* varasm.c (assemble_variable): Augment alignment warning.
+
+Sun May 31 01:02:05 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c (process_command): Use concat instead of effectively
+	open-coding it.
+
+Sun May 31 10:37:49 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.c (gen_compare): Fix last change to swap GT/GTU/LE/LEU
+	arguments if both are registers.  Don't convert GTU/LEU of a
+	negative value into GEU/LTU.
+
+Fri May 29 14:31:39 1998  Ken Raeburn	<raeburn@cygnus.com>
+			  Jeff Law	<law@cygnus.com>
+
+	(mulsi_r5400, macc_r5400): Delete patterns.
+	(muls_r5400, msac_r5400, muls_r5400_di): Rewrite.
+	(macc_r5400_di, msac_r5400_di): Likewise.
+	(xmulsi3_highpart_5400): Likewise.
+	(xmulsi3_neg_highpart_5400): Likewise.
+
+Fri May 29 13:36:17 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.c (gen_compare): Cmpui takes a signed 16 bit value, not
+	unsigned.
+	* m32r.md (cmp_ltusi_insn): Ditto.
+
+	* m32r.c (gen_compare): If the first compare value is not a
+	register, force it into a register.  If the second compare value
+	is not a register or a constant integer, force it into a
+	register.
+
+	* m32r.md (cmpsi): Only allow registers or signed 16 bit values
+	for the second argument.
+	
+Thu May 28 13:47:18 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.c (gen_compare): Convert LE/LEU/GT/GTU of a constant into
+	LT/LTU/GE/GEU with the constant+1.
+
+Wed May 27 09:04:36 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* config/mips/mips.h (ASM_OUTPUT_ALIGN): Remove trailing semi-colon.
+
+Tue May 26 20:38:27 1998  Stan Cox  <scox@equinox.cygnus.com>
+
+	* config/sparc/sp86x-elf.h (TARGET_LITTLE_ENDIAN_DATA): New.
+	(INIT_SECTION_ASM_OP): Undef so __main constructor invocation is used.
+
+Tue May 26 14:48:50 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.c (v850_output_aligned_bss): use
+	ASM_DECALRE_OBJECT_NAME if it is available.
+
+Tue May 26 09:28:07 1998  Catherine Moore <clm@cygnus.com>
+
+       * config/sparc/lb1spc.asm (.urem, .rem) Replace routines.
+
+Fri May 22 23:46:37 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* gcc.c (make_relative_prefix): Call obstack_1grow with '\0'.
+
+Thu May 21 14:37:15 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/README-interworking:  Add note about ignoring linker
+	warning message when --support-old-code is used. 
+
+Tue May 19 18:28:47 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* config/generic/xm-generic (NO_STAB_H): Delete reference.
+	* config/d30v/xm-d30v.h (NO_STAB_H): Delete reference.
+
+Tue May 19 15:38:48 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* stmt.c (expand_end_loop): Instead of using a hard-coded 30 for
+	the number of insns, use LOOP_TEST_THRESHOLD.
+
+	* jump.c (duplicate_loop_exit_test): Use LOOP_TEST_THRESHOLD for
+	decided how many instructions to duplicate.  If optimizing for
+	space, don't duplicate the loop exit test at the top.
+
+	* expr.h (LOOP_TEST_THRESHOLD): Define if not defined.
+
+	* tm.texi (LOOP_TEST_THRESHOLD): Document.
+
+Mon May 18 15:28:26 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/lib1funcs.asm: Add .text pseudo op to start of
+	___udivsi3. 
+	
+	* config/v850/lib1funcs.asm: Fix .size pseudo ops to use three
+	underscores for the prefixes to the names of the maths functions. 
+
+	* dbxout.c (dbxout_parms): Revert to using DECL_ARG_TYPE for
+	parameters passed in memory.  Add a comment explaining why.
+
+Mon May 18 00:21:53 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* c-lex.c (check_newline): Remove old CYGNUS LOCAL code that
+	is no longer needed.
+
+Sun May 17 20:57:01 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (PREDICATE_CODES): Add seth_add3_operand, int8_operand,
+	and uint16_operand.
+	(int8_operand): Add declaration.
+
+	* m32r.c (int8_operand): Return true if value is a signed 8 bit
+	constant int.
+	(m32r_expand_prologue): Remove duplicate setting of gmask.
+	(direct_return): Return true if we have no stack to allow jmp lr
+	to be used as a return.
+
+	* m32r.md ({and,ior,xor}si3): If -Os and we have a 8 bit immediate
+	constant and different registers, emit two short instructions
+	instead of a long instruction.  Also don't accept integer
+	arguments greater than 16 bits initially, to give those values a
+	chance at CSE.
+	(return): Add return pattern.
+
+Fri May 15 19:30:29 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.md (mov{si,sf}_insn): Correct attributes for load/store
+	with inc/dec.
+
+Fri May 15 14:55:45 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* dbxout.c (dbxout_parms): Use TREE_ARG to compute the type of a
+	function parameter passed in memory.
+
+Thu May 14 14:37:26 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/README-interworking: Document dlltool support for
+	interworking.
+	
+	* config/arm/lib1thumb.asm: Add labels to help disassembler
+	distinguish between ARM and Thumb code.
+	Fix _interwork_call_via_ip.
+	* config/arm/lib1funcs.asm: Ditto.
+
+Thu May 14 13:27:07 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* global.c (undo_live_range): Use PUT_REG_NOTE_KIND instead of
+	REG_NOTE_KIND.
+
+Wed May 13 22:45:53 1998  Michael Meissner  <meissner@cygnus.com>
+			  Jeff Law <law@cygnus.com.
+
+	* Makefile.in (OBJS): Add range.o
+	(clean rules): Delete *.range.
+	(toplev.o): Depend on range.h.
+	(dbxout.o, global.o): Likewise.
+	(final.o): Depend on bitmap.h, range.h, except.h, and function.h.
+	(range.o): Add dependencies.
+	* range.c, range.h: New files.
+	* dbxout.c: Include "range.h".
+	(range_current, range_max_number_for_parms): New static variables.
+	(range_max_number): New global variable.
+	(dbxout_symbol_name): New argument "live_range_p".  All callers
+	changed.
+	(dbxout_live_range_alias): New function.
+	(dbxout_live_range_parms): Likewise.
+	(dbxout_symbol_location): Call dbxout_live_range_alias.
+	(dbxout_symbol_name): If live_range_p, then output LRS
+	debug symbol extensions.
+	(dbxout_parms): Handle LRS optimizations.
+	(dbxout_really_begin_function): Keep track of range_max_number at
+	function entry (so we can properly output ranges for parameters).
+	(dbxout_function): Call dbxout_live_range_parms.
+	* final.c: Include "function.h", "range.h", "bitmap.h" and "obstack.h".
+	(block_nodes): New global.
+	(rtl_obstack, range_max_number): Declare.
+	(struct block_seq): New structure for blocks.
+	(pending_blocks): Now a struct block_seq *.
+	(init_final): Fix allocation of pending_blocks.
+	(final): Call identify_blocks to get the block nodes for the current
+	function.  When finished, free space allocated for block_nodes.
+	(final_scan_insn): Handle LRS notes.  Various fixes for change in
+	pending_blocks structure.
+	* flags.h (flag_live_range): Declare new variable.
+	(flag_live_range_gdb, flag_live_range_scope): Likewise.
+	* function.c (reorder_blocks): Revamp to track blocks created by LRS
+	optimizations.
+	* global.c: Inlcude obstack.h and range.h.
+	(global_obstack): New obstack for use in global allocation.
+	(reg_live_ranges, save_reg_renumber): New static variables.
+	(CLEAR_CONFLICT): Define.
+	(record_conflits): Now accepts int* as first argument.  All callers
+	changed.
+	(undo_live_range, global_init): New functions.
+	(global_alloc): Split into two functions, global_init and global_alloc.
+	Try to allocate LRS copies first, then fall back to normal allocation
+	order.  If some LRS copies did not get hard regs, then undo some live
+	ranges.  Free the global_obstack when finished.
+	(global_init): Allow multiple calls.  Only allocate space on the first
+	call.  Allocate stuff on the global obstack instead of with alloca.
+	(allocno_compare): Handle LRS copies.
+	(global_conflicts): block_start_allocnos is an int * now.  Allocate
+	space on the global obstack.  Remove conflicts between LRS copies from
+	LRS base registers.
+	(find_reg): For an LRS copy, try to allocate it in the same reg as
+	another LRS copy.
+	* output.h: Declare block_nodes.
+	* regclass.c ({pref,alt}class_buffer): New statics to hold buffers
+	allocate_reg_info allocates for {pref,alt}class_buffer.
+	(regclass): Use {pref,alt}class_buffer to initialize
+	{pref,alt}class.
+	(allocate_reg_info): Allocate buffers for the preferred and alter
+	register class information.
+	* regs.h (struct reg_n_info): Add fields for LRS info.
+	(REG_N_RANGE_CANDIDATE, REG_N_RANGE_COPY_P): New accessor macros.
+	* toplev.c: Include range.h.
+	(live_range_dump, flag_live_range): New variables.
+	(flag_live_range_gdb, flag_live_range_scope): Likewise.
+	(live_range_time): Likewise.
+	(f_options): Add LRS options.
+	(compile_file): Call init_live_range.  Clean the .range dump file
+	if necessary.  Print time spent in LRS.
+	(rest_of_compilation): Optimize live ranges if requested.  Free basic
+	block info and regsets when finished with the current function.  Also
+	call init_live_range to reinitialize LRS.
+	(main): Perform LRS dumps is requested.
+
+Tue May 12 23:23:25 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.c (move_src_operand): Reject loads with PRE_INC or PRE_DEC.
+	(move_dest_operand): Reject stores with POST_INC.
+	(m32r_print_operand): Change abort calls into fatal_insn calls.
+	(m32r_print_operand_address): Ditto.
+
+	* m32r.h (EXTRA_CONSTRAINT): 'S' is now for stores with PRE_INC or
+	PRE_DEC.  'U' is now for loads with POST_INC.
+	(HAVE_PRE_{INC,DEC}REMENT): Define.
+	(HAVE_POST_INCREMENT): Ditto.
+	(PUSH_POP_P): Delete, no longer used.
+	(LOAD_POSTINC_P): Recognize loads with POST_INC.
+	(STORE_PREINC_PREDEC_P): Recognize stores with PRE_{INC,DEC}.
+	(GO_IF_LEGITIMATE_ADDRESS): Recognize loads with POST_INC, and
+	stores with PRE_{INC,DEC}.
+
+	* m32r.md (movsi_insn): Separate loads with POST_INC from stores
+	with PRE_{DEC,INC}.  Emit push/pop if pushing/poping stack
+	pointer.
+	(movsf_insn): Allow memory loads to have POST_INC, and stores to
+	have PRE_{DEC,INC}.
+
+Mon May 11 11:34:17 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* egcs -> gcc merge.  See ChangeLog.egcs & ChangeLog.12 for
+	details.
+
+Thu May  7 16:20:59 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* config/mips/elf.h (ASM_OUTPUT_DEF,ASM_WEAKEN_LABEL,
+	ASM_OUTPUT_WEAK_ALIAS): Define.
+	* config/mips/elf64.h: Same.
+	* config/mips/r3900.h (ASM_OUTPUT_DEF,SUPPORTS_WEAK,
+	ASM_WEAKEN_LABEL): Removed.
+
+Tue May  5 14:28:53 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* elfb4100.h, elfb4300.h, elfb4320.h, elfb4900.h, elfb5000.h,
+	elfl4100.h, elfl4300.h, elfl4320.h, elfl4900.h, elfl5000.h
+	(MULTILIB_DEFAULTS): Move definition after elf64.h include.
+Thu Apr 30 16:07:02 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.h (ASM_OUTPUT_ALIGNED_BSS): Call v850_output_aligned_bss().
+	* config/v850/v850.c (v850_output_aligned_bss): New
+	function. Preserve alignment information when emitting symbols
+	into the bss section.
+	(v850_output_bss): Function removed.
+
+Wed Apr 29 16:18:40 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (ASM_OUTPUT_SOURCE_LINE): Use .debugsym instead of
+	creating a label if -Os to prevent extra NOPs.
+
+Tue Apr 28 11:10:10 1998  Mark Alexander  <marka@cygnus.com>
+
+	* config/sparc/t-sp86x (MULTILIB_OPTIONS): Remove big-endian.
+	(MULTILIB_DIRNAMES): Add "little" for brevity.
+
+Mon Apr 27 17:07:09 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.h (GO_IF_LEGITIMATE_ADDRESS): Use
+	frame_pointer_rtx rather than FRAME_POINTER_REGNUM.
+
+Sun Apr 26 17:04:11 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.c (conditional_move_operand): Silence a debug message.
+
+Fri Apr 24 06:46:40 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.h (GO_IF_LEGITIMATE_ADDRESS): Disallow frame
+	pointer as second register in REG+REG pair.
+
+Thu Apr 23 12:13:36 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.c (expand_prologue): Only generate callt using
+	insns if TARGET_DISABLE_CALLT is not defined.
+
+Wed Apr 22 17:53:04 1998  Stan Cox  <scox@equinox.cygnus.com>
+
+	* sparc.c (sparc_override_options): New option name -mcpu=sparclite86x.
+
+Wed Apr 22 17:23:07 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (TARGET_M32R): New macro.
+	(PREDICATE_CODES): Rearrange somewhat, add small_insn/long_insn.
+
+	* m32r.c ({small,long}_insn): New predicates.
+
+	* m32r.md (insn_size): New attribute.
+	({,rev_}branch_insn): Add .s qualifier to branches believed to be
+	short.
+	(m32r): New attribute.
+	(small_sequence,long_group): Add initial framework for instruction
+	grouping.
+
+	* m32r.h (ASM_SPEC): Add -O to the assembler arguments if we are
+	compiling for the m32rx and optimizing.
+
+	* m32r.md (m32rx{,_pipeline}): New attributes.
+	(small_parallel): Add initial framework for instruction grouping.
+	
+	* rtl.def (GROUP_{PARALLEL,SEQUENCE}: Add new insns.
+
+Mon Apr 20 13:31:17 1998  Dave Brolley  <brolley@cygnus.com>
+
+	* stmt.c (mark_seen_cases): Needs to be external linkage for Chill.
+
+Mon Apr 20 07:37:49 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* i386.c: Include expr.h to get the change_address prototype
+	declared.
+
+Sat Apr 18 23:37:59 1998  Stan Cox  <scox@equinox.cygnus.com>
+
+	* configure.in: Added sparc86x.
+	* configure: Regenerate.
+	
+	* sparc.h (TARGET_CPU_{hypersparc,sparc86x},
+	PROCESSOR_{HYPERSPARC,SPARC86X}): Added for sparc86x/hypersparc.  
+	(ADJUST_COST): Call hypersparc_adjust_cost.
+	
+	* sparc.c (hypersparc_adjust_cost): Added for sparc86x/hypersparc.
+
+	* sparc.md (define_function_unit): Added for sparc86x/hypersparc.
+	(define_attr "cpu"): Added hypersparc/sparc86x.
+	
+	* (t-sp86x, sp86x-elf.h, sp86x-aout.h: Added for sparc86x.
+	
+Tue Apr 14 14:10:43 1998  Dave Brolley  <brolley@cygnus.com>
+
+	* toplev.c: Call init_parse using new interface.
+
+	* c-lex.c (init_parse): Now returns char* containing the filename.
+Mon Apr 13 11:31:29 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* m32r.h (HAIFA_P): Define as 1/0 depending on whether the Haifa
+	scheduler was selected.
+	(ISSUE_RATE): Define as 2.
+
+	* configure.in (enable_haifa): Switch m32r to Haifa by default.
+	* configure: Regenerate.
+
+1998-04-10  Ken Raeburn  <raeburn@cygnus.com>
+
+	* config/arm/thumb.h, config/d10v/d10v.h (MEMORY_MOVE_COST):
+	Updated to show extra args, currently ignored.  See my 16-Mar
+	change.
+	* config/d30v/d30v.h (MEMORY_MOVE_COST): Likewise.
+
+Fri Apr 10 15:38:21 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* config/i386/i386elf.h (ENDFILE_SPEC, STARTFILE_SPEC): Delete.
+	* configure.in (i[34567]86-*-elf*): Add ${xm_file} and xm-svr4.h to
+	xm_file list.
+
+Fri Apr 10 10:42:42 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Add trailing newline.
+
+	* rtl.c (read_skip_spaces): Prevent infinite loops upon
+	encountering unterminated comments.
+
+	* config/arm/aout.c:      Add CYGNUS LOCAL markers.
+	* config/arm/riscix.h:    Add CYGNUS LOCAL markers.
+	* config/arm/riscix1-1.h: Add CYGNUS LOCAL markers.
+	* config/arm/semiaof.h:   Add CYGNUS LOCAL markers.
+	* config/arm/t-linux:     Add CYGNUS LOCAL markers.
+	* config/arm/thumb.h:     Remove CYGNUS LOCAL markers.
+	* config/arm/thumb.c:     Remove CYGNUS LOCAL markers.
+
+Thu Apr  9 16:26:53 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Add CYGNUS LOCAL markers.
+	* config/m32r/m32r.c:  Add CYGNUS LOCAL markers.
+	* config/m32r/m32r.h:  Add CYGNUS LOCAL markers.
+	* config/m32r/t-m32r:  Add CYGNUS LOCAL markers.
+
+	* config/arm/README-interworking: Added note about DLLs not
+	working.
+
+	* config/arm/arm.c:  Add CYGNUS LOCAL markers.
+	* config/arm/arm.h:  Add CYGNUS LOCAL markers.
+	* config/arm/arm.md: Add CYGNUS LOCAL markers.
+	* config/arm/coff.h: Add CYGNUS LOCAL markers.
+	* config/arm/semi.h: Add CYGNUS LOCAL markers.
+	* config/arm/t-bare: Add CYGNUS LOCAL markers.
+	* config/arm/lib1funcs.asm: Add CYGNUS LOCAL markers.
+
+Thu Apr  9 12:57:05 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* tree.def (EXPR_WITH_FILE_LOCATION): New tree node definition.
+ 	* tree.h (EXPR_WFL_{NODE,FILENAME,FILENAME_NODE,LINENO,
+ 	COLNO,LINECOL,SET_LINECOL,EMIT_LINE_NOTE}): New macros.
+ 	(build_expr_wfl): New prototype declaration.
+ 	* tree.c (build_expr_wfl): New function, to build
+ 	EXPR_WITH_FILE_LOCATION nodes.
+ 	(copy_node): Don't zero TREE_CHAIN if copying a
+ 	EXPR_WITH_FILE_LOCATION node.
+ 	* print-tree.c (print_node): Handle EXPR_WITH_FILE_LOCATION.
+ 	* expr.c (expand_expr): Handle EXPR_WITH_FILE_LOCATION.
+
+Thu Apr  9 12:14:40 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* loop.c (loop_optimize): Call init_alias_analysis immediately after
+	reg_scan.
+
+	* configure.in: Kill mpw.
+	* config.sub: Likewise.
+
+Wed Apr  8 15:08:57 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in m68010-adobe-scout): Delete obsolete local config.
+	(m68k-apollo-sysv, m68k-tandem-*, m68*-netx,vxworks*): Likewise.
+	(mips-ncd-elf*, powerpc-*-netware*): Likewise.
+	* config.sub: Kill "scout" references.
+
+	* configure.in: Completely disable objc unless --enable-objc is
+	specified at configure time.
+	* objc/Make-lang.in: Remove CYGNUS LOCAL hack.
+
+	* configure.in: Reorganize local configurations to make
+	merging with egcs easier.
+
+	* gcc.c (process_command): putenv only takes a single argument.
+
+Mon Apr  6 07:17:52 1998  Catherine Moore  <clm@cygnus.com>
+
+	* combine.c (can_combine_p):  Include successor in volatile test.
+
+Fri Apr  3 15:59:35 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcse.c (gcse_main): If we split any edges, then run jump
+	optimizations after gcse.
+
+Wed Apr  1 17:06:19 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.h: Add super interworking support.
+	* config/arm/thumb.c: Add super interworking support.
+	* config/arm/thumb.md: Add super interworking support.
+	* config/arm/tpe.h: Add super interworking support.
+	* config/arm/lib1funcs.asm: Add interworking support.
+	* config/arm/lib1thumb.asm: Add super interworking support.
+	* config/arm/t-pe: Add super interworking support.
+	* config/arm/t-semi: Add interworking support.
+	* config/arm/t-thumb: Add interworking support.
+	* config/arm/t-pe-thumb: Add super interworking support.
+	* config/arm/README-interworking: New file.
+
+Mon Mar 30 09:22:16 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* mips.md (rotrsi3): Use GEN_INT instead of gen_rtx (CONST_INT).
+	(rotrdi3): Likewise.
+
+Mon Mar 30 12:27:21 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* invoke.texi (ARM Options): Removed spurious @end table marker.
+
+	* config/m32r/m32r.h (EXTRA_CONSTRAINT): Implement 'S' constraint
+	to perfoirm the equivalent of a negated 'I' constraint.
+
+	* config/m32r/m32r.md (cmp_ne_small_const_insn): Use 'S'
+	constriant rather than 'I' since the value is negated.
+
+Sat Mar 28 13:03:22 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* invoke.texi: Document more ARM and Thumb options.
+
+Fri Mar 27 16:15:29 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* gcc.c (make_relative_prefix): If argv[0] does not contain a
+	directory separator, look up the name in the PATH environment
+	variable.
+
+Wed Mar 25 13:50:16 1998  Dave Brolley  <brolley@cygnus.com>
+
+	* cccp.c: Restore chill support.
+
+Tue Mar 24 10:44:11 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* Makefile.in (gcov$(exeext)): Support .exe extension to gcov.
+
+	* collect2.c (find_a_file): Add debugging.
+	(find_a_file): Test for win32 style absolute paths if
+	DIR_SERPARATOR is defined.
+	(prefix_from_string): Add debugging.
+	(main): Test for debug command line switch at start of program
+	execution. 
+	(main): Use GET_ENVIRONMENT rather than getenv().
+	
+Sun Mar 22 16:15:45 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/tpe.h (ASM_DECLARE_FUNCTION_NAME): Include
+	.thumb_func directive in function header.
+
+Fri Mar 20 09:32:46 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* objc/Make-lang.in: Apply patch from Geoff Noer (noer@cygnus.com)
+	to allow cygwin32 native toolchain builds via canadian crosses.
+
+	* objc/Makefile.in: Apply patch from Geoff Noer (noer@cygnus.com)
+	to allow cygwin32 native toolchain builds via canadian crosses.
+
+	* Makefile.in: Apply patch from Geoff Noer (noer@cygnus.com) to
+	allow cygwin32 native toolchain builds via canadian crosses.
+
+	* config/i386/xm-cygwin32.h (PATH_SEPARATOR): Set to a semi-colon.
+
+Thu Mar 19 13:45:28 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/i386/xm-cygwin32.h (GET_ENVIRONMENT): Patch resubmitted,
+	since it appears to have been lost in the shuffle....
+
+	* config/arm/thumb.c (arm_valid_machine_decl_attribute): Copied
+	from arm.c for thumb-pe builds.
+
+	* config/arm/t-pe-thumb: New file: makefile fragement for thumb-pe
+	build.
+
+	* config/arm/tpe.h: New file: PE support for thumb-pe build.
+
+Wed Mar 18 11:21:16 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/i386/xm-cygwin32.h (GET_ENVIRONMENT): Do not call
+	cygwin32_posix_path_list_p with a NULL or empty path.
+
+Wed Mar 18 09:33:13 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/thumb.c (arm_valid_machine_decl_attribute): New
+	function for thumb-pe support.
+
+	* configure.in: Add thumb-pe target.
+
+	* configure: Add thumb-pe target.
+
+	* config.sub (maybe_os): Add thumb-pe target.
+
+Mon Mar 16 16:24:45 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* gcc.c (make_relative_prefix): If directory is the same as
+	expected, or there are no directory separators, don't create a
+	relative pathname.
+
+Fri Mar 13 17:55:04 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* i386/cygwin32.h    (GET_ENVIRONMENT): Delete from here.
+	* i386/xm-cygwin32.h (GET_ENVIRONMENT): Move to here.  
+	Initialize variable if not a posix style pathname.
+	
+Fri Mar 13 17:54:04 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* gcc.c (DIR_UP): If not defined, define as "..".
+	(standard_bindir_prefix): New static, holds target location to
+	install binaries.
+	(split_directories): New function to split a filename into
+	component directories.
+	(free_split_directories): New function, release memory allocated
+	by split_directories.
+	(make_relative_prefix): New function, make a relative pathname if
+	the compiler is not in the expected location.
+	(process_command): Use GET_ENVIRONMENT to read GCC_EXEC_PREFIX.
+	If GCC_EXEC_PREFIX was not specified, see if we can figure out an
+	appropriate prefix from argv[0].
+
+	* Makefile.in (gcc.o): Define STANDARD_BINDIR_PREFIX.
+
+Fri Mar 13 11:49:49 1998  Stan Cox  <scox@equinox.cygnus.com>
+
+	* config/i386/cygwin32.h (GET_ENVIRONMENT): Defined to allow win32
+	style environment paths.
+
+Thu Mar 12 16:22:03 1998  Stan Cox  <scox@cygnus.com>
+
+	* sparc/liteelf.h (MULDI3,DIVDI3,UDIVDI3,MODDI3,UMODDI3)_LIBCALL:
+	Undefine solaris library routines.
+	
+Thu Mar 12 13:21:38 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.md (movsi, movhi, movhi_insn_arch4,
+	movho_insn_littleend, movhi_insn_bigend): Use
+	ok_integer_or_other().
+	(movhi_insn_arch4): Swap order of 2nd and 3rd alternatives to
+	avoid problem in reload.
+
+	* config/arm/arm.c: (find_barrier_insn): Return barrier insn, if
+	found, rather than insn after the barrier.
+	(ok_integer_of_other): New function, to avoid duplication in md
+	file. 
+
+	* config/arm/arm.h: Add prototype for ok_integer_or_other().
+
+Wed Mar 11 15:21:52 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* haifa-sched.c (schedule_insns): Remove debug statement.
+
+Wed Mar 11 15:44:54 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips/mips.h (MASK_DEBUG_E): Redefine to zero. 
+
+Tue Mar 10 12:20:57 1998  Stan Cox  <scox@rtl.cygnus.com>
+
+	* sparc/liteelf.h (PREFERRED_DEBUGGING_TYPE): Make dwarf2
+	the default debugging type.
+
+Mon Mar  9 16:29:34 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* expr.c (expand_builtin): Add __builtin_expect code back in.
+	* rs6000.c (ccr_bit,print_operand): Ditto.
+
+Mon Mar  9 14:24:27 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* t-sh (MULTILIB_OPTIONS): Add m4-single-only.
+	(MULTILIB_MATCHES): Remove m3e=m4-single-only.
+
+Sun Mar  8 23:46:29 1998  Stan Cox  <scox@equinox.cygnus.com>
+
+	* configure, configure.in (sparclite-*-elf*): Added.
+	* sparc/liteelf.h: New file.
+
+Sat Mar  7 13:59:47 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d10v.h (LOOP_ALIGN): Fix comment delimiter.
+
+Fri Mar  6 21:28:45 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d10v.h (ASM_OUTPUT_ADDR_DIFF_ELT): New argument BODY.
+	* arm/thumb.h, i386/i386elf.h, m68k/st2000.h: Likewise.
+	* d30v.h: Likewise.
+
+Thu Mar  5 09:09:08 1998  Catherine Moore <clm@cygnus.com>
+       * config/v850/v850.h: Add option -mdisable-callt.
+       * config/v850/v850.md: Don't generate callt instructions if
+       -mdisable-callt has been specified.
+
+Thu Mar  5 09:09:08 1998  Catherine Moore <clm@cygnus.com>
+
+	* config/v850/lib1funcs.asm (___udivsi3):  Don't use r5.
+	* config/v850/t-v850: Add -mno-app-regs to target build flags.
+	* config/v850/v850.h:  Change STATIC_CHAIN_REGNUM from 5 to 20.
+	Add option -mno-app-regs.  Add CONDITIONAL_REGISTER_USAGE macro.
+
+Thu Mar  5 14:39:45 1998  Fred Fish  <fnf@cygnus.com>
+
+	* config/d30v/d30v.h: Fix prematurely terminated comment.
+
+Tue Mar  3 09:12:04 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* toplev.c: Do not generate a <name>.dbr file when dumping RTL
+	unless DELAY_SLOTS is defined.
+
+Mon Mar  2 20:06:04 1998  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d10v.h (ASM_OUTPUT_LOOP_ALIGN, ASM_OUTPUT_ALIGN_CODE):
+	replace with LOOP_ALIGN, ALIGN_LABEL_AFTER_BARRIER.
+	* d30v.h: Likewise.
+
+Wed Feb 25 10:02:19 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.md (movsfcc, movdfcc): Cope with constants that
+	cannot be placed into instructions.  Patch supplied by Richard
+	Earnshaw. 
+
+Fri Feb 20 15:42:56 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips/t-vr4100 (MULTILIB_OPTIONS, MULTILIB_DIRNAMES): 
+	Add mno-mips16 and mips16.
+	* mips/elfb4100.h, mips/elfl4100.h (MULTILIB_DEFAULTS) :
+ 	Add "mno-mips16".
+
+Tue Feb 17 16:41:43 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Fix sanitization.
+
+	* config/m32r/m32r.c (gen_compare): Fix sanitization.
+Fri Feb 13 14:55:13 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Add peephole optimisation to cope with
+	PR14189, pending a better solution.
+
+	* config/m32r/m32r.h (PRESERVE_DEATH_INFO_REGNO_P): Define in
+	order to allow peephole optimisation to work.
+
+Fri Feb 13 02:57:19 1998  J"orn Rennecke  <amylaar@cygnus.com>
+
+	* d10v.h (DEFAULT_PCC_STRUCT_RETURN) Define as 0.
+
+Wed Feb 11 09:07:22 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.h (ASM_SPEC): Pass on
+	--nmo-warn-explicit-parallel-conflicts to the assembler.
+Mon Feb  9 09:53:41 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.c (v850_output_local): Call
+	ASM_OUTPUT_ALIGNED_DECL_COMMON rather than ASM_OUTPUT_DECL_LOCAL
+	(which is not defined).
+
+	* varasm.c (assemble_variable): Ditto.
+
+Fri Feb  6 14:55:28 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850ea.h: Remove multilibing and add -mUS-bit-set
+	command line option.
+
+	* config/v850/v850e.h: Remove multilibing.
+
+	* config/v850/v850.c (ep_memory_offset): Support new command line
+	options -msmall-sld and -mUS-bit-set to allow fine tuning of the
+	SLD.[BH] offsets.
+	* config/v850/v850.h: Ditto. 
+
+	* config/v850/t-v850: Remove multilibing and replace with single,
+	universal build using -mv850 and -msmall-sld command line options.
+
+
+Fri Feb  6 09:19:12 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips/elfb4100.h (DWARF2_DEBUGGING_INFO,PREFERRED_DEBUGGING_TYPE,
+	SUBTARGET_ASM_DEBUGGING_SPEC): Define.
+	* mips/elfl4100.h (DWARF2_DEBUGGING_INFO,PREFERRED_DEBUGGING_TYPE,
+	SUBTARGET_ASM_DEBUGGING_SPEC): Same.
+
+Fri Feb  6 02:53:28 1998  J"orn Rennecke  <amylaar@cygnus.com>
+
+	* d10v.h (MUST_PASS_IN_STACK): Define.
+
+	* d10v/libgcc1.asm (__cmpdi): Fix bug in last change.
+
+	* d10v.md (movhi): Don't call force_reg while reloading.
+	(movsi): Handle case when reload asks us to use an uneven reg pair.
+
+	Undo this change:
+	  * va-d10v.h (__va_start_common): Add DELTA argument to subtract
+	  from register number.
+	  (va_start): Add DELTA argument to __va_start_common call, stdarg
+	  passes 0, varargs needs to ignore last argument.
+
+Tue Feb  3 15:45:55 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* mips/elfb4100.h (SUBTARGET_CPP_SPEC): Insure that __mips64
+	is defined.
+	* mips/elfl4100.h (SUBTARGET_CPP_SPEC): Same.
+
+Sat Jan 31 02:18:52 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcse.c (gcse_main): Fix minor typo in critial edge splitting code.
+	(pre_insert_insn): Correctly handle inserting code before a switch
+	table.
+
+Thu Jan 29 18:29:30 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config/d30v/d30v.h (LINK_SPEC): Never specify -h.
+
+Wed Jan 28 16:43:49 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.c zero_and_one, emit_cond_move): Add support
+	for MVFC instruction.
+
+	* config/m32r/m32r.h: Ditto. 
+
+	* config/m32r/m32r.md: Ditto.
+
+Mon Jan 26 11:20:55 1998  Gavin Koch  <gavin@cygnus.com>
+
+	* configure.in (mips64vr4100-*-elf*,mips64vr4100el-*-elf*):
+	Add abi64.h to the tm_file list.
+	* configure: Rebuild.
+	* mips/elfb4100.h (MIPS_ABI_DEFAULT,SUBTARGET_CPP_SIZE_SPEC,
+	SUBTARGET_CPP_SPEC): Define.
+	* mips/elfl4100.h (MIPS_ABI_DEFAULT,SUBTARGET_CPP_SIZE_SPEC,
+	SUBTARGET_CPP_SPEC): Define.
+
+Sun Jan 25 21:46:07 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* va-d10v.h (__va_start_common): Add DELTA argument to subtract
+	from register number.
+	(va_start): Add DELTA argument to __va_start_common call, stdarg
+	passes 0, varargs needs to ignore last argument.
+
+	* d10v.c (emit_move_word): Use %. to emit code to access the 0
+	register, not hardcoded r0.
+
+	* d10v.md (movqi_internal): Use %. to emit code to access the 0
+	register, not hardcoded r0.
+
+Fri Jan 23 09:39:36 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* toplev.c: Add -dM command line option to dump RTL after the
+	machine dependent reorganisation pass, if there is one.
+	Reorganise RTL dump code, so that only one file handle is
+	needed. 
+
+	* configure.in: Fix indentation of CYGNUS LOCAL markers.
+
+	* configure: Add support for thumb-coff.
+
+	* toplev.c (lang_options): Add -Wunknown-pragmas and
+	-Wno-unknown-pragmas. 
+
+Fri Jan 23 11:20:19 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* d10v.c (override_options): Use GPR_EVEN_P.
+	(override_options): Change to new ABI where args are in r0..r3,
+	r14 is zero register.  Change names of register class to be
+	ARG{0,1,2,3}_REGS, not R{2,3,4,5}_REGS, and RETURN_REGS instead of
+	R13_REGS.
+	(print_operand{,_memory_reference}): Ditto.
+	(d10v_stack_info): Ditto.
+	(function_{pro,epi}logue): Ditto.
+	(emit_move_4words): Make refers_to_regno_p be type correct.
+
+	* d10v.h (ARG_{FIRST,LAST}): Change to new ABI where args are in
+	r0..r3, r14 is zero register.  Change names of register class to
+	be ARG{0,1,2,3}_REGS, not R{2,3,4,5}_REGS, and RETURN_REGS instead
+	of R13_REGS.
+	(GPR_ZERO_REGNUM): Ditto.
+	(SAVE_{ACC,GUARD}_REGNUM): Ditto.
+	({FIXED,CALL_USED}_REGISTERS): Ditto.
+	(REG_ALLOC_ORDER): Ditto.
+	(reg_class): Ditto.
+	(REG_CLASS_{NAMES,CONTENTS}): Ditto.
+	(STATIC_CHAIN_REGNUM): Ditto.
+	({FUNCTION,LIBCALL}_VALUE): Ditto.
+	(FUNCTION_VALUE_REGNO_P): Ditto.
+
+	* d10v.md (32-bit shifts): Change to new ABI where args are in
+	r0..r3, r14 is zero register.  Change names of register class to
+	be ARG{0,1,2,3}_REGS, not R{2,3,4,5}_REGS, and RETURN_REGS instead
+	of R13_REGS.
+
+	* d10v/libgcc1.asm: Change to new ABI where args are in r0..r3,
+	r14 is zero register.  Change names of register class to be
+	ARG{0,1,2,3}_REGS, not R{2,3,4,5}_REGS, and RETURN_REGS instead of
+	R13_REGS.
+
+	* d10v/scrt0.asm (_start): Zero r14, not r0.
+
+Fri Jan 23 11:20:19 1998  J"orn Rennecke  <amylaar@cygnus.com>
+
+	* d10v.h (CUMULATIVE_ARGS): Now a typedefed struct.
+	* d10v.c (init_cumulative_args): Access the appropriate members of cum.
+	(function_arg, setup_incoming_varargs): Likewise.
+	(function_arg_advance): When an argument doesn't fit in registers,
+	retain the remaining argument regsiters for possible use by
+	subsequent arguments.
+	* va-d10v.h (__va_list_tag): New three members.
+	(__va_start_common, va_arg): Update.
+
+	* d10v.c (function_arg_boundary): Alignment for arguments starts
+	with an arguemnt size of four bytes.
+	(function_arg): No special case for structures > 4 bytes, if they
+	fit fully in the remaining argument passing registers, they are
+	passed in registers.
+	When an argument would exceed the remaining argument passing
+	registers, pass it fully on the stack.
+	(function_arg_advance): Likewise.  In the latter case, mark remaining
+	argument passing registers as used.
+	(function_arg_partial_nregs): Remove.
+	* d10v.h (FUNCTION_ARG_PARTIAL_NREGS): Don't define.
+
+	* va-d10v.h (enum __type_class): Remove.
+	(va_arg): Update.
+
+Thu Jan 22 10:45:40 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add thumb-*-coff target.
+
+	* config/arm/thumb.c (number_of_first_bit_set): Only use inline
+	attribute when compiling with GCC.
+
+	* config/arm/thumb.md (mulsi): Fix PR 14644.  Patch supplied by
+	Jim Wilson.
+
+	* config/arm/arm.c (output_func_epilogue): Fix PR14671 by changing
+	the logic for determining when stack unwinding code is needed.
+
+Wed Jan 21 11:01:49 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* invoke.texi (M32R/D/X Options): Add documentation of -mcond-exec
+	option.
+
+Tue Jan 20 16:01:03 1998  Anthony Green  <green@cygnus.com>
+
+	* invoke.texi (Optimize Options): -Os documentation.
+	* tm.texi (Run-time Target): New argument to OPTIMIZATION_OPTIONS.
+	* flags.h: New flag (optimize_size).
+	* toplev.c (main): Parse -Os option and set optimize_space
+	accordingly.
+	* gcc.c (default_compilers), cp/lang-specs.h, ch/lang-specs.h: Define 
+	__OPTIMIZE_SIZE__ when compiling with -Os.
+	* config/dsp16xx/dsp16xx.h, config/i386/i386.h,
+ 	config/i386/dgux.h, config/i960/i960.h, config/pdp11/pdp11.h,
+ 	config/v850/v850.h, config/d10v/d10v.h, config/sh/sh.h
+	(OPTIMIZATION_OPTIONS): New SIZE argument to macro.
+	* config/i386/i386.c (optimization_options): Accept new	SIZE argument.
+
+Tue Jan 20 16:01:03 1998  Anthony Green  <green@cygnus.com>
+
+	* config/d30v/d30v.h (OPTIMIZATION_OPTIONS): New SIZE argument to 
+	macro.
+
+Tue Jan 20 14:13:06 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Add support for conditional execution of
+	simple unary operators.  Add support for conditional execution of
+	addtion of small constants.
+	
+	* config/m32r/m32r.h: Ditto.
+
+	* config/m32r/m32r.c (generate_comparison,
+	unary_parallel_operator, emit_unary_cond_exec): Ditto.
+
+Mon Jan 19 16:48:43 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Add conditional execution patterns for
+	simple binary operations.
+	* config/m32r/m32r.h: Add support for conditional execution
+	patterns. 
+	* config/m32r/m32r.c (conditional_compare_operand,
+	binary_parallel_operator, emit_code_exec): New functions to
+	implement conditional execution of simple binary operations.
+
+Fri Jan 16 14:30:29 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.md: PR 14644: Fix multiply patterns to prevent
+	contraint matching failure when all three registers are the same.
+
+Thu Jan 15 16:41:18 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.h (PREDICATE_CODES): Add declaration of machine
+	specific predicates.
+	* config/m32r/m32r.md: Add patterns for simple conditional move
+	instructions. 
+
+	* config/m32r/m32r.c (gen_compare): Add support for parallel
+	instructions. 
+	(reg_or_zero_operand): New function.
+	(conditional_move_operand): New function.
+	(carry_compare_operator): New function.
+	(emit_S_clause): New function.
+	(emit_cond_move): New function.
+	
+Tue Jan 13 17:41:10 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* cse.c (invalidate): Remove CYGNUS LOCAL patch.
+
+Mon Jan 12 16:35:04 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* config/v850/v850.md: Removed duplicate entries.
+
+Mon Jan  5 17:22:09 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* d30v.h (CONST_COSTS): Define as an empty instead of not defining
+	it.
+
+Wed Dec 31 12:30:03 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.c (call_address_operand): Remove acceptance of
+	constant values and addresses held in registers.
+
+Wed Dec 31 12:26:53 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.md: Add patterns for the CMPZ and CMPEQ
+	instructions. 
+Tue Dec 30 16:19:47 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* d30v.c (d30v_return_addr_rtx): New static variable.
+	(override_options): Use SPECIAL_REG_P, not ARG_PTR_FIRST.
+	(d30v_stack_info): Note where link pointer is stored.
+	(d30v_function_epilogue): Reset d30v_return_addr_rtx.
+	(d30v_legitimate_address_p): Correctly test r1 for r0+r1
+	addressing.
+	(d30v_emit_cond_move): Emit code to do a conditional move.  If the
+	move is just the same as setcc or setcc of the reverse condition,
+	just emit that code instead.
+	(d30v_return_addr): Insert code to copy return address into a
+	temporary before saving it.
+
+	* d30v.h (SPECIAL_REG_*): Delete ARG_PTR* macros, replace with
+	SPECIAL_REG_* macros.
+	({FIXED,CALL_USED}_REGISTERS): Make registers easier to add new
+	registers, by starting each group on a separate line.
+	(REG_ALLOC_ORDER): Ditto.
+	(REGISTER_NAMES): Ditto.
+	(MASK_WORD3): Convert a register number into bitmask for 3rd word
+	of REG_CLASS_CONTENTS.
+	(*_MASK): Use MASK_WORD3 for each of the special/cr/flag/accum
+	registers.
+	(REG_CLASS_CONTENTS): Use the *_MASK macros.
+	({,INCOMING_}RETURN_ADDR_RTX): Define.
+	(INCOMING_FRAME_SP_OFFSET): Ditto.
+	(ELIMINABLE_REGS): Simplify somewhat.
+	(d30v_emit_cond_move): Add declaration.
+	(d30v_return_addr): Ditto.
+
+	* d30v.md (mov{qi,hi,si}cc): Use d30v_emit_cond_move to generate
+	conditional moves.
+
+Mon Dec 29 14:09:01 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (enable_fortran): Delete one too many '[' ']' levels.
+
+Mon Dec 29 14:38:50 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* mips/t-vr4100 (LIB2FUNCS_EXTRA): Add mips16.S.
+	* mips/t-vr4300: Likewise.
+
+Mon Dec 29 11:11:51 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/m32r/m32r.h: Add support for second accumulator register.
+	
+	* config/m32r/m32r.c: Add support for second accumulator register. 
+
+Mon Dec 29 11:06:16 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Disable fortran by default.
+
+Tue Dec 16 23:08:00 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d10v.h (REG_OK_FOR_BASE_P): Fix non-strict definition.
+
+	* d10v.c (function_arg): Don't pass DImode partially in registers.
+	(function_arg_pass_by_reference): Don't pass structs / unions by
+	reference.
+
+Tue Dec 16 20:12:39 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d10v.c (emit_comparison): Use CONSTANT_P to detect constant op1.
+	Check it for being a CONST_INT before using its value.
+	Use plus_constant_for_output to add to it.
+	Fix bug in output template for >= 32767.
+
+Tue Dec 16 11:17:12 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c (arm_override_options): Force apcs-32 mode if
+	interworking is specified.
+
+Fri Dec 12 18:54:23 1997  Per Bothner  <bothner@cygnus.com>
+
+	* expr.c (expand_builtin):  Support BUILT_IN_FMOD - just call fmod.
+
+Fri Dec 12 23:09:29 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* d10v.c (override_options): Fix regno_reg_class for registers
+	1, 7, 9, 11 and 15.
+
+	(d10v_subword): Fix word_num calculation for SUBREG.
+
+	(emit_subtract): Carry is ! Borrow.
+
+	(emit_comparison): Handle CONSTs.
+
+Mon Dec  8 17:12:47 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c (all_architectures): Removed processor field. 
+
+Wed Dec  3 10:44:25 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* mips/mips.md (muldi3_r4000): Broaden the output template
+	and attribute assignments to handle three operand dmult;
+	rename to muldi3_internal2.
+	(muldi3): Call the new muldi3_internal2 for R4000, and
+	any GENERATE_MULT3 chip.
+
+Tue Dec  2 09:20:50 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/lib1funcs.asm: Add error condition if
+	__USER_LABEL_PREFIX__ is not defined.
+
+	* config.sub: Add support for Thumb target.
+
+	* configure: Add support for Thumb target.
+
+Tue Nov 25 19:10:56 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* Makefile.in (fixproto-defines): New rule.
+	(fixhdr.ready): Depend on fixproto-defines.
+	(mostlyclean): Remove fixproto-defines.
+	(install-common): Don't create a temporary file, install the
+	ready-built fixproto-defines.
+
+Tue Nov 25 11:22:11 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.c: Brought up to date with respect to devo and
+	branch.
+	* config/arm/aout.h:        Ditto.
+	* config/arm/arm.h:         Ditto.
+	* config/arm/arm.md:        Ditto.
+	* config/arm/coff.h:        Ditto.
+	* config/arm/lib1funcs.asm: Ditto.
+	* config/arm/pe.h:          Ditto.
+	* config/arm/riscix.h:      Ditto.
+	* config/arm/riscix1-1.h:   Ditto.
+	* config/arm/semi.h:        Ditto.
+	* config/arm/semiaof.h:     Ditto.
+	* config/arm/t-bare:        Ditto.
+	* config/arm/t-linux:       Ditto.
+	* config/arm/aout.h:        Ditto.
+	* config/arm/lib1thumb.asm: Imported from branch.
+	* config/arm/t-thumb:       Imported from branch.
+	* config/arm/thumb.c:       Imported from branch.
+	* config/arm/thumb.h:       Imported from branch.
+	* config/arm/tcoff.h:       Imported from branch.
+	* config/arm/thumb.md:      Imported from branch.
+	* config/arm/xm-thumb.h:    Imported from branch.
+
+Mon Nov 24 17:19:39 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config/arm/arm.md: Updated with changes in devo.
+	* config/arm/arm.c:  Updated with changes in devo.
+	* config/arm/arm.h:  Updated with changes in devo.
+	* config/arm/aout.h: Updated with changes in devo.
+	* config/arm/semi.h: Updated with changes in devo.
+
+Sat Nov 22 15:32:00 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* gcc.c (SWITCH_CURTAILS_COMPILATION): Definition.
+	(DEFAULT_SWITCH_CURTAILS_COMPILATION): True for options -S and -c.
+	(process_command): If HAVE_EXECUTABLE_SUFFIX is defined then scan
+	command line arguments to see if an executable is not being
+	created, and if so - do not append the suffix.
+
+	* tm.texi (SWITCH_CURTAILS_COMPILATION): Add description of new
+	driver macro.
+
+Sat Nov 22 01:01:41 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (AR_FOR_TARGET): Clean up "-e" confustion with
+	program_transform_name.
+	(RANLIB_FOR_TARGET): Likewise.
+
+Tue Nov 11 22:38:02 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* combine.c (nonzero_bits): For paradoxical subregs, take
+	LOAD_EXTENDED_OP into account.
+
+Mon Nov 10 20:53:11 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config/mips/mips.h (MASK_DEBUG_H): Set to zero, so this bit
+	is available elsewhere.
+
+
+Local Variables:
+add-log-time-format: current-time-string
+End:
--- gcc/alias.c.jj	Sat Feb  3 23:47:57 2001
+++ gcc/alias.c	Mon Feb  5 14:56:13 2001
@@ -454,7 +454,7 @@ get_alias_set (t)
 
   /* If this is an aggregate type, we must record any component aliasing
      information.  */
-  if (AGGREGATE_TYPE_P (t))
+  if (AGGREGATE_TYPE_P (t) || TREE_CODE (t) == COMPLEX_TYPE)
     record_component_aliases (t);
 
   return set;
@@ -559,6 +559,10 @@ record_component_aliases (type)
       for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))
 	if (TREE_CODE (field) == FIELD_DECL && ! DECL_NONADDRESSABLE_P (field))
 	  record_alias_subset (superset, get_alias_set (TREE_TYPE (field)));
+      break;
+
+    case COMPLEX_TYPE:
+      record_alias_subset (superset, get_alias_set (TREE_TYPE (type)));
       break;
 
     default:
--- gcc/c-common.c.jj	Sat Feb  3 23:48:08 2001
+++ gcc/c-common.c	Mon Feb  5 14:56:13 2001
@@ -787,18 +787,7 @@ decl_attributes (node, attributes, prefi
 	    else if (i > HOST_BITS_PER_INT - 2)
 	      error ("requested alignment is too large");
 	    else if (is_type)
-	      {
-		if (decl)
-		  {
-		    DECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;
-		    DECL_USER_ALIGN (decl) = 1;
-		  }
-		else
-		  {
-		    TYPE_ALIGN (type) = (1 << i) * BITS_PER_UNIT;
-		    TYPE_USER_ALIGN (type) = 1;
-		  }
-	      }
+	      TYPE_ALIGN (type) = (1 << i) * BITS_PER_UNIT;
 	    else if (TREE_CODE (decl) != VAR_DECL
 		     && TREE_CODE (decl) != FIELD_DECL)
 	      error_with_decl (decl,
--- gcc/calls.c.jj	Sat Feb  3 23:48:05 2001
+++ gcc/calls.c	Mon Feb  5 14:56:13 2001
@@ -597,6 +597,10 @@ emit_call_1 (funexp, fndecl, funtype, st
     REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_EH_REGION, const0_rtx,
 					       REG_NOTES (call_insn));
 
+  if (ecf_flags & ECF_NORETURN)
+    REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_NORETURN, const0_rtx,
+					       REG_NOTES (call_insn));
+
   SIBLING_CALL_P (call_insn) = ((ecf_flags & ECF_SIBCALL) != 0);
 
   /* Restore this now, so that we do defer pops for this call's args
--- gcc/combine.c.jj	Sat Feb  3 23:48:01 2001
+++ gcc/combine.c	Mon Feb  5 14:56:13 2001
@@ -6549,6 +6549,7 @@ make_compound_operation (x, in_code)
 				 INTVAL (rhs) - INTVAL (XEXP (lhs, 1)),
 				 NULL_RTX, mode_width - INTVAL (rhs),
 				 code == LSHIFTRT, 0, in_code == COMPARE);
+	  break;
 	}
 
       /* See if we have operations between an ASHIFTRT and an ASHIFT.
@@ -12088,6 +12089,7 @@ distribute_notes (notes, from_insn, i3, 
 
 	case REG_EH_REGION:
 	case REG_EH_RETHROW:
+	case REG_NORETURN:
 	  /* These notes must remain with the call.  It should not be
 	     possible for both I2 and I3 to be a call.  */
 	  if (GET_CODE (i3) == CALL_INSN) 
--- gcc/doloop.c.jj	Mon Jul 31 01:57:55 2000
+++ gcc/doloop.c	Wed Sep 27 01:47:40 2000
@@ -280,7 +280,7 @@ doloop_valid_p (loop, jump_insn)
      statement within a loop will generate multiple loop exits.
      Another example of a loop that currently generates multiple exit
      targets is for (i = 0; i < (foo ? 8 : 4); i++) { }.  */
-  if (loop_info->has_multiple_exit_targets)
+  if (loop_info->has_multiple_exit_targets || loop->exit_count > 0)
     {
       if (loop_dump_stream)
 	fprintf (loop_dump_stream,
@@ -414,13 +414,13 @@ doloop_modify (loop, iterations, iterati
       fputs (" iterations).", loop_dump_stream);
     }
 
+  /* Emit the label that will delimit the top of the loop.  */
+  emit_label_after (start_label, loop->top ? loop->top : loop->start);
+  LABEL_NUSES (start_label)++;
+
   /* Discard original jump to continue loop.  The original compare
      result may still be live, so it cannot be discarded explicitly.  */
   delete_insn (jump_insn);
-
-  /* Emit the label that will delimit the start of the loop.  */
-  emit_label_after (start_label, loop->start);
-  LABEL_NUSES (start_label)++;
 
   counter_reg = XEXP (condition, 0);
   if (GET_CODE (counter_reg) == PLUS)
--- gcc/defaults.h.jj	Sat Feb  3 23:48:11 2001
+++ gcc/defaults.h	Mon Feb  5 14:56:13 2001
@@ -129,6 +129,15 @@ do { ASM_OUTPUT_LABEL(FILE,LABEL_ALTERNA
 #define ASM_OUTPUT_LABELREF(FILE,NAME)  asm_fprintf ((FILE), "%U%s", (NAME))
 #endif
 
+/* Allow target to print debug info labels specially.  This is useful for
+   VLIW targets, since debug info labels should go into the middle of
+   instruction bundles instead of breaking them.  */
+
+#ifndef ASM_OUTPUT_DEBUG_LABEL
+#define ASM_OUTPUT_DEBUG_LABEL(FILE, PREFIX, NUM) \
+  ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM)
+#endif
+
 /* This determines whether or not we support weak symbols.  */
 #ifndef SUPPORTS_WEAK
 #ifdef ASM_WEAKEN_LABEL
--- gcc/expmed.c.jj	Sat Feb  3 23:48:11 2001
+++ gcc/expmed.c	Mon Feb  5 15:19:38 2001
@@ -245,7 +245,9 @@ store_bit_field (str_rtx, bitsize, bitnu
   insv_bitsize = GET_MODE_BITSIZE (op_mode);
 #endif
 
-  if (GET_CODE (str_rtx) == MEM && ! MEM_IN_STRUCT_P (str_rtx))
+  /* It is wrong to have align==0, since every object is aligned at
+     least at a bit boundary.  This usually means a bug elsewhere.  */
+  if (align == 0)
     abort ();
 
   /* Discount the part of the structure before the desired byte.
--- gcc/expr.c.jj	Sat Feb  3 23:48:06 2001
+++ gcc/expr.c	Mon Feb  5 14:56:13 2001
@@ -1941,7 +1941,7 @@ emit_group_load (dst, orig_src, ssize, a
   /* If we won't be loading directly from memory, protect the real source
      from strange tricks we might play.  */
   src = orig_src;
-  if (GET_CODE (src) != MEM)
+  if (GET_CODE (src) != MEM && ! CONSTANT_P (src))
     {
       if (GET_MODE (src) == VOIDmode)
 	src = gen_reg_rtx (GET_MODE (dst));
@@ -1990,6 +1990,10 @@ emit_group_load (dst, orig_src, ssize, a
 	  else
 	    abort ();
 	}
+      else if ((CONSTANT_P (src)
+		&& (GET_MODE (src) == VOIDmode || GET_MODE (src) == mode))
+	       || (GET_CODE (src) == REG && GET_MODE (src) == mode))
+	tmps[i] = src;
       else
 	tmps[i] = extract_bit_field (src, bytelen * BITS_PER_UNIT,
 				     bytepos * BITS_PER_UNIT, 1, NULL_RTX,
@@ -2069,14 +2073,6 @@ emit_group_store (orig_dst, src, ssize, 
       /* Make life a bit easier for combine.  */
       emit_move_insn (dst, const0_rtx);
     }
-  else if (! MEM_IN_STRUCT_P (dst))
-    {
-      /* store_bit_field requires that memory operations have
-	 mem_in_struct_p set; we might not.  */
-
-      dst = copy_rtx (orig_dst);
-      MEM_SET_IN_STRUCT_P (dst, 1);
-    }
 
   /* Process the pieces.  */
   for (i = start; i < XVECLEN (src, 0); i++)
--- gcc/final.c.jj	Sat Feb  3 23:48:05 2001
+++ gcc/final.c	Mon Feb  5 15:25:24 2001
@@ -2272,7 +2272,7 @@ final_scan_insn (insn, file, optimize, p
 	     referenced (in the form of having its address taken.  */
 	  /* ??? Figure out how not to do this unconditionally.  This
 	     interferes with bundling on LIW targets.  */
-	  ASM_OUTPUT_INTERNAL_LABEL (file, "L", CODE_LABEL_NUMBER (insn));
+	  ASM_OUTPUT_DEBUG_LABEL (file, "L", CODE_LABEL_NUMBER (insn));
 
 	  if (debug_info_level == DINFO_LEVEL_NORMAL
 	      || debug_info_level == DINFO_LEVEL_VERBOSE)
@@ -4137,7 +4137,7 @@ leaf_function_p ()
   for (insn = current_function_epilogue_delay_list; insn; insn = XEXP (insn, 1))
     {
       if (GET_CODE (XEXP (insn, 0)) == CALL_INSN
-	  && ! SIBLING_CALL_P (insn))
+	  && ! SIBLING_CALL_P (XEXP (insn, 0)))
 	return 0;
       if (GET_CODE (XEXP (insn, 0)) == INSN
 	  && GET_CODE (PATTERN (XEXP (insn, 0))) == SEQUENCE
--- gcc/flow.c.jj	Sat Feb  3 23:47:50 2001
+++ gcc/flow.c	Mon Feb  5 19:12:41 2001
@@ -162,6 +162,13 @@ Boston, MA 02111-1307, USA.  */
 #define HAVE_sibcall_epilogue 0
 #endif
 
+#ifndef LOCAL_REGNO
+#define LOCAL_REGNO(REGNO)  0
+#endif
+#ifndef EPILOGUE_USES
+#define EPILOGUE_USES(REGNO)  0
+#endif
+
 /* The contents of the current function definition are allocated
    in this obstack, and all are freed at the end of the function.
    For top-level functions, this is temporary_obstack.
@@ -3028,8 +3037,9 @@ mark_regs_live_at_end (set)
     {
       SET_REGNO_REG_SET (set, FRAME_POINTER_REGNUM);
 #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM
-      /* If they are different, also mark the hard frame pointer as live */
-      SET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);
+      /* If they are different, also mark the hard frame pointer as live.  */
+      if (! LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))
+        SET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);
 #endif      
     }
 
@@ -3047,18 +3057,14 @@ mark_regs_live_at_end (set)
      as being live at the end of the function since they may be
      referenced by our caller.  */
   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-    if (global_regs[i]
-#ifdef EPILOGUE_USES
-	|| EPILOGUE_USES (i)
-#endif
-	)
+    if (global_regs[i] || EPILOGUE_USES (i))
       SET_REGNO_REG_SET (set, i);
 
   /* Mark all call-saved registers that we actaully used.  */
   if (HAVE_epilogue && reload_completed)
     {
       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-	if (! call_used_regs[i] && regs_ever_live[i])
+	if (regs_ever_live[i] && ! call_used_regs[i] && ! LOCAL_REGNO (i))
 	  SET_REGNO_REG_SET (set, i);
     }
 
@@ -3745,7 +3751,18 @@ init_propagate_block_info (bb, live, loc
 		|| (GET_CODE (XEXP (mem, 0)) == PLUS
 		    && XEXP (XEXP (mem, 0), 0) == frame_pointer_rtx
 		    && GET_CODE (XEXP (XEXP (mem, 0), 1)) == CONST_INT))
-	      pbi->mem_set_list = alloc_EXPR_LIST (0, mem, pbi->mem_set_list);
+	      {
+#ifdef AUTO_INC_DEC
+		/* Store a copy of mem, otherwise the address may be
+		   scrogged by find_auto_inc.  This can cause discrepencies
+		   between the set of live registers calculated during
+		   the calculate_global_regs_live phase and what actually
+		   exists after flow completes, leading to aborts.  */
+		if (flags & PROP_AUTOINC)
+		  mem = shallow_copy_rtx (mem);
+#endif
+		pbi->mem_set_list = alloc_EXPR_LIST (0, mem, pbi->mem_set_list);
+	      }
 	  }
     }
 
@@ -4360,7 +4377,15 @@ mark_set_1 (pbi, code, reg, cond, insn, 
 	     everything that invalidates it.  To be safe, don't eliminate any
 	     stores though SP; none of them should be redundant anyway.  */
 	  && ! reg_mentioned_p (stack_pointer_rtx, reg))
-	pbi->mem_set_list = alloc_EXPR_LIST (0, reg, pbi->mem_set_list);
+	{
+#ifdef AUTO_INC_DEC
+	  /* Store a copy of mem, otherwise the address may be
+	     scrogged by find_auto_inc.  */
+	  if (flags & PROP_AUTOINC)
+	    reg = shallow_copy_rtx (reg);
+#endif
+	  pbi->mem_set_list = alloc_EXPR_LIST (0, reg, pbi->mem_set_list);
+	}
     }
 
   if (GET_CODE (reg) == REG
@@ -4585,8 +4610,7 @@ mark_regno_cond_dead (pbi, regno, cond)
 	  splay_tree_insert (pbi->reg_cond_dead, regno,
 			     (splay_tree_value) rcli);
 
-	  SET_REGNO_REG_SET (pbi->reg_cond_reg,
-			     REGNO (XEXP (cond, 0)));
+	  SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));
 
 	  /* Not unconditionaly dead.  */
 	  return 0;
@@ -4607,8 +4631,7 @@ mark_regno_cond_dead (pbi, regno, cond)
 	    {
 	      rcli->condition = ncond;
 
-	      SET_REGNO_REG_SET (pbi->reg_cond_reg,
-				 REGNO (XEXP (cond, 0)));
+	      SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));
 
 	      /* Not unconditionaly dead.  */
 	      return 0;
@@ -5210,7 +5233,10 @@ mark_used_reg (pbi, reg, cond, insn)
 		  splay_tree_remove (pbi->reg_cond_dead, regno);
 		}
 	      else
-		rcli->condition = ncond;
+		{
+		  rcli->condition = ncond;
+		  SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));
+		}
 	    }
 	}
       else
@@ -5221,6 +5247,8 @@ mark_used_reg (pbi, reg, cond, insn)
 	  rcli->condition = not_reg_cond (cond);
 	  splay_tree_insert (pbi->reg_cond_dead, regno,
 			     (splay_tree_value) rcli);
+
+	  SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));
 	}
     }
   else if (some_was_live)
--- gcc/frame.h.jj	Fri Jul  7 21:39:58 2000
+++ gcc/frame.h	Mon Feb  5 14:56:13 2001
@@ -30,12 +30,12 @@ typedef struct frame_state
   void *cfa;
   void *eh_ptr;
   long cfa_offset;
+  long base_offset;
   long args_size;
   long reg_or_offset[DWARF_FRAME_REGISTERS+1];
   unsigned short cfa_reg;
   unsigned short retaddr_column;
   char saved[DWARF_FRAME_REGISTERS+1];
-  long base_offset;
   char indirect;
 } frame_state;
 
@@ -248,6 +248,7 @@ typedef struct ia64_frame_state
   ia64_reg_loc sp;
   ia64_reg_loc psp;
   ia64_reg_loc spill_base;
+  void *my_psp;
   void *my_sp;
   void *my_bsp;
 } ia64_frame_state;
@@ -266,8 +267,13 @@ typedef struct unwind_info_ptr 
 #define IA64_UNW_HDR_FLAGS(x)	(((x) >> 32) & 0xffffUL)
 #define IA64_UNW_HDR_VERSION(x)	(((x) >> 48) & 0xffffUL)
 
+/* Header flag bits, after extraction by IA64_UNW_HDR_FLAGS.  */
+#define IA64_UNW_EHANDLER	0x1
+#define IA64_UNW_UHANDLER	0x2
+
 extern unwind_info_ptr *__build_ia64_frame_state (unsigned char *, 
-						  ia64_frame_state *, void *,
+						  ia64_frame_state *,
+						  void *, void *,
 						  void **);
 extern void *__get_real_reg_value (ia64_reg_loc *);
 extern void *__get_personality (unwind_info_ptr *);
--- gcc/function.c.jj	Sat Feb  3 23:48:08 2001
+++ gcc/function.c	Mon Feb  5 14:56:13 2001
@@ -1466,6 +1466,7 @@ put_reg_into_stack (function, reg, type,
   struct function *func = function ? function : cfun;
   rtx new = 0;
   unsigned int regno = original_regno;
+  int unsigned_p;
 
   if (regno == 0)
     regno = REGNO (reg);
@@ -1487,9 +1488,15 @@ put_reg_into_stack (function, reg, type,
      previously generated stack slot, then we need to copy the bit in
      case it was set for other reasons.  For instance, it is set for
      __builtin_va_alist.  */
-  MEM_SET_IN_STRUCT_P (reg,
-		       AGGREGATE_TYPE_P (type) || MEM_IN_STRUCT_P (new));
-  MEM_ALIAS_SET (reg) = get_alias_set (type);
+  if (type)
+    {
+      MEM_SET_IN_STRUCT_P (reg, (AGGREGATE_TYPE_P (type)
+				 || MEM_IN_STRUCT_P (new)));
+      MEM_ALIAS_SET (reg) = get_alias_set (type);
+      unsigned_p = TREE_UNSIGNED (type);
+    }
+  else
+    unsigned_p = 0;
 
   /* Now make sure that all refs to the variable, previously made
      when it was a register, are fixed up to be valid again.  */
@@ -1502,13 +1509,13 @@ put_reg_into_stack (function, reg, type,
 	= (struct var_refs_queue *) xmalloc (sizeof (struct var_refs_queue));
       temp->modified = reg;
       temp->promoted_mode = promoted_mode;
-      temp->unsignedp = TREE_UNSIGNED (type);
+      temp->unsignedp = unsigned_p;
       temp->next = function->fixup_var_refs_queue;
       function->fixup_var_refs_queue = temp;
     }
   else if (used_p)
     /* Variable is local; fix it up now.  */
-    fixup_var_refs (reg, promoted_mode, TREE_UNSIGNED (type), ht);
+    fixup_var_refs (reg, promoted_mode, unsigned_p, ht);
 }
 
 static void
@@ -1979,6 +1986,14 @@ fixup_var_refs_1 (var, promoted_mode, lo
 		  if (replacement->new == 0)
 		    replacement->new = gen_reg_rtx (GET_MODE (var));
 		  SUBREG_REG (tem) = replacement->new;
+
+		  /* The following code works only if we have a MEM, so we
+		     need to handle the subreg here.  We directly substitute
+		     it assuming that a subreg must be OK here.  We already
+		     scheduled a replacement to copy the mem into the
+		     subreg.  */
+		  XEXP (x, 0) = tem;
+		  return;
 		}
 	      else
 		tem = fixup_memory_subreg (tem, insn, 0);
@@ -2280,7 +2295,7 @@ fixup_var_refs_1 (var, promoted_mode, lo
 	    && GET_MODE (var) == promoted_mode
 	    && x == single_set (insn))
 	  {
-	    rtx pat;
+	    rtx pat, last;
 
 	    replacement = find_fixup_replacement (replacements, SET_SRC (x));
 	    if (replacement->new)
@@ -2306,10 +2321,22 @@ fixup_var_refs_1 (var, promoted_mode, lo
 	    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));
 	    if (GET_CODE (pat) == SEQUENCE)
 	      {
-		emit_insn_after (pat, insn);
-		PUT_CODE (insn, NOTE);
-		NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;
-		NOTE_SOURCE_FILE (insn) = 0;
+		last = emit_insn_before (pat, insn);
+
+		/* INSN might have REG_RETVAL or other important notes, so
+		   we need to store the pattern of the last insn in the
+		   sequence into INSN similarly to the normal case.  LAST
+		   should not have REG_NOTES, but we allow them if INSN has
+		   no REG_NOTES.  */
+		if (REG_NOTES (last) && REG_NOTES (insn))
+		  abort ();
+		if (REG_NOTES (last))
+		  REG_NOTES (insn) = REG_NOTES (last);
+		PATTERN (insn) = PATTERN (last);
+
+		PUT_CODE (last, NOTE);
+		NOTE_LINE_NUMBER (last) = NOTE_INSN_DELETED;
+		NOTE_SOURCE_FILE (last) = 0;
 	      }
 	    else
 	      PATTERN (insn) = pat;
@@ -2326,7 +2353,7 @@ fixup_var_refs_1 (var, promoted_mode, lo
 	    && GET_MODE (var) == promoted_mode
 	    && x == single_set (insn))
 	  {
-	    rtx pat;
+	    rtx pat, last;
 
 	    if (GET_CODE (SET_DEST (x)) == SUBREG)
 	      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn, 0);
@@ -2339,10 +2366,22 @@ fixup_var_refs_1 (var, promoted_mode, lo
 	    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));
 	    if (GET_CODE (pat) == SEQUENCE)
 	      {
-		emit_insn_after (pat, insn);
-		PUT_CODE (insn, NOTE);
-		NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;
-		NOTE_SOURCE_FILE (insn) = 0;
+		last = emit_insn_before (pat, insn);
+
+		/* INSN might have REG_RETVAL or other important notes, so
+		   we need to store the pattern of the last insn in the
+		   sequence into INSN similarly to the normal case.  LAST
+		   should not have REG_NOTES, but we allow them if INSN has
+		   no REG_NOTES.  */
+		if (REG_NOTES (last) && REG_NOTES (insn))
+		  abort ();
+		if (REG_NOTES (last))
+		  REG_NOTES (insn) = REG_NOTES (last);
+		PATTERN (insn) = PATTERN (last);
+
+		PUT_CODE (last, NOTE);
+		NOTE_LINE_NUMBER (last) = NOTE_INSN_DELETED;
+		NOTE_SOURCE_FILE (last) = 0;
 	      }
 	    else
 	      PATTERN (insn) = pat;
@@ -2776,7 +2815,6 @@ gen_mem_addressof (reg, decl)
      rtx reg;
      tree decl;
 {
-  tree type = TREE_TYPE (decl);
   rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)),
 			     REGNO (reg), decl);
 
@@ -2786,14 +2824,26 @@ gen_mem_addressof (reg, decl)
   RTX_UNCHANGING_P (XEXP (r, 0)) = RTX_UNCHANGING_P (reg);
 
   PUT_CODE (reg, MEM);
-  PUT_MODE (reg, DECL_MODE (decl));
   XEXP (reg, 0) = r;
-  MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);
-  MEM_SET_IN_STRUCT_P (reg, AGGREGATE_TYPE_P (type));
-  MEM_ALIAS_SET (reg) = get_alias_set (decl);
+  if (decl)
+    {
+      tree type = TREE_TYPE (decl);
+
+      PUT_MODE (reg, DECL_MODE (decl));
+      MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);
+      MEM_SET_IN_STRUCT_P (reg, AGGREGATE_TYPE_P (type));
+      MEM_ALIAS_SET (reg) = get_alias_set (decl);
+
+      if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)
+	fixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), 0);
+    }
+  else
+    {
+      /* We have no alias information about this newly created MEM.  */
+      MEM_ALIAS_SET (reg) = 0;
 
-  if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)
-    fixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), 0);
+      fixup_var_refs (reg, GET_MODE (reg), 0, 0);
+    }
 
   return reg;
 }
@@ -2819,21 +2869,33 @@ put_addressof_into_stack (r, ht)
      rtx r;
      struct hash_table *ht;
 {
-  tree decl = ADDRESSOF_DECL (r);
+  tree decl, type;
+  int volatile_p, used_p;
+
   rtx reg = XEXP (r, 0);
 
   if (GET_CODE (reg) != REG)
     abort ();
 
-  put_reg_into_stack (0, reg, TREE_TYPE (decl), GET_MODE (reg),
-		      GET_MODE (reg),
-		      (TREE_CODE (decl) != SAVE_EXPR
-		       && TREE_THIS_VOLATILE (decl)),
-		      ADDRESSOF_REGNO (r),
-		      (TREE_USED (decl)
-		       || (TREE_CODE (decl) != SAVE_EXPR
-			   && DECL_INITIAL (decl) != 0)),
-		      ht);
+  decl = ADDRESSOF_DECL (r);
+  if (decl)
+    {
+      type = TREE_TYPE (decl);
+      volatile_p = (TREE_CODE (decl) != SAVE_EXPR
+		    && TREE_THIS_VOLATILE (decl));
+      used_p = (TREE_USED (decl)
+		|| (TREE_CODE (decl) != SAVE_EXPR
+		    && DECL_INITIAL (decl) != 0));
+    }
+  else
+    {
+      type = NULL_TREE;
+      volatile_p = 0;
+      used_p = 1;
+    }
+
+  put_reg_into_stack (0, reg, type, GET_MODE (reg), GET_MODE (reg),
+		      volatile_p, ADDRESSOF_REGNO (r), used_p, ht);
 }
 
 /* List of replacements made below in purge_addressof_1 when creating
--- gcc/gcse.c.jj	Mon Jul 31 20:02:11 2000
+++ gcc/gcse.c	Mon Feb  5 18:01:01 2001
@@ -465,14 +465,11 @@ static sbitmap reg_set_bitmap;
    gcse) and it's currently not easy to realloc sbitmap vectors.  */
 static sbitmap *reg_set_in_block;
 
-/* For each block, non-zero if memory is set in that block.
-   This is computed during hash table computation and is used by
-   expr_killed_p and compute_transp.
-   ??? Handling of memory is very simple, we don't make any attempt
-   to optimize things (later).
-   ??? This can be computed by compute_sets since the information
-   doesn't change.  */
-static char *mem_set_in_block;
+/* CYGNUS LOCAL alias/law */
+/* Array, indexed by basic block number for a list of insns which modify
+   memory within that block.  */
+static rtx *modify_mem_list;
+/* END CYGNUS LOCAL */
 
 /* Various variables for statistics gathering.  */
 
@@ -586,6 +583,10 @@ static int cprop_jump		PARAMS ((rtx, rtx
 #ifdef HAVE_cc0
 static int cprop_cc0_jump	PARAMS ((rtx, struct reg_use *, rtx));
 #endif
+/* CYGNUS LOCAL alias/law */
+static void mems_conflict_for_gcse_p PARAMS ((rtx, rtx, void *));
+static int load_killed_in_block_p PARAMS ((int, int, rtx, int));
+/* END CYGNUS LOCAL */
 static int cprop_insn		PARAMS ((rtx, int));
 static int cprop		PARAMS ((int));
 static int one_cprop_pass	PARAMS ((int, int));
@@ -652,6 +653,13 @@ gcse_main (f, file)
   /* Point to release obstack data from for each pass.  */
   char *gcse_obstack_bottom;
 
+  /* CYGNUS LOCAL alias/law */
+  /* Insertion of instructions on edges can create new basic blocks; we
+     need the original basic block count so that we can properly deallocate
+     arrays sized on the number of basic blocks originally in the cfg.  */
+  int orig_bb_count;
+  /* END CYGNUS LOCAL */
+
   /* We do not construct an accurate cfg in functions which call
      setjmp, so just punt to be safe.  */
   if (current_function_calls_setjmp)
@@ -671,6 +679,10 @@ gcse_main (f, file)
   if (file)
     dump_flow_info (file);
 
+  /* CYGNUS LOCAL alias/law */
+  orig_bb_count = n_basic_blocks;
+  /* END CYGNUS LOCAL */
+
   /* Return if there's nothing to do.  */
   if (n_basic_blocks <= 1)
     return 0;
@@ -696,6 +708,11 @@ gcse_main (f, file)
   gcc_obstack_init (&gcse_obstack);
   bytes_used = 0;
 
+  /* CYGNUS LOCAL alias/law */
+  /* We need alias.  */
+  init_alias_analysis ();
+  /* END CYGNUS LOCAL */
+
   /* Record where pseudo-registers are set.  This data is kept accurate
      during each pass.  ??? We could also record hard-reg information here
      [since it's unchanging], however it is currently done during hash table
@@ -737,10 +754,28 @@ gcse_main (f, file)
       else
         {
 	  changed |= one_pre_gcse_pass (pass + 1);
-	  free_reg_set_mem ();
-	  alloc_reg_set_mem (max_reg_num ());
-	  compute_sets (f);
-	  run_jump_opt_after_gcse = 1;
+
+	  /* CYGNUS LOCAL alias/law */
+	  /* We may have just created new basic blocks.  Release and
+	     recompute various things which are sized on the number of
+	     basic blocks.  */
+	  if (changed)
+	    {
+	      int i;
+
+	      for (i = 0; i < orig_bb_count; i++)
+		if (modify_mem_list[i])
+		  free_INSN_LIST_list (modify_mem_list + i);
+	      modify_mem_list
+		= (rtx *) gmalloc (n_basic_blocks * sizeof (rtx *));
+	      bzero ((char *) modify_mem_list, n_basic_blocks * sizeof (rtx *));
+	      orig_bb_count = n_basic_blocks;
+	      free_reg_set_mem ();
+	      alloc_reg_set_mem (max_reg_num ());
+	      compute_sets (f);
+	      run_jump_opt_after_gcse = 1;
+	    }
+	  /* END CYGNUS LOCAL */
 	}
 
       if (max_pass_bytes < bytes_used)
@@ -797,6 +832,13 @@ gcse_main (f, file)
 
   obstack_free (&gcse_obstack, NULL_PTR);
   free_reg_set_mem ();
+
+  /* CYGNUS LOCAL alias/law */
+  /* We are finished with alias.  */
+  end_alias_analysis ();
+  /* END CYGNUS LOCAL */
+
+  /* Record where pseudo-registers are set.  */
   return run_jump_opt_after_gcse;
 }
 
@@ -914,7 +956,13 @@ alloc_gcse_mem (f)
   /* Allocate vars to track sets of regs, memory per block.  */
   reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks,
 						       max_gcse_regno);
-  mem_set_in_block = (char *) gmalloc (n_basic_blocks);
+
+  /* CYGNUS LOCAL alias/law */
+  /* Allocate array to keep a list of insns which modify memory in each
+     basic block.  */
+  modify_mem_list = (rtx *) gmalloc (n_basic_blocks * sizeof (rtx *));
+  bzero ((char *) modify_mem_list, n_basic_blocks * sizeof (rtx *));
+  /* END CYGNUS LOCAL */
 }
 
 /* Free memory allocated by alloc_gcse_mem.  */
@@ -928,7 +976,20 @@ free_gcse_mem ()
   free (reg_set_bitmap);
 
   free (reg_set_in_block);
-  free (mem_set_in_block);
+
+  /* CYGNUS LOCAL alias/law */
+  /* re-Cache any INSN_LIST nodes we have allocated.  */
+  {
+    int i;
+
+    for (i = 0; i < n_basic_blocks; i++)
+      if (modify_mem_list[i])
+        free_INSN_LIST_list (modify_mem_list + i);
+
+    free (modify_mem_list);
+    modify_mem_list = 0;
+  }
+  /* END CYGNUS LOCAL */
 }
 
 /* Many of the global optimization algorithms work by solving dataflow
@@ -1176,15 +1237,8 @@ compute_sets (f)
 static int *reg_first_set;
 static int *reg_last_set;
 
-/* While computing "first/last set" info, this is the CUID of first/last insn
-   to set memory or -1 if not set.  `mem_last_set' is also used when
-   performing GCSE to record whether memory has been set since the beginning
-   of the block.
-
-   Note that handling of memory is very simple, we don't make any attempt
-   to optimize things (later).  */
-static int mem_first_set;
-static int mem_last_set;
+/* CYGNUS LOCAL alias/law */
+/* END CYGNUS LOCAL */
 
 /* Perform a quick check whether X, the source of a set, is something
    we want to consider for GCSE.  */
@@ -1209,6 +1263,97 @@ want_to_gcse_p (x)
   return 1;
 }
 
+/* CYGNUS LOCAL alias/law */
+/* Used for communication between mems_conflict_for_gcse_p and
+   load_killed_in_block_p.  Nonzero if mems_conflict_for_gcse_p finds a
+   conflict between two memory references.  */
+static int gcse_mems_conflict_p;
+
+/* Used for communication between mems_conflict_for_gcse_p and
+   load_killed_in_block_p.  A memory reference for a load instruction,
+   mems_conflict_for_gcse_p will see if a memory store conflicts with
+   this memory load.  */
+static rtx gcse_mem_operand;
+
+/* DEST is the output of an instruction.  If it is a memory reference, and
+   possibly conflicts with the load found in gcse_mem_operand, then set
+   gcse_mems_conflict_p to a nonzero value.  */
+
+static void
+mems_conflict_for_gcse_p (dest, setter, data)
+     rtx dest, setter ATTRIBUTE_UNUSED;
+     void *data ATTRIBUTE_UNUSED;
+{
+  while (GET_CODE (dest) == SUBREG
+         || GET_CODE (dest) == ZERO_EXTRACT
+         || GET_CODE (dest) == SIGN_EXTRACT
+         || GET_CODE (dest) == STRICT_LOW_PART)
+    dest = XEXP (dest, 0);
+
+  /* If DEST is not a MEM, then it will not conflict with the load.  Note
+     that function calls are assumed to clobber memory, but are handled
+     elsewhere.  */
+  if (GET_CODE (dest) != MEM)
+    return;
+
+  if (true_dependence (dest, GET_MODE (dest), gcse_mem_operand,
+		       rtx_addr_varies_p))
+    gcse_mems_conflict_p = 1;
+}
+
+/* Return nonzero if the expression in X (a memory reference) is killed
+   in block BB before or after the insn with the CUID in UID_LIMIT.
+   AVAIL_P is nonzero for kills after UID_LIMIT, and zero for kills
+   before UID_LIMIT.
+
+   To check the entire block, set UID_LIMIT to max_uid + 1 and
+   AVAIL_P to 0.  */
+
+static int
+load_killed_in_block_p (bb, uid_limit, x, avail_p)
+     int bb;
+     int uid_limit;
+     rtx x;
+     int avail_p;
+{
+  rtx list_entry = modify_mem_list[bb];
+  while (list_entry)
+    {
+      rtx setter;
+      /* Ignore entries in the list that do not apply.  */
+      if ((avail_p
+	   && INSN_CUID (XEXP (list_entry, 0)) < uid_limit)
+	  || (! avail_p
+	      && INSN_CUID (XEXP (list_entry, 0)) > uid_limit))
+        {
+	  list_entry = XEXP (list_entry, 1);
+	  continue;
+	}
+
+      setter = XEXP (list_entry, 0);
+
+      /* If SETTER is a call everything is clobbered.  Note that calls
+         to pure functions are never put on the list, so we need not
+         worry about them.  */
+      if (GET_CODE (setter) == CALL_INSN)
+        return 1;
+
+      /* SETTER must be an INSN of some kind that sets memory.  Call
+         note_stores to examine each hunk of memory that is modified. 
+
+         The note_stores interface is pretty limited, so we have to
+         communicate via global variables.  Yuk.  */
+      gcse_mem_operand = x;
+      gcse_mems_conflict_p = 0;
+      note_stores (PATTERN (setter), mems_conflict_for_gcse_p, NULL);
+      if (gcse_mems_conflict_p)
+        return 1;
+      list_entry = XEXP (list_entry, 1);
+    }
+  return 0;
+}
+/* END CYGNUS LOCAL */
+
 /* Return non-zero if the operands of expression X are unchanged from the
    start of INSN's basic block up to but not including INSN (if AVAIL_P == 0),
    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */
@@ -1237,14 +1382,15 @@ oprs_unchanged_p (x, insn, avail_p)
 		|| reg_first_set[REGNO (x)] >= INSN_CUID (insn));
 
     case MEM:
-      if (avail_p && mem_last_set != NEVER_SET
-	  && mem_last_set >= INSN_CUID (insn))
+      /* CYGNUS LOCAL alias/law */
+      if (load_killed_in_block_p (BLOCK_NUM (insn), INSN_CUID (insn),
+				  x, avail_p))
 	return 0;
-      else if (! avail_p && mem_first_set != NEVER_SET
-	       && mem_first_set < INSN_CUID (insn))
-	return 0;
-      else
+
+      /* There is no conflict for the memory locations.  Now check that the
+	 address itself has not changed.  */
 	return oprs_unchanged_p (XEXP (x, 0), insn, avail_p);
+      /* END CYGNUS LOCAL */
 
     case PRE_DEC:
     case PRE_INC:
@@ -2027,18 +2173,19 @@ record_last_reg_set_info (insn, regno)
   SET_BIT (reg_set_in_block[BLOCK_NUM (insn)], regno);
 }
 
-/* Record memory first/last/block set information for INSN.  */
+/* CYGNUS LOCAL alias/law */
+/* Record memory modification information for INSN.  We do not actually care
+   about the memory location(s) that are set, or even how they are set (consider
+   a CALL_INSN).  We merely need to record which insns modify memory.  */
 
 static void
 record_last_mem_set_info (insn)
      rtx insn;
 {
-  if (mem_first_set == NEVER_SET)
-    mem_first_set = INSN_CUID (insn);
-
-  mem_last_set = INSN_CUID (insn);
-  mem_set_in_block[BLOCK_NUM (insn)] = 1;
+  modify_mem_list[BLOCK_NUM (insn)]
+    = alloc_INSN_LIST (insn, modify_mem_list[BLOCK_NUM (insn)]);
 }
+/* END CYGNUS LOCAL */
 
 /* Called from compute_hash_table via note_stores to handle one
    SET or CLOBBER in an insn.  DATA is really the instruction in which
@@ -2092,7 +2239,16 @@ compute_hash_table (set_p)
      ??? This isn't needed during const/copy propagation, but it's cheap to
      compute.  Later.  */
   sbitmap_vector_zero (reg_set_in_block, n_basic_blocks);
-  bzero ((char *) mem_set_in_block, n_basic_blocks);
+
+  /* CYGNUS LOCAL alias/law */
+  /* re-Cache any INSN_LIST nodes we have allocated.  */
+  {
+    int i;
+    for (i = 0; i < n_basic_blocks; i++)
+      if (modify_mem_list[i])
+	free_INSN_LIST_list (modify_mem_list + i);
+  }
+  /* END CYGNUS LOCAL */
 
   /* Some working arrays used to track first and last set in each block.  */
   /* ??? One could use alloca here, but at some size a threshold is crossed
@@ -2115,9 +2271,6 @@ compute_hash_table (set_p)
       for (i = 0; i < max_gcse_regno; i++)
 	reg_first_set[i] = reg_last_set[i] = NEVER_SET;
 
-      mem_first_set = NEVER_SET;
-      mem_last_set = NEVER_SET;
-
       for (insn = BLOCK_HEAD (bb);
 	   insn && insn != NEXT_INSN (BLOCK_END (bb));
 	   insn = NEXT_INSN (insn))
@@ -2347,10 +2500,16 @@ reset_opr_set_tables ()
      the block.  */
   sbitmap_zero (reg_set_bitmap);
 
-  /* Also keep a record of the last instruction to modify memory.
-     For now this is very trivial, we only record whether any memory
-     location has been modified.  */
-  mem_last_set = 0;
+  /* CYGNUS LOCAL alias/law */
+  {
+    int i;
+
+    /* re-Cache any INSN_LIST nodes we have allocated.  */
+    for (i = 0; i < n_basic_blocks; i++)
+      if (modify_mem_list[i])
+	free_INSN_LIST_list (modify_mem_list + i);
+  }
+  /* END CYGNUS LOCAL */
 }
 
 /* Return non-zero if the operands of X are not set before INSN in
@@ -2382,10 +2541,14 @@ oprs_not_set_p (x, insn)
       return 1;
 
     case MEM:
-      if (mem_last_set != 0)
+      /* CYGNUS LOCAL alias/law */
+      if (load_killed_in_block_p (BLOCK_NUM (insn), INSN_CUID (insn), x, 0))
 	return 0;
-      else
-	return oprs_not_set_p (XEXP (x, 0), insn);
+
+      /* There is no conflict for the memory locations.  Now check that the
+	 address itself has not changed.  */
+      return oprs_not_set_p (XEXP (x, 0), insn);
+      /* END CYGNUS LOCAL */
 
     case REG:
       return ! TEST_BIT (reg_set_bitmap, REGNO (x));
@@ -2422,7 +2585,10 @@ static void
 mark_call (insn)
      rtx insn;
 {
-  mem_last_set = INSN_CUID (insn);
+  /* CYGNUS LOCAL alias/law */
+  if (! CONST_CALL_P (insn))
+    record_last_mem_set_info (insn);
+  /* END CYGNUS LOCAL */
 }
 
 /* Mark things set by a SET.  */
@@ -2439,10 +2605,12 @@ mark_set (pat, insn)
 	 || GET_CODE (dest) == STRICT_LOW_PART)
     dest = XEXP (dest, 0);
 
+  /* CYGNUS LOCAL alias/law */
   if (GET_CODE (dest) == REG)
     SET_BIT (reg_set_bitmap, REGNO (dest));
   else if (GET_CODE (dest) == MEM)
-    mem_last_set = INSN_CUID (insn);
+    record_last_mem_set_info (insn);
+  /* END CYGNUS LOCAL */
 
   if (GET_CODE (SET_SRC (pat)) == CALL)
     mark_call (insn);
@@ -2459,10 +2627,12 @@ mark_clobber (pat, insn)
   while (GET_CODE (clob) == SUBREG || GET_CODE (clob) == STRICT_LOW_PART)
     clob = XEXP (clob, 0);
 
+  /* CYGNUS LOCAL alias/law */
   if (GET_CODE (clob) == REG)
     SET_BIT (reg_set_bitmap, REGNO (clob));
   else
-    mem_last_set = INSN_CUID (insn);
+    record_last_mem_set_info (insn);
+  /* END CYGNUS LOCAL */
 }
 
 /* Record things set by INSN.
@@ -2709,10 +2879,14 @@ expr_killed_p (x, bb)
       return TEST_BIT (reg_set_in_block[bb], REGNO (x));
 
     case MEM:
-      if (mem_set_in_block[bb])
+      /* CYGNUS LOCAL alias/law */
+      if (load_killed_in_block_p (bb, get_max_uid () + 1, x, 0))
 	return 1;
-      else
-	return expr_killed_p (XEXP (x, 0), bb);
+
+      /* There is no conflict for the memory locations.  Now check that the
+	 address itself has not changed.  */
+      return expr_killed_p (XEXP (x, 0), bb);
+      /* END CYGNUS LOCAL */
 
     case PC:
     case CC0: /*FIXME*/
@@ -3376,21 +3550,46 @@ compute_transp (x, indx, bmap, set_p)
       return;
 
     case MEM:
-      if (set_p)
-	{
-	  for (bb = 0; bb < n_basic_blocks; bb++)
-	    if (mem_set_in_block[bb])
-	      SET_BIT (bmap[bb], indx);
-	}
-      else
+      /* CYGNUS LOCAL alias/law */
+      for (bb = 0; bb < n_basic_blocks; bb++)
 	{
-	  for (bb = 0; bb < n_basic_blocks; bb++)
-	    if (mem_set_in_block[bb])
-	      RESET_BIT (bmap[bb], indx);
+	  rtx list_entry = modify_mem_list[bb];
+
+	  while (list_entry)
+	    {
+	      if (GET_CODE (XEXP (list_entry, 0)) == CALL_INSN)
+		{
+		  if (set_p)
+		    SET_BIT (bmap[bb], indx);
+		  else
+		    RESET_BIT (bmap[bb], indx);
+		  break;
+		}
+	      /* LIST_ENTRY must be an INSN of some kind that sets memory.
+		 Call note_stores to examine each hunk of memory that is
+		 modified. 
+
+		 The note_stores interface is pretty limited, so we have to
+		 communicate via global variables.  Yuk.  */
+	      gcse_mem_operand = x;
+	      gcse_mems_conflict_p = 0;
+	      note_stores (PATTERN (XEXP (list_entry, 0)),
+			   mems_conflict_for_gcse_p, NULL);
+	      if (gcse_mems_conflict_p)
+		{
+		  if (set_p)
+		    SET_BIT (bmap[bb], indx);
+		  else
+		    RESET_BIT (bmap[bb], indx);
+		  break;
+		}
+	      list_entry = XEXP (list_entry, 1);
+	    }
 	}
 
       x = XEXP (x, 0);
       goto repeat;
+      /* END CYGNUS LOCAL */
 
     case PC:
     case CC0: /*FIXME*/
@@ -3564,7 +3763,10 @@ try_replace_reg (from, to, insn)
      information.  */
   if (!success && !note)
     {
-      if (!set)
+      /* Don't add a REG_EQUAL note for a CCmode destination, because this
+	 confuses the code in cse.c that simplifies compare and branch
+	 instructions.  */
+      if (!set || GET_MODE_CLASS (GET_MODE (SET_DEST (set))) == MODE_CC)
 	return 0;
 
       note = REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,
--- gcc/haifa-sched.c.jj	Sat Feb  3 23:47:50 2001
+++ gcc/haifa-sched.c	Mon Feb  5 18:17:19 2001
@@ -1232,7 +1232,7 @@ do { register bitset tmpset = set;      
     abort ();                                                        \
   else                                                               \
     set[index/HOST_BITS_PER_WIDE_INT] |=			     \
-      1 << (index % HOST_BITS_PER_WIDE_INT);                         \
+      ((unsigned HOST_WIDE_INT) 1) << (index % HOST_BITS_PER_WIDE_INT); \
 }
 
 /* Turn off the index'th bit in set.  */
@@ -1242,7 +1242,7 @@ do { register bitset tmpset = set;      
     abort ();                                                        \
   else                                                               \
     set[index/HOST_BITS_PER_WIDE_INT] &=			     \
-      ~(1 << (index%HOST_BITS_PER_WIDE_INT));                        \
+      ~(((unsigned HOST_WIDE_INT) 1) << (index % HOST_BITS_PER_WIDE_INT)); \
 }
 
 
@@ -1255,8 +1255,9 @@ bitset_member (set, index, len)
 {
   if (index >= HOST_BITS_PER_WIDE_INT * len)
     abort ();
-  return (set[index / HOST_BITS_PER_WIDE_INT] &
-	  1 << (index % HOST_BITS_PER_WIDE_INT)) ? 1 : 0;
+  return ((set[index / HOST_BITS_PER_WIDE_INT] &
+	   ((unsigned HOST_WIDE_INT) 1) << (index % HOST_BITS_PER_WIDE_INT))
+	  ? 1 : 0);
 }
 
 
@@ -1986,12 +1987,26 @@ compute_trg_info (trg)
 
       if (sp->is_valid)
 	{
+	  char *update_blocks;
+
+	  /* Compute split blocks and store them in bblst_table.
+	     The TO block of every split edge is a split block.  */
 	  sp->split_bbs.first_member = &bblst_table[bblst_last];
 	  sp->split_bbs.nr_members = el.nr_members;
 	  for (j = 0; j < el.nr_members; bblst_last++, j++)
 	    bblst_table[bblst_last] =
 	      TO_BLOCK (rgn_edges[el.first_member[j]]);
 	  sp->update_bbs.first_member = &bblst_table[bblst_last];
+
+	  /* Compute update blocks and store them in bblst_table.
+	     For every split edge, look at the FROM block, and check
+	     all out edges.  For each out edge that is not a split edge,
+	     add the TO block to the update block list.  This list can end
+	     up with a lot of duplicates.  We need to weed them out to avoid
+	     overrunning the end of the bblst_table.  */
+	  update_blocks = (char *) alloca (n_basic_blocks);
+	  bzero (update_blocks, n_basic_blocks);
+
 	  update_idx = 0;
 	  for (j = 0; j < el.nr_members; j++)
 	    {
@@ -1999,14 +2014,18 @@ compute_trg_info (trg)
 	      fst_edge = nxt_edge = OUT_EDGES (check_block);
 	      do
 		{
-		  for (k = 0; k < el.nr_members; k++)
-		    if (EDGE_TO_BIT (nxt_edge) == el.first_member[k])
-		      break;
-
-		  if (k >= el.nr_members)
+		  if (! update_blocks[TO_BLOCK (nxt_edge)])
 		    {
-		      bblst_table[bblst_last++] = TO_BLOCK (nxt_edge);
-		      update_idx++;
+		      for (k = 0; k < el.nr_members; k++)
+			if (EDGE_TO_BIT (nxt_edge) == el.first_member[k])
+			  break;
+
+		      if (k >= el.nr_members)
+			{
+			  bblst_table[bblst_last++] = TO_BLOCK (nxt_edge);
+			  update_blocks[TO_BLOCK (nxt_edge)] = 1;
+			  update_idx++;
+			}
 		    }
 
 		  nxt_edge = NEXT_OUT (nxt_edge);
@@ -2015,6 +2034,9 @@ compute_trg_info (trg)
 	    }
 	  sp->update_bbs.nr_members = update_idx;
 
+	  /* Make sure we didn't overrun the end of bblst_table.  */
+	  if (bblst_last > bblst_size)
+	    abort ();
 	}
       else
 	{
@@ -5868,12 +5890,11 @@ schedule_block (bb, rgn_n_insns)
 					       * sizeof (candidate));
 
       bblst_last = 0;
-      /* ??? It is not clear why bblst_size is computed this way.  The original
-	 number was clearly too small as it resulted in compiler failures.
-	 Multiplying by the original number by 2 (to account for update_bbs
-	 members) seems to be a reasonable solution.  */
-      /* ??? Or perhaps there is a bug somewhere else in this file?  */
-      bblst_size = (current_nr_blocks - bb) * rgn_nr_edges * 2;
+      /* bblst_table holds split blocks and update blocks for each block after
+	 the current one in the region.  split blocks and update blocks are
+	 the TO blocks of region edges, so there can be at most rgn_nr_edges
+	 of them.  */
+      bblst_size = (current_nr_blocks - bb) * rgn_nr_edges;
       bblst_table = (int *) xmalloc (bblst_size * sizeof (int));
 
       bitlst_table_last = 0;
@@ -6998,8 +7019,7 @@ schedule_insns (dump_file)
 	  && GET_CODE (insn) != CODE_LABEL
 	  /* Don't emit a NOTE if it would end up between an unconditional
 	     jump and a BARRIER.  */
-	  && !(GET_CODE (insn) == JUMP_INSN
-	       && GET_CODE (NEXT_INSN (insn)) == BARRIER)))
+	  && ! GET_CODE (NEXT_INSN (insn)) == BARRIER))
     emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));
 
   /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before
--- gcc/ifcvt.c.jj	Fri Jun 16 13:10:29 2000
+++ gcc/ifcvt.c	Mon Feb  5 14:56:13 2001
@@ -1247,6 +1247,11 @@ noce_process_if_block (test_bb, then_bb,
 	  reorder_insns (insn_b, insn_b, PREV_INSN (if_info.cond_earliest));
 	  insn_b = NULL_RTX;
 	}
+      /* If we have "x = b; if (...) x = a;", and x has side-effects, then
+	 x must be executed twice.  */
+      else if (insn_b && side_effects_p (orig_x))
+	return FALSE;
+	
       x = orig_x;
       goto success;
     }
--- gcc/libgcc2.c.jj	Tue Jul 11 10:32:15 2000
+++ gcc/libgcc2.c	Mon Feb  5 15:52:21 2001
@@ -4046,10 +4046,8 @@ __ia64_personality_v1 (void *pc, old_exc
 }
 
 static void
-ia64_throw_helper (throw_frame, caller, throw_bsp)
-     ia64_frame_state *throw_frame;
-     ia64_frame_state *caller;
-     void *throw_bsp;
+ia64_throw_helper (ia64_frame_state *throw_frame, ia64_frame_state *caller,
+		   void *throw_bsp, void *throw_sp)
 {
   void *throw_pc = __builtin_return_address (0);
   unwind_info_ptr *info;
@@ -4061,7 +4059,8 @@ ia64_throw_helper (throw_frame, caller, 
   __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */
 
   /* Start at our stack frame, get our state.  */
-  __build_ia64_frame_state (throw_pc, throw_frame, throw_bsp, &pc_base);
+  __build_ia64_frame_state (throw_pc, throw_frame, throw_bsp, throw_sp,
+			    &pc_base);
 
   /* Now we have to find the proper frame for pc, and see if there
      is a handler for it. if not, we keep going back frames until
@@ -4078,8 +4077,10 @@ ia64_throw_helper (throw_frame, caller, 
       /* We only care about the RP right now, so we dont need to keep
          any other information about a call frame right now.  */
       pc = __get_real_reg_value (&caller->rp) - 1;
-      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs), caller->my_bsp);
-      info = __build_ia64_frame_state (pc, caller, bsp, &pc_base);
+      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs),
+			       caller->my_bsp);
+      info = __build_ia64_frame_state (pc, caller, bsp, caller->my_psp,
+				       &pc_base);
 
       /* If we couldn't find the next frame, we lose.  */
       if (! info)
@@ -4099,7 +4100,7 @@ ia64_throw_helper (throw_frame, caller, 
     }
   
   if (!handler)
-   __terminate ();
+    __terminate ();
 
   /* Handler is a segment relative address, so we must adjust it here.  */
   handler += (long) pc_base;
@@ -4116,8 +4117,9 @@ ia64_throw_helper (throw_frame, caller, 
   for ( ; frame_count > 0; frame_count--)
     {
       pc = __get_real_reg_value (&caller->rp) - 1;
-      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs), caller->my_bsp);
-      __build_ia64_frame_state (pc, caller, bsp, &pc_base);
+      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs),
+			       caller->my_bsp);
+      __build_ia64_frame_state (pc, caller, bsp, caller->my_psp, &pc_base);
       /* Any regs that were saved can be put in the throw frame now.  */
       /* We don't want to copy any saved register from the 
          target destination, but we do want to load up it's frame.  */
@@ -4130,12 +4132,13 @@ ia64_throw_helper (throw_frame, caller, 
 
   /* TODO, do we need to do anything to make the values we wrote 'stick'? */
   /* DO we need to go through the whole loadrs seqeunce?  */
-
 }
 
+
 void
 __throw ()
 {
+  register void *stack_pointer __asm__("r12");
   struct eh_context *eh = (*get_eh_context) ();
   ia64_frame_state my_frame;
   ia64_frame_state originator;	/* For the context handler is in.  */
@@ -4149,6 +4152,7 @@ __throw ()
     __terminate ();
 
   __builtin_unwind_init ();
+
   /* We have to call another routine to actually process the frame 
      information, which will force all of __throw's local registers into
      backing store.  */
@@ -4156,7 +4160,7 @@ __throw ()
   /* Get the value of ar.bsp while we're here.  */
 
   bsp = __builtin_ia64_bsp ();
-  ia64_throw_helper (&my_frame, &originator, bsp);
+  ia64_throw_helper (&my_frame, &originator, bsp, stack_pointer);
 
   /* Now we have to fudge the bsp by the amount in our (__throw)
      frame marker, since the return is going to adjust it by that much. */
@@ -4165,11 +4169,6 @@ __throw ()
 			     my_frame.my_bsp);
   offset = (char *)my_frame.my_bsp - (char *)tmp_bsp;
   tmp_bsp = (char *)originator.my_bsp + offset;
-
-  /* A throw handler is trated like a  non-local goto, which is architeched
-     to set the FP (or PSP) in r7 before branching.  gr[0-3] map to 
-     r4-r7, so we want gr[3].  */
-  __set_real_reg_value (&my_frame.gr[3], __get_real_reg_value (&originator.psp));
 
   __builtin_eh_return (tmp_bsp, offset, originator.my_sp);
 
--- gcc/loop.c.jj	Sat Feb  3 23:48:05 2001
+++ gcc/loop.c	Mon Feb  5 17:22:57 2001
@@ -270,17 +270,20 @@ static void record_biv PARAMS ((struct i
 static void check_final_value PARAMS ((const struct loop *,
 				       struct induction *));
 static void record_giv PARAMS ((const struct loop *, struct induction *, 
-				rtx, rtx, rtx, rtx, rtx, int, enum g_types, 
-				int, int, rtx *));
+				rtx, rtx, rtx, rtx, rtx, rtx, int,
+				enum g_types, int, int, rtx *));
 static void update_giv_derive PARAMS ((const struct loop *, rtx));
+static void check_ext_dependant_givs PARAMS ((struct iv_class *,
+					      struct loop_info *));
 static int basic_induction_var PARAMS ((const struct loop *, rtx, 
 					enum machine_mode, rtx, rtx,
 					rtx *, rtx *, rtx **));
-static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, int *));
+static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, rtx *, int *));
 static int general_induction_var PARAMS ((const struct loop *loop, rtx, rtx *,
-					  rtx *, rtx *, int, int *, enum machine_mode));
+					  rtx *, rtx *, rtx *, int, int *,
+					  enum machine_mode));
 static int consec_sets_giv PARAMS ((const struct loop *, int, rtx,
-				    rtx, rtx, rtx *, rtx *, rtx *));
+				    rtx, rtx, rtx *, rtx *, rtx *, rtx *));
 static int check_dbra_loop PARAMS ((struct loop *, int));
 static rtx express_from_1 PARAMS ((rtx, rtx, rtx));
 static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));
@@ -4060,7 +4063,11 @@ strength_reduce (loop, insn_count, flags
 	    }
 	
 	  /* Now, can we transform this biv into a giv?  */
-	  if (bl2
+	  /* This transformation breaks the loop unrolling code.  In
+	     calculate_giv_inc, it is unable to compute the increment for
+	     this newly created giv.  This code was removed from FSF gcc
+	     sources, so it is OK to disable it.  */
+	  if (0 && bl2
 	      && bl2->biv_count == 1
 	      && rtx_equal_p (increment, biv_total_increment (bl2))
 	      /* init_insn is only set to insns that are before loop_start
@@ -4483,6 +4490,10 @@ strength_reduce (loop, insn_count, flags
 	    }
 	}
 
+      /* Check each extension dependant giv in this class to see if its
+	 root biv is safe from wrapping in the interior mode.  */
+      check_ext_dependant_givs (bl, loop_info);
+
       /* Combine all giv's for this iv_class.  */
       combine_givs (bl);
 
@@ -4791,8 +4802,9 @@ strength_reduce (loop, insn_count, flags
 
 	      /* Add code at loop start to initialize giv's reduced reg.  */
 
-	      emit_iv_add_mult (bl->initial_value, v->mult_val,
-				v->add_val, v->new_reg, loop_start);
+	      emit_iv_add_mult (extend_value_for_giv (v, bl->initial_value),
+				v->mult_val, v->add_val, v->new_reg,
+				loop_start);
 	    }
 	}
 
@@ -4857,8 +4869,9 @@ strength_reduce (loop, insn_count, flags
 	     not replaceable.  The correct final value is the same as the
 	     value that the giv starts the reversed loop with.  */
 	  if (bl->reversed && ! v->replaceable)
-	    emit_iv_add_mult (bl->initial_value, v->mult_val,
-			      v->add_val, v->dest_reg, end_insert_before);
+	    emit_iv_add_mult (extend_value_for_giv (v, bl->initial_value),
+			      v->mult_val, v->add_val, v->dest_reg,
+			      end_insert_before);
 	  else if (v->final_value)
 	    {
 	      rtx insert_before;
@@ -5115,6 +5128,7 @@ check_insn_for_givs (loop, p, not_every_
       rtx dest_reg;
       rtx add_val;
       rtx mult_val;
+      rtx ext_val;
       int benefit;
       rtx regnote = 0;
       rtx last_consec_insn;
@@ -5125,11 +5139,11 @@ check_insn_for_givs (loop, p, not_every_
 
       if (/* SET_SRC is a giv.  */
 	  (general_induction_var (loop, SET_SRC (set), &src_reg, &add_val,
-				  &mult_val, 0, &benefit, VOIDmode)
+				  &mult_val, &ext_val, 0, &benefit, VOIDmode)
 	   /* Equivalent expression is a giv.  */
 	   || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))
 	       && general_induction_var (loop, XEXP (regnote, 0), &src_reg,
-					 &add_val, &mult_val, 0,
+					 &add_val, &mult_val, &ext_val, 0,
 					 &benefit, VOIDmode)))
 	  /* Don't try to handle any regs made by loop optimization.
 	     We have nothing on them in regno_first_uid, etc.  */
@@ -5141,7 +5155,7 @@ check_insn_for_givs (loop, p, not_every_
 	      /* or all sets must be consecutive and make a giv.  */
 	      || (benefit = consec_sets_giv (loop, benefit, p,
 					     src_reg, dest_reg,
-					     &add_val, &mult_val,
+					     &add_val, &mult_val, &ext_val,
 					     &last_consec_insn))))
 	{
 	  struct induction *v
@@ -5156,7 +5170,7 @@ check_insn_for_givs (loop, p, not_every_
 	    p = last_consec_insn;
 
 	  record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,
-		      benefit, DEST_REG, not_every_iteration,
+		      ext_val, benefit, DEST_REG, not_every_iteration,
 		      maybe_multiple, NULL_PTR);
 
 	}
@@ -5260,6 +5274,7 @@ find_mem_givs (loop, x, insn, not_every_
 	rtx src_reg;
 	rtx add_val;
 	rtx mult_val;
+	rtx ext_val;
 	int benefit;
 
 	/* This code used to disable creating GIVs with mult_val == 1 and
@@ -5268,15 +5283,16 @@ find_mem_givs (loop, x, insn, not_every_
 	   this one would not be seen.   */
 
 	if (general_induction_var (loop, XEXP (x, 0), &src_reg, &add_val,
-				   &mult_val, 1, &benefit, GET_MODE (x)))
+				   &mult_val, &ext_val, 1, &benefit,
+				   GET_MODE (x)))
 	  {
 	    /* Found one; record it.  */
 	    struct induction *v
 	      = (struct induction *) oballoc (sizeof (struct induction));
 
 	    record_giv (loop, v, insn, src_reg, addr_placeholder, mult_val,
-			add_val, benefit, DEST_ADDR, not_every_iteration,
-			maybe_multiple, &XEXP (x, 0));
+			add_val, ext_val, benefit, DEST_ADDR,
+			not_every_iteration, maybe_multiple, &XEXP (x, 0));
 
 	    v->mem_mode = GET_MODE (x);
 	  }
@@ -5335,6 +5351,7 @@ record_biv (v, insn, dest_reg, inc_val, 
   v->dest_reg = dest_reg;
   v->mult_val = mult_val;
   v->add_val = inc_val;
+  v->ext_dependant = NULL_RTX;
   v->location = location;
   v->mode = GET_MODE (dest_reg);
   v->always_computable = ! not_every_iteration;
@@ -5418,14 +5435,14 @@ record_biv (v, insn, dest_reg, inc_val, 
    LOCATION points to the place where this giv's value appears in INSN.  */
 
 static void
-record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, benefit,
-	    type, not_every_iteration, maybe_multiple, location)
+record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,
+	    benefit, type, not_every_iteration, maybe_multiple, location)
      const struct loop *loop;
      struct induction *v;
      rtx insn;
      rtx src_reg;
      rtx dest_reg;
-     rtx mult_val, add_val;
+     rtx mult_val, add_val, ext_val;
      int benefit;
      enum g_types type;
      int not_every_iteration, maybe_multiple;
@@ -5447,6 +5464,7 @@ record_giv (loop, v, insn, src_reg, dest
   v->dest_reg = dest_reg;
   v->mult_val = mult_val;
   v->add_val = add_val;
+  v->ext_dependant = ext_val;
   v->benefit = benefit;
   v->location = location;
   v->cant_derive = 0;
@@ -5635,6 +5653,27 @@ record_giv (loop, v, insn, src_reg, dest
       if (v->no_const_addval)
 	fprintf (loop_dump_stream, " ncav");
 
+      if (v->ext_dependant)
+	{
+	  switch (GET_CODE (v->ext_dependant))
+	    {
+	    case SIGN_EXTEND:
+	      fprintf (loop_dump_stream, " ext se");
+	      break;
+	    case ZERO_EXTEND:
+	      fprintf (loop_dump_stream, " ext ze");
+	      break;
+	    case SUBREG:
+	      fprintf (loop_dump_stream, " ext sr");
+	      break;
+	    case TRUNCATE:
+	      fprintf (loop_dump_stream, " ext tr");
+	      break;
+	    default:
+	      abort ();
+	    }
+	}
+
       if (GET_CODE (mult_val) == CONST_INT)
 	{
 	  fprintf (loop_dump_stream, " mult ");
@@ -5744,19 +5783,25 @@ check_final_value (loop, v)
 	  if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN
 	      || GET_CODE (p) == CALL_INSN)
 	    {
-	      if (biv_increment_seen || before_giv_insn)
+	      /* It is possible for the BIV increment to use the GIV if we
+		 have a cycle.  Thus we must be sure to check each insn for
+		 both BIV and GIV uses, and we must check for BIV uses
+		 first.  */
+
+	      if (! biv_increment_seen
+		  && reg_set_p (v->src_reg, PATTERN (p)))
+		biv_increment_seen = 1;
+
+	      if (reg_mentioned_p (v->dest_reg, PATTERN (p)))
 		{
-		  if (reg_mentioned_p (v->dest_reg, PATTERN (p)))
+		  if (biv_increment_seen)
 		    {
 		      v->replaceable = 0;
 		      v->not_replaceable = 1;
 		      break;
 		    }
-		}
-	      else if (reg_set_p (v->src_reg, PATTERN (p)))
-		biv_increment_seen = 1;
-	      else if (reg_mentioned_p (v->dest_reg, PATTERN (p)))
-		last_giv_use = p;
+		  last_giv_use = p;
+		}                                                                                                                          
 	    }
 	}
       
@@ -5882,20 +5927,21 @@ update_giv_derive (loop, p)
 		 be able to compute a compensation.  */
 	      else if (biv->insn == p)
 		{
-		  tem = 0;
+		  rtx ext_val_dummy;
 
+		  tem = 0;
 		  if (biv->mult_val == const1_rtx)
 		    tem = simplify_giv_expr (loop,
 					     gen_rtx_MULT (giv->mode,
 							   biv->add_val,
 							   giv->mult_val),
-					     &dummy);
+					     &ext_val_dummy, &dummy);
 
 		  if (tem && giv->derive_adjustment)
 		    tem = simplify_giv_expr
 		      (loop,
 		       gen_rtx_PLUS (giv->mode, tem, giv->derive_adjustment),
-		       &dummy);
+		       &ext_val_dummy, &dummy);
 
 		  if (tem)
 		    giv->derive_adjustment = tem;
@@ -6113,13 +6159,14 @@ basic_induction_var (loop, x, mode, dest
      such that the value of X is biv * mult + add;  */
 
 static int
-general_induction_var (loop, x, src_reg, add_val, mult_val, is_addr,
-		       pbenefit, addr_mode)
+general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,
+		       is_addr, pbenefit, addr_mode)
      const struct loop *loop;
      rtx x;
      rtx *src_reg;
      rtx *add_val;
      rtx *mult_val;
+     rtx *ext_val;
      int is_addr;
      int *pbenefit;
      enum machine_mode addr_mode;
@@ -6135,7 +6182,8 @@ general_induction_var (loop, x, src_reg,
      Mark our place on the obstack in case we don't find a giv.  */
   storage = (char *) oballoc (0);
   *pbenefit = 0;
-  x = simplify_giv_expr (loop, x, pbenefit);
+  *ext_val = NULL_RTX;
+  x = simplify_giv_expr (loop, x, ext_val, pbenefit);
   if (x == 0)
     {
       obfree (storage);
@@ -6232,9 +6280,10 @@ static int cmp_combine_givs_stats PARAMS
 static int cmp_recombine_givs_stats PARAMS ((const PTR, const PTR));
 
 static rtx
-simplify_giv_expr (loop, x, benefit)
+simplify_giv_expr (loop, x, ext_val, benefit)
      const struct loop *loop;
      rtx x;
+     rtx *ext_val;
      int *benefit;
 {
   enum machine_mode mode = GET_MODE (x);
@@ -6251,8 +6300,8 @@ simplify_giv_expr (loop, x, benefit)
   switch (GET_CODE (x))
     {
     case PLUS:
-      arg0 = simplify_giv_expr (loop, XEXP (x, 0), benefit);
-      arg1 = simplify_giv_expr (loop, XEXP (x, 1), benefit);
+      arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);
+      arg1 = simplify_giv_expr (loop, XEXP (x, 1), ext_val, benefit);
       if (arg0 == 0 || arg1 == 0)
 	return NULL_RTX;
 
@@ -6304,7 +6353,7 @@ simplify_giv_expr (loop, x, benefit)
 					       gen_rtx_PLUS (mode,
 							     XEXP (arg0, 1),
 							     arg1)),
-				 benefit);
+				 ext_val, benefit);
 
 	  default:
 	    abort ();
@@ -6330,7 +6379,7 @@ simplify_giv_expr (loop, x, benefit)
 					     gen_rtx_PLUS (mode, arg0,
 							   XEXP (arg1, 0)),
 					     XEXP (arg1, 1)),
-			       benefit);
+			       ext_val, benefit);
 
       /* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */
       if (GET_CODE (arg0) != MULT || GET_CODE (arg1) != MULT)
@@ -6345,7 +6394,7 @@ simplify_giv_expr (loop, x, benefit)
 					      gen_rtx_PLUS (mode,
 							    XEXP (arg0, 1),
 							    XEXP (arg1, 1))),
-				benefit);
+				ext_val, benefit);
 
     case MINUS:
       /* Handle "a - b" as "a + b * (-1)".  */
@@ -6355,11 +6404,11 @@ simplify_giv_expr (loop, x, benefit)
 					      gen_rtx_MULT (mode,
 							    XEXP (x, 1),
 							    constm1_rtx)),
-				benefit);
+				ext_val, benefit);
 
     case MULT:
-      arg0 = simplify_giv_expr (loop, XEXP (x, 0), benefit);
-      arg1 = simplify_giv_expr (loop, XEXP (x, 1), benefit);
+      arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);
+      arg1 = simplify_giv_expr (loop, XEXP (x, 1), ext_val, benefit);
       if (arg0 == 0 || arg1 == 0)
 	return NULL_RTX;
 
@@ -6405,7 +6454,7 @@ simplify_giv_expr (loop, x, benefit)
 								    XEXP (arg0,
 									  1),
 								    arg1)),
-					benefit);
+					ext_val, benefit);
 	    }
 	  /* Porpagate the MULT expressions to the intermost nodes.  */
 	  else if (GET_CODE (arg0) == PLUS)
@@ -6421,7 +6470,7 @@ simplify_giv_expr (loop, x, benefit)
 								    XEXP (arg0,
 									  1),
 								    arg1)),
-					benefit);
+					ext_val, benefit);
 	    }
 	  return gen_rtx_USE (mode, gen_rtx_MULT (mode, arg0, arg1));
 
@@ -6433,7 +6482,7 @@ simplify_giv_expr (loop, x, benefit)
 						  gen_rtx_MULT (mode,
 								XEXP (arg0, 1),
 								arg1)),
-				    benefit);
+				    ext_val, benefit);
 
 	case PLUS:
 	  /* (a + invar_1) * invar_2.  Distribute.  */
@@ -6445,7 +6494,7 @@ simplify_giv_expr (loop, x, benefit)
 						  gen_rtx_MULT (mode,
 								XEXP (arg0, 1),
 								arg1)),
-				    benefit);
+				    ext_val, benefit);
 
 	default:
 	  abort ();
@@ -6462,13 +6511,13 @@ simplify_giv_expr (loop, x, benefit)
 					 XEXP (x, 0),
 					 GEN_INT ((HOST_WIDE_INT) 1
 						  << INTVAL (XEXP (x, 1)))),
-			   benefit);
+			   ext_val, benefit);
 
     case NEG:
       /* "-a" is "a * (-1)" */
       return simplify_giv_expr (loop,
 				gen_rtx_MULT (mode, XEXP (x, 0), constm1_rtx),
-				benefit);
+				ext_val, benefit);
 
     case NOT:
       /* "~a" is "-a - 1". Silly, but easy.  */
@@ -6476,13 +6525,45 @@ simplify_giv_expr (loop, x, benefit)
 				gen_rtx_MINUS (mode,
 					       gen_rtx_NEG (mode, XEXP (x, 0)),
 					       const1_rtx),
-				benefit);
+				ext_val, benefit);
 
     case USE:
       /* Already in proper form for invariant.  */
       return x;
 
-    case REG:
+    case SUBREG:
+      /* Conditionally recognize extensions of simple IVs.  After we've
+	 computed loop traversal counts and verified the range of the 
+	 source IV, we'll reevaluate this as a GIV.  */
+      if (subreg_lowpart_p (x) && *ext_val == NULL_RTX)
+	{
+	  arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);
+	  if (arg0 && *ext_val == NULL_RTX && GET_CODE (arg0) == REG)
+	    {
+	      *ext_val = gen_lowpart_SUBREG (mode, arg0);
+	      return arg0;
+	    }
+	}
+      goto do_default;
+
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
+    case TRUNCATE:
+      /* Conditionally recognize extensions of simple IVs.  After we've
+	 computed loop traversal counts and verified the range of the 
+	 source IV, we'll reevaluate this as a GIV.  */
+      if (*ext_val == NULL_RTX)
+	{
+	  arg0 = simplify_giv_expr (loop, XEXP (x, 0), ext_val, benefit);
+	  if (arg0 && *ext_val == NULL_RTX && GET_CODE (arg0) == REG)
+	    {
+	      *ext_val = gen_rtx_fmt_e (GET_CODE (x), mode, arg0);
+	      return arg0;
+	    }
+	}
+      goto do_default;
+
+  case REG:
       /* If this is a new register, we can't deal with it.  */
       if (REGNO (x) >= max_reg_before_loop)
 	return 0;
@@ -6508,10 +6589,22 @@ simplify_giv_expr (loop, x, benefit)
 
 	    if (v->derive_adjustment)
 	      tem = gen_rtx_MINUS (mode, tem, v->derive_adjustment);
-	    return simplify_giv_expr (loop, tem, benefit);
+	    arg0 = simplify_giv_expr (loop, tem, ext_val, benefit);
+	    if (*ext_val)
+	      {
+		if (!v->ext_dependant)
+		  return arg0;
+	      }
+	    else
+	      {
+		*ext_val = v->ext_dependant;
+		return arg0;
+	      }
+	    return 0;
 	  }
 
 	default:
+	do_default:
 	  /* If it isn't an induction variable, and it is invariant, we
 	     may be able to simplify things further by looking through
 	     the bits we just moved outside the loop.  */
@@ -6528,7 +6621,7 @@ simplify_giv_expr (loop, x, benefit)
 		       this one is going away.  */
 		    if (m->match)
 		      return simplify_giv_expr (loop, m->match->set_dest, 
-						benefit);
+						ext_val, benefit);
 
 		    /* If consec is non-zero, this is a member of a group of
 		       instructions that were moved together.  We handle this
@@ -6562,7 +6655,8 @@ simplify_giv_expr (loop, x, benefit)
 			    || GET_CODE (tem) == CONST_INT
 			    || GET_CODE (tem) == SYMBOL_REF)
 			  {
-			    tem = simplify_giv_expr (loop, tem, benefit);
+			    tem = simplify_giv_expr (loop, tem, ext_val,
+						     benefit);
 			    if (tem)
 			      return tem;
 			  }
@@ -6572,7 +6666,7 @@ simplify_giv_expr (loop, x, benefit)
 			    && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)
 			  {
 			    tem = simplify_giv_expr (loop, XEXP (tem, 0),
-						     benefit);
+						     ext_val, benefit);
 			    if (tem)
 			      return tem;
 			  }
@@ -6677,7 +6771,7 @@ sge_plus (mode, x, y)
 
 static int
 consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,
-		 add_val, mult_val, last_consec_insn)
+		 add_val, mult_val, ext_val, last_consec_insn)
      const struct loop *loop;
      int first_benefit;
      rtx p;
@@ -6685,6 +6779,7 @@ consec_sets_giv (loop, first_benefit, p,
      rtx dest_reg;
      rtx *add_val;
      rtx *mult_val;
+     rtx *ext_val;
      rtx *last_consec_insn;
 {
   int count;
@@ -6708,6 +6803,7 @@ consec_sets_giv (loop, first_benefit, p,
   v->benefit = first_benefit;
   v->cant_derive = 0;
   v->derive_adjustment = 0;
+  v->ext_dependant = NULL_RTX;
 
   REG_IV_TYPE (REGNO (dest_reg)) = GENERAL_INDUCT;
   REG_IV_INFO (REGNO (dest_reg)) = v;
@@ -6728,12 +6824,13 @@ consec_sets_giv (loop, first_benefit, p,
 	  && GET_CODE (SET_DEST (set)) == REG
 	  && SET_DEST (set) == dest_reg
 	  && (general_induction_var (loop, SET_SRC (set), &src_reg,
-				     add_val, mult_val, 0, &benefit, VOIDmode)
+				     add_val, mult_val, ext_val, 0,
+				     &benefit, VOIDmode)
 	      /* Giv created by equivalent expression.  */
 	      || ((temp = find_reg_note (p, REG_EQUAL, NULL_RTX))
 		  && general_induction_var (loop, XEXP (temp, 0), &src_reg,
-					    add_val, mult_val, 0, &benefit,
-					    VOIDmode)))
+					    add_val, mult_val, ext_val, 0,
+					    &benefit, VOIDmode)))
 	  && src_reg == v->src_reg)
 	{
 	  if (find_reg_note (p, REG_RETVAL, NULL_RTX))
@@ -6964,25 +7061,36 @@ static rtx
 combine_givs_p (g1, g2)
      struct induction *g1, *g2;
 {
-  rtx tem = express_from (g1, g2);
+  rtx comb, ret;
+
+  /* With the introduction of ext dependant givs, we must care for modes.
+     G2 must not use a wider mode than G1.  */
+  if (GET_MODE_SIZE (g1->mode) < GET_MODE_SIZE (g2->mode))
+    return NULL_RTX;
+
+  ret = comb = express_from (g1, g2);
+  if (comb == NULL_RTX)
+    return NULL_RTX;
+  if (g1->mode != g2->mode)
+    ret = gen_lowpart (g2->mode, comb);
 
   /* If these givs are identical, they can be combined.  We use the results
      of express_from because the addends are not in a canonical form, so
      rtx_equal_p is a weaker test.  */
   /* But don't combine a DEST_REG giv with a DEST_ADDR giv; we want the
      combination to be the other way round.  */
-  if (tem == g1->dest_reg
+  if (comb == g1->dest_reg
       && (g1->giv_type == DEST_REG || g2->giv_type == DEST_ADDR))
     {
-      return g1->dest_reg;
+      return ret;
     }
 
   /* If G2 can be expressed as a function of G1 and that function is valid
      as an address and no more expensive than using a register for G2,
      the expression of G2 in terms of G1 can be used.  */
-  if (tem != NULL_RTX
+  if (ret != NULL_RTX
       && g2->giv_type == DEST_ADDR
-      && memory_address_p (g2->mem_mode, tem)
+      && memory_address_p (g2->mem_mode, ret)
       /* ??? Looses, especially with -fforce-addr, where *g2->location
 	 will always be a register, and so anything more complicated
 	 gets discarded.  */
@@ -6995,12 +7103,190 @@ combine_givs_p (g1, g2)
 #endif
       )
     {
-      return tem;
+      return ret;
     }
 
   return NULL_RTX;
 }
 
+/* Check each extension dependant giv in this class to see if its
+   root biv is safe from wrapping in the interior mode, which would
+   make the giv illegal.  */
+
+static void
+check_ext_dependant_givs (bl, loop_info)
+     struct iv_class *bl;
+     struct loop_info *loop_info;
+{
+  int ze_ok = 0, se_ok = 0, info_ok = 0;
+  enum machine_mode biv_mode = GET_MODE (bl->biv->src_reg);
+  HOST_WIDE_INT start_val;
+  unsigned HOST_WIDE_INT u_end_val, u_start_val;
+  rtx incr;
+  struct induction *v;
+
+  /* Make sure the iteration data is available.  We must have
+     constants in order to be certain of no overflow.  */
+  /* ??? An unknown iteration count with an increment of +-1
+     combined with friendly exit tests of against an invariant
+     value is also ameanable to optimization.  Not implemented.  */
+  if (loop_info->n_iterations > 0
+      && bl->initial_value
+      && GET_CODE (bl->initial_value) == CONST_INT
+      && (incr = biv_total_increment (bl))
+      && GET_CODE (incr) == CONST_INT
+      /* Make sure the host can represent the arithmetic.  */
+      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (biv_mode))
+    {
+      unsigned HOST_WIDE_INT abs_incr, total_incr;
+      HOST_WIDE_INT s_end_val;
+      int neg_incr;
+
+      info_ok = 1;
+      start_val = INTVAL (bl->initial_value);
+      u_start_val = start_val;
+	   
+      neg_incr = 0, abs_incr = INTVAL (incr);
+      if (INTVAL (incr) < 0)
+	neg_incr = 1, abs_incr = -abs_incr;
+      total_incr = abs_incr * loop_info->n_iterations;
+
+      /* Check for host arithmatic overflow.  */
+      if (total_incr / loop_info->n_iterations == abs_incr)
+	{
+	  unsigned HOST_WIDE_INT u_max;
+	  HOST_WIDE_INT s_max;
+
+	  u_end_val = start_val + (neg_incr ? -total_incr : total_incr);
+	  s_end_val = u_end_val;
+	  u_max = GET_MODE_MASK (biv_mode);
+	  s_max = u_max >> 1;
+		  
+	  /* Check zero extension of biv ok.  */
+	  if (start_val >= 0
+	      /* Check for host arithmatic overflow.  */
+	      && (neg_incr
+		  ? u_end_val < u_start_val
+		  : u_end_val > u_start_val)
+	      /* Check for target arithmetic overflow.  */
+	      && (neg_incr
+		  ? 1 /* taken care of with host overflow */
+		  : u_end_val <= u_max))
+	    {
+	      ze_ok = 1;
+	    }
+		  
+	  /* Check sign extension of biv ok.  */
+	  /* ??? While it is true that overflow with signed and pointer
+	     arithmetic is undefined, I fear too many programmers don't
+	     keep this fact in mind -- myself included on occasion.
+	     So leave alone with the signed overflow optimizations.  */
+	  if (start_val >= -s_max - 1
+	      /* Check for host arithmatic overflow.  */
+	      && (neg_incr
+		  ? s_end_val < start_val
+		  : s_end_val > start_val)
+	      /* Check for target arithmetic overflow.  */
+	      && (neg_incr
+		  ? s_end_val >= -s_max - 1
+		  : s_end_val <= s_max))
+	    {
+	      se_ok = 1;
+	    }
+	}
+    }
+
+  /* Invalidate givs that fail the tests.  */
+  for (v = bl->giv; v; v = v->next_iv)
+    if (v->ext_dependant)
+      {
+	enum rtx_code code = GET_CODE (v->ext_dependant);
+	int ok = 0;
+
+	switch (code)
+	  {
+	  case SIGN_EXTEND:
+	    ok = se_ok;
+	    break;
+	  case ZERO_EXTEND:
+	    ok = ze_ok;
+	    break;
+
+	  case SUBREG:
+	  case TRUNCATE:
+	    /* We don't know whether this value is being used as either
+	       signed or unsigned, so to safely truncate we must satisfy
+	       both.  The initial check here verifies the BIV itself; 
+	       once that is successful we may check its range wrt the
+	       derived GIV.  */
+	    if (se_ok && ze_ok)
+	      {
+		enum machine_mode outer_mode = GET_MODE (v->ext_dependant);
+		unsigned HOST_WIDE_INT max = GET_MODE_MASK (outer_mode) >> 1;
+
+		/* We know from the above that both endpoints are nonnegative,
+		   and that there is no wrapping.  Verify that both endpoints
+		   are within the (signed) range of the outer mode.  */
+		if (u_start_val <= max && u_end_val <= max)
+		  ok = 1;
+	      }
+	    break;
+
+	  default:
+	    abort ();
+	  }
+
+	if (ok)
+	  {
+	    if (loop_dump_stream)
+	      {
+		fprintf(loop_dump_stream,
+			"Verified ext dependant giv at %d of reg %d\n",
+			INSN_UID (v->insn), bl->regno);
+	      }
+	  }
+	else
+	  {
+	    if (loop_dump_stream)
+	      {
+		fprintf(loop_dump_stream,
+			"Failed ext dependant giv at %d, %s\n",
+			INSN_UID (v->insn),
+			(info_ok
+			 ? "biv iteration values overflowed"
+			 : "biv iteration info incomplete"));
+	      }
+	    v->ignore = 1;
+	  }
+      }
+}
+
+/* Generate a version of VALUE in a mode appropriate for initializing V.  */
+
+rtx
+extend_value_for_giv (v, value)
+     struct induction *v;
+     rtx value;
+{
+  rtx ext_dep = v->ext_dependant;
+
+  if (! ext_dep)
+    return value;
+
+  /* Recall that check_ext_dependant_givs verified that the known bounds
+     of a biv did not overflow or wrap with respect to the extension for
+     the giv.  Therefore, constants need no additional adjustment.  */
+  if (CONSTANT_P (value) && GET_MODE (value) == VOIDmode)
+    return value;
+
+  /* Otherwise, we must adjust the value to compensate for the
+     differing modes of the biv and the giv.  */
+  if (GET_CODE (ext_dep) == SUBREG)
+    return gen_lowpart (GET_MODE (ext_dep), value);
+  else
+    return gen_rtx_fmt_e (GET_CODE (ext_dep), GET_MODE (ext_dep), value);
+}
+
 struct combine_givs_stats
 {
   int giv_number;
@@ -7517,10 +7803,24 @@ recombine_givs (loop, bl, unroll_p)
 	{
 	  j = v->same->ix;
 	  luid = stats[i].start_luid;
+	  /* The first instruction of this giv is the only instruction
+	     that uses the combined with giv, so we set the lifetime end
+	     of the combined with giv to the lifetime start of this one.  */
 	  /* Use unsigned arithmetic to model loop wrap-around.  */
 	  if (luid - stats[j].start_luid
 	      > (unsigned) stats[j].end_luid - stats[j].start_luid)
 	    stats[j].end_luid = luid;
+
+	  /* If the lifetime of this giv wraps around the end of the loop,
+	     then that implies that it must be initialized before the start
+	     of the loop.  Derived givs are not initialized before loop start,
+	     so we can not derive such a giv.  This condition is checked
+	     below for the combined with giv.  We check this condition for
+	     combined givs here, and if true, then we extend the lifetime of
+	     the combined with giv so that the check below will fail.  */
+	  if ((unsigned) stats[i].end_luid - INSN_LUID (loop->start)
+	      <= (unsigned) stats[i].start_luid - INSN_LUID (loop->start))
+	    stats[j].end_luid = INSN_LUID (loop->start);
 	}
     }
 
@@ -7568,7 +7868,10 @@ recombine_givs (loop, bl, unroll_p)
 	      /*  Check that the giv insn we're about to use for deriving
 		  precedes all uses of that giv.  Note that initializing the
 		  derived giv would defeat the purpose of reducing register
-		  pressure.
+		  pressure.  We assume a giv is safe as long as its lifetime
+		  does not wrap around the end of the loop.  This also requires
+		  that no giv combined into this one has a lifetime that wraps
+		  around the end of the loop.  This is handled above.
 		  ??? We could arrange to move the insn.  */
 	      && ((unsigned) stats[i].end_luid - INSN_LUID (loop->start)
                   > (unsigned) stats[i].start_luid - INSN_LUID (loop->start))
@@ -9200,6 +9503,7 @@ canonicalize_condition (insn, cond, reve
 }
 
 
+
 /* Given a jump insn JUMP, return the condition that will cause it to branch
    to its JUMP_LABEL.  If the condition cannot be understood, or is an
    inequality floating-point comparison which needs to be reversed, 0 will
@@ -9590,7 +9894,7 @@ load_mems (loop)
 		  && GET_CODE (SET_DEST (set)) == REG
 		  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER
 		  && REGNO (SET_DEST (set)) < last_max_reg
-		  && VARRAY_INT (n_times_set, REGNO (SET_DEST (set))) == 1
+		  && VARRAY_INT (n_times_set, REGNO (SET_DEST (set))) == 1U
 		  && rtx_equal_p (SET_SRC (set), loop_mems[i].mem))
 		SET_REGNO_REG_SET (&copies, REGNO (SET_DEST (set)));
 	      ri.r = p;
--- gcc/rtlanal.c.jj	Sat Feb  3 23:48:01 2001
+++ gcc/rtlanal.c	Mon Feb  5 16:19:16 2001
@@ -1877,8 +1877,16 @@ may_trap_p (x)
 	 certainly may trap.  */
       return 1;
 
+    case GE:
+    case GT:
+    case LE:
+    case LT:
     case COMPARE:
-      /* Any floating comparison may trap.  */
+      /* Some floating point comparisons may trap.  */
+      /* ??? There is no machine independent way to check for tests that trap
+	 when COMPARE is used, though many targets do make this distinction.
+	 For instance, sparc uses CCFPE for compares which generate exceptions
+	 and CCFP for compares which do not generate exceptions.  */
       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)
 	return 1;
       /* But often the compare has some CC mode, so check operand
--- gcc/loop.h.jj	Mon Jul 31 20:02:11 2000
+++ gcc/loop.h	Mon Feb  5 14:56:13 2001
@@ -115,6 +115,8 @@ struct induction
 				   subtracted from add_val when this giv
 				   derives another.  This occurs when the
 				   giv spans a biv update by incrementation. */
+  rtx ext_dependant;		/* If nonzero, is a sign or zero extension
+				   if a biv on which this giv is dependant.  */
   struct induction *next_iv;	/* For givs, links together all givs that are
 				   based on the same biv.  For bivs, links
 				   together all biv entries that refer to the
@@ -238,6 +240,7 @@ int loop_invariant_p PARAMS ((const stru
 rtx get_condition_for_loop PARAMS ((const struct loop *, rtx));
 void emit_iv_add_mult PARAMS ((rtx, rtx, rtx, rtx, rtx));
 rtx express_from PARAMS ((struct induction *, struct induction *));
+rtx extend_value_for_giv PARAMS ((struct induction *, rtx));
 
 void unroll_loop PARAMS ((struct loop *, int, rtx, int));
 rtx biv_total_increment PARAMS ((struct iv_class *));
--- gcc/regmove.c.jj	Sat Feb  3 23:47:52 2001
+++ gcc/regmove.c	Mon Feb  5 14:56:13 2001
@@ -1150,11 +1150,10 @@ regmove_optimize (f, nregs, regmove_dump
 	      src = recog_data.operand[op_no];
 	      dst = recog_data.operand[match_no];
 
-	      if (GET_CODE (src) != REG)
-		continue;
-
+	      /* CYGNUS LOCAL amylaar / gcc/15594 */
 	      src_subreg = src;
 	      if (GET_CODE (dst) == SUBREG
+		  && GET_CODE (src) == REG
 		  && GET_MODE_SIZE (GET_MODE (dst))
 		     >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dst))))
 		{
@@ -1163,9 +1162,20 @@ regmove_optimize (f, nregs, regmove_dump
 				      src, SUBREG_BYTE (dst));
 		  dst = SUBREG_REG (dst);
 		}
-	      if (GET_CODE (dst) != REG
+	      else if (GET_CODE (src) == SUBREG
+		       && (GET_MODE_SIZE (GET_MODE (src))
+			   >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))
+		{
+		  src = SUBREG_REG (src);
+		  /* Unshare the SUBREG.  */
+		  src_subreg = copy_rtx (src_subreg);
+		}
+
+	      if (GET_CODE (src) != REG
+		  || GET_CODE (dst) != REG
 		  || REGNO (dst) < FIRST_PSEUDO_REGISTER)
 		continue;
+	      /* END CYGNUS LOCAL */
 
 	      if (REGNO (src) < FIRST_PSEUDO_REGISTER)
 		{
@@ -1790,6 +1800,21 @@ fixup_match_1 (insn, set, src, src_subre
 	  validate_change (insn, recog_data.operand_loc[match_number], src, 1);
 	  if (validate_replace_rtx (dst, src_subreg, p))
 	    success = 1;
+	  /* CYGNUS LOCAL amylaar / gcc/15594 */
+	  else if (src_subreg != src
+		   && *recog_data.operand_loc[match_number] == dst)
+	    {
+	      /* In this case, we originally have a subreg in the src
+		 operand.  Its mode should match the destination operand.
+		 Moreover, P is likely to use DST in a subreg, so replacing
+		 it with another subreg will fail - but putting the raw
+		 register there can succeed.  */
+	      validate_change (insn, recog_data.operand_loc[match_number],
+			       src_subreg, 1);
+	      if (validate_replace_rtx (dst, src, p))
+		success = 1;
+	    }
+	  /* END CYGNUS LOCAL */
 	  break;
 	}
 
--- gcc/reload.c.jj	Sat Feb  3 23:48:02 2001
+++ gcc/reload.c	Mon Feb  5 16:14:17 2001
@@ -375,13 +375,13 @@ push_secondary_reload (in_p, x, opnum, o
 	 in operand 1.  Outputs should have an initial "=", which we must
 	 skip.  */
 
-      char insn_letter
-	= insn_data[(int) icode].operand[!in_p].constraint[in_p];
-      enum reg_class insn_class
-	= (insn_letter == 'r' ? GENERAL_REGS
-	   : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));
+      char insn_letter, t_letter;
 
-      if (insn_class == NO_REGS
+      insn_letter = insn_data[(int) icode].operand[!in_p].constraint[in_p];
+      class = (insn_letter == 'r' ? GENERAL_REGS
+	       : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));
+
+      if (class == NO_REGS
 	  || (in_p
 	      && insn_data[(int) icode].operand[!in_p].constraint[0] != '=')
 	  /* The scratch register's constraint must start with "=&".  */
@@ -389,18 +389,12 @@ push_secondary_reload (in_p, x, opnum, o
 	  || insn_data[(int) icode].operand[2].constraint[1] != '&')
 	abort ();
 
-      if (reg_class_subset_p (reload_class, insn_class))
-	mode = insn_data[(int) icode].operand[2].mode;
-      else
-	{
-	  char t_letter = insn_data[(int) icode].operand[2].constraint[2];
-	  class = insn_class;
-	  t_mode = insn_data[(int) icode].operand[2].mode;
-	  t_class = (t_letter == 'r' ? GENERAL_REGS
-		     : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));
-	  t_icode = icode;
-	  icode = CODE_FOR_nothing;
-	}
+      t_letter = insn_data[(int) icode].operand[2].constraint[2];
+      t_mode = insn_data[(int) icode].operand[2].mode;
+      t_class = (t_letter == 'r' ? GENERAL_REGS
+		 : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));
+      t_icode = icode;
+      icode = CODE_FOR_nothing;
     }
 
   /* This case isn't valid, so fail.  Reload is allowed to use the same
@@ -410,15 +404,14 @@ push_secondary_reload (in_p, x, opnum, o
      silently generating incorrect code later.
 
      The convention is that secondary input reloads are valid only if the
-     secondary_class is different from class.  If you have such a case, you
-     can not use secondary reloads, you must work around the problem some
-     other way.
-
-     Allow this when MODE is not reload_mode and assume that the generated
-     code handles this case (it does on the Alpha, which is the only place
-     this currently happens).  */
+     secondary class is different from the reload class.  If you have such
+     a case, you can not use secondary reloads, you must work around the
+     problem some other way.
+
+     Allow this when a tertiary reload is used; i.e. assume that the
+     generated code handles this case.  */
 
-  if (in_p && class == reload_class && mode == reload_mode)
+  if (in_p && class == reload_class && t_class == NO_REGS)
     abort ();
 
   /* If we need a tertiary reload, see if we have one we can reuse or else
@@ -909,7 +902,8 @@ push_reload (in, out, inloc, outloc, cla
 
   if (in != 0 && GET_CODE (in) == SUBREG
 #ifdef CLASS_CANNOT_CHANGE_MODE
-      && class != CLASS_CANNOT_CHANGE_MODE
+      && (class != CLASS_CANNOT_CHANGE_MODE
+	  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (in)), inmode))
 #endif
       && (CONSTANT_P (SUBREG_REG (in))
 	  || GET_CODE (SUBREG_REG (in)) == PLUS
@@ -1031,7 +1025,9 @@ push_reload (in, out, inloc, outloc, cla
      and in that case the constraint should label it input-output.)  */
   if (out != 0 && GET_CODE (out) == SUBREG
 #ifdef CLASS_CANNOT_CHANGE_MODE
-      && class != CLASS_CANNOT_CHANGE_MODE
+      && (class != CLASS_CANNOT_CHANGE_MODE
+	  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (out)),
+					   outmode))
 #endif
       && (CONSTANT_P (SUBREG_REG (out))
 	  || strict_low
--- gcc/stor-layout.c.jj	Sat Feb  3 23:48:06 2001
+++ gcc/stor-layout.c	Mon Feb  5 16:27:58 2001
@@ -1073,12 +1073,7 @@ compute_record_mode (type)
       /* If this field is the whole struct, remember its mode so
 	 that, say, we can put a double in a class into a DF
 	 register instead of forcing it to live in the stack.  */
-      if (field == TYPE_FIELDS (type) && TREE_CHAIN (field) == 0)
-	mode = DECL_MODE (field);
-      else if (TREE_CODE (type) == RECORD_TYPE
-	       && simple_cst_equal (TYPE_SIZE (type), DECL_SIZE (field))
-	       && mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1)
-		  != BLKmode)
+      if (simple_cst_equal (TYPE_SIZE (type), DECL_SIZE (field)))
 	mode = DECL_MODE (field);
 
 #ifdef STRUCT_FORCE_BLK
@@ -1089,8 +1084,9 @@ compute_record_mode (type)
 #endif /* STRUCT_FORCE_BLK  */
     }
 
-  /* If we only have one real field; use its mode.  */
-  if (mode != VOIDmode)
+  /* If we only have one real field; use its mode.  This only applies to
+     RECORD_TYPE.  This does not apply to unions.  */
+  if (TREE_CODE (type) == RECORD_TYPE && mode != VOIDmode)
     TYPE_MODE (type) = mode;
   else
     TYPE_MODE (type) = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);
--- gcc/reload1.c.jj	Sat Feb  3 23:48:03 2001
+++ gcc/reload1.c	Mon Feb  5 14:56:14 2001
@@ -85,6 +85,10 @@ Boston, MA 02111-1307, USA.  */
 #ifndef REGISTER_MOVE_COST
 #define REGISTER_MOVE_COST(x, y) 2
 #endif
+
+#ifndef LOCAL_REGNO
+#define LOCAL_REGNO(REGNO)  0
+#endif
 
 /* During reload_as_needed, element N contains a REG rtx for the hard reg
    into which reg N has been reloaded (perhaps for a previous insn).  */
@@ -654,10 +658,8 @@ reload (first, global, dumpfile)
      registers.  */
   if (current_function_has_nonlocal_label)
     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-      {
-	if (! call_used_regs[i] && ! fixed_regs[i])
-	  regs_ever_live[i] = 1;
-      }
+      if (! call_used_regs[i] && ! fixed_regs[i] && ! LOCAL_REGNO (i))
+	regs_ever_live[i] = 1;
 
   /* Find all the pseudo registers that didn't get hard regs
      but do have known equivalent constants or memory slots.
@@ -1021,7 +1023,7 @@ reload (first, global, dumpfile)
   if (insns_need_reload != 0 || something_needs_elimination
       || something_needs_operands_changed)
     {
-      int old_frame_size = get_frame_size ();
+      HOST_WIDE_INT old_frame_size = get_frame_size ();
 
       reload_as_needed (global);
 
--- gcc/rtl.h.jj	Sat Feb  3 23:47:49 2001
+++ gcc/rtl.h	Mon Feb  5 14:56:14 2001
@@ -515,7 +515,10 @@ enum reg_note
   REG_EH_RETHROW,
 
   /* Used by haifa-sched to save NOTE_INSN notes across scheduling.  */
-  REG_SAVE_NOTE
+  REG_SAVE_NOTE,
+
+  /* Indicates that a call does not return.  */
+  REG_NORETURN
 };
 
 /* The base value for branch probability notes.  */
--- gcc/stmt.c.jj	Sat Feb  3 23:48:05 2001
+++ gcc/stmt.c	Mon Feb  5 17:01:12 2001
@@ -798,7 +798,7 @@ expand_goto (label)
     {
       struct function *p = find_function_data (context);
       rtx label_ref = gen_rtx_LABEL_REF (Pmode, label_rtx (label));
-      rtx temp, handler_slot;
+      rtx handler_slot, static_chain, save_area;
       tree link;
 
       /* Find the corresponding handler slot for this label.  */
@@ -816,49 +816,40 @@ expand_goto (label)
 	 case the virtual stack vars register gets instantiated differently
 	 in the parent than in the child.  */
 
+      static_chain = copy_to_reg (lookup_static_chain (label));
+
+      /* Get addr of containing function's current nonlocal goto handler,
+	 which will do any cleanups and then jump to the label.  */
+      handler_slot = copy_to_reg (replace_rtx (copy_rtx (handler_slot),
+					       virtual_stack_vars_rtx,
+					       static_chain));
+
+      /* Get addr of containing function's nonlocal save area.  */
+      save_area = p->x_nonlocal_goto_stack_level;
+      if (save_area)
+	save_area = replace_rtx (copy_rtx (save_area),
+				 virtual_stack_vars_rtx, static_chain);
+
 #if HAVE_nonlocal_goto
       if (HAVE_nonlocal_goto)
-	emit_insn (gen_nonlocal_goto (lookup_static_chain (label),
-				      copy_rtx (handler_slot),
-				      copy_rtx (p->x_nonlocal_goto_stack_level),
-				      label_ref));
+	emit_insn (gen_nonlocal_goto (static_chain, handler_slot,
+				      save_area, label_ref));
       else
 #endif
 	{
-	  rtx addr;
-
 	  /* Restore frame pointer for containing function.
 	     This sets the actual hard register used for the frame pointer
 	     to the location of the function's incoming static chain info.
 	     The non-local goto handler will then adjust it to contain the
 	     proper value and reload the argument pointer, if needed.  */
-	  emit_move_insn (hard_frame_pointer_rtx, lookup_static_chain (label));
-
-	  /* We have now loaded the frame pointer hardware register with
-	     the address of that corresponds to the start of the virtual
-	     stack vars.  So replace virtual_stack_vars_rtx in all
-	     addresses we use with stack_pointer_rtx.  */
-
-	  /* Get addr of containing function's current nonlocal goto handler,
-	     which will do any cleanups and then jump to the label.  */
-	  addr = copy_rtx (handler_slot);
-	  temp = copy_to_reg (replace_rtx (addr, virtual_stack_vars_rtx,
-					   hard_frame_pointer_rtx));
-	  
-	  /* Restore the stack pointer.  Note this uses fp just restored.  */
-	  addr = p->x_nonlocal_goto_stack_level;
-	  if (addr)
-	    addr = replace_rtx (copy_rtx (addr),
-				virtual_stack_vars_rtx,
-				hard_frame_pointer_rtx);
-
-	  emit_stack_restore (SAVE_NONLOCAL, addr, NULL_RTX);
+	  emit_move_insn (hard_frame_pointer_rtx, static_chain);
+	  emit_stack_restore (SAVE_NONLOCAL, save_area, NULL_RTX);
 
-	  /* USE of hard_frame_pointer_rtx added for consistency; not clear if
-	     really needed.  */
+	  /* USE of hard_frame_pointer_rtx added for consistency;
+	     not clear if really needed.  */
 	  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));
 	  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));
-	  emit_indirect_jump (temp);
+	  emit_indirect_jump (handler_slot);
 	}
      }
   else
@@ -1483,9 +1474,6 @@ expand_asm_operands (string, outputs, in
 	  case 's':  case 'i':  case 'n':
 	  case 'I':  case 'J':  case 'K':  case 'L':  case 'M':
 	  case 'N':  case 'O':  case 'P':  case ',':
-#ifdef EXTRA_CONSTRAINT
-	  case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':
-#endif
 	    break;
 
 	  case '0':  case '1':  case '2':  case '3':  case '4':
@@ -1505,6 +1493,9 @@ expand_asm_operands (string, outputs, in
 	    break;
 
 	  case 'g':  case 'X':
+#ifdef EXTRA_CONSTRAINT
+	  case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':
+#endif
 	    allows_reg = 1;
 	    allows_mem = 1;
 	    break;
@@ -1637,13 +1628,10 @@ expand_asm_operands (string, outputs, in
 
 	  case '<':  case '>':
 	  case '?':  case '!':  case '*':
-	  case 'E':  case 'F':  case 'G':  case 'H':  case 'X':
+	  case 'E':  case 'F':  case 'G':  case 'H':
 	  case 's':  case 'i':  case 'n':
 	  case 'I':  case 'J':  case 'K':  case 'L':  case 'M':
 	  case 'N':  case 'O':  case 'P':  case ',':
-#ifdef EXTRA_CONSTRAINT
-	  case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':
-#endif
 	    break;
 
 	    /* Whether or not a numeric constraint allows a register is
@@ -1682,7 +1670,11 @@ expand_asm_operands (string, outputs, in
 	    allows_reg = 1;
 	    break;
 
-	  case 'g':
+	  case 'g':  case 'X':
+#ifdef EXTRA_CONSTRAINT
+	  case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':
+#endif
+
 	    allows_reg = 1;
 	    allows_mem = 1;
 	    break;
@@ -2313,8 +2305,10 @@ expand_end_loop ()
 		    break;
 		  continue;
 		}
+	      
 	      if (GET_CODE (prev) == CODE_LABEL)
 		break;
+	      
 	      if (GET_CODE (prev) == JUMP_INSN)
 		{
 		  if (GET_CODE (PATTERN (prev)) == SET
@@ -2461,6 +2455,7 @@ expand_end_loop ()
 	      rtx dest1 = NULL_RTX;
 	      rtx dest2 = NULL_RTX;
 	      rtx potential_last_test;
+	      
 	      if (GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)
 		{
 		  /* A conditional jump.  */
@@ -2476,22 +2471,24 @@ expand_end_loop ()
 		  potential_last_test = NEXT_INSN (insn);
 		}
 
-	      do {
-		if (dest1 && GET_CODE (dest1) == LABEL_REF
-		    && ((XEXP (dest1, 0) 
-			 == loop_stack->data.loop.alt_end_label)
-			|| (XEXP (dest1, 0) 
-			    == loop_stack->data.loop.end_label)))
-		  {
-		    last_test_insn = potential_last_test;
-		    break;
-		  }
-
-		/* If this was a conditional jump, there may be
-		   another label at which we should look.  */
-		dest1 = dest2;
-		dest2 = NULL_RTX;
-	      } while (dest1);
+	      do
+		{
+		  if (dest1 && GET_CODE (dest1) == LABEL_REF
+		      && ((XEXP (dest1, 0) 
+			   == loop_stack->data.loop.alt_end_label)
+			  || (XEXP (dest1, 0) 
+			      == loop_stack->data.loop.end_label)))
+		    {
+		      last_test_insn = potential_last_test;
+		      break;
+		    }
+		  
+		  /* If this was a conditional jump, there may be
+		     another label at which we should look.  */
+		  dest1 = dest2;
+		  dest2 = NULL_RTX;
+		}
+	      while (dest1);
 	    }
 	}
 
--- gcc/tm.texi.jj	Sat Feb  3 23:47:55 2001
+++ gcc/tm.texi	Mon Feb  5 14:56:14 2001
@@ -1489,6 +1489,14 @@ corresponding to the register number @va
 function.  Return @var{in} if register number @var{in} is not an inbound
 register.
 
+@findex LOCAL_REGNO
+@item LOCAL_REGNO (@var{regno})
+Define this macro if the target machine has register windows.  This C
+expression returns true if the register is call-saved but is in the
+register window.  Unlike most call-saved registers, such registers
+need not be explicitly restored on function exit or during non-local
+gotos.
+
 @ignore
 @findex PC_REGNUM
 @item PC_REGNUM
@@ -5848,6 +5856,19 @@ The usual definition of this macro is as
 @example
 fprintf (@var{stream}, "L%s%d:\n", @var{prefix}, @var{num})
 @end example
+
+@findex ASM_OUTPUT_DEBUG_LABEL
+@item ASM_OUTPUT_DEBUG_LABEL (@var{stream}, @var{prefix}, @var{num})
+A C statement to output to the stdio stream @var{stream} a debug info
+label whose name is made from the string @var{prefix} and the number
+@var{num}.  This is useful for VLIW targets, where debug info labels
+may need to be treated differently than branch target labels.  On some
+systems, branch target labels must be at the beginning of instruction
+bundles, but debug info labels can occur in the middle of instruction
+bundles.
+
+If this macro is not defined, then @code{ASM_OUTPUT_INTERNAL_LABEL} will be
+used.
 
 @findex ASM_OUTPUT_ALTERNATE_LABEL_NAME
 @item ASM_OUTPUT_ALTERNATE_LABEL_NAME (@var{stream}, @var{string})
--- gcc/tree.c.jj	Sat Feb  3 23:48:05 2001
+++ gcc/tree.c	Mon Feb  5 14:56:14 2001
@@ -1077,7 +1077,7 @@ make_node (code)
 
     case 't':
       TYPE_UID (t) = next_type_uid++;
-      TYPE_ALIGN (t) = 1;
+      TYPE_ALIGN (t) = char_type_node ? TYPE_ALIGN (char_type_node) : 0;
       TYPE_USER_ALIGN (t) = 0;
       TYPE_MAIN_VARIANT (t) = t;
       TYPE_OBSTACK (t) = obstack;
--- gcc/unroll.c.jj	Sat Feb  3 23:48:05 2001
+++ gcc/unroll.c	Mon Feb  5 14:56:14 2001
@@ -2047,10 +2047,12 @@ copy_loop_body (copy_start, copy_end, ma
 	  if (JUMP_LABEL (insn) == start_label && insn == copy_end
 	      && ! last_iteration)
 	    {
-	      /* Update JUMP_LABEL correctly to make invert_jump working.  */
+	      /* Update JUMP_LABEL make invert_jump work correctly.  */
 	      JUMP_LABEL (copy) = get_label_from_map (map,
 						      CODE_LABEL_NUMBER
 						      (JUMP_LABEL (insn)));
+	      LABEL_NUSES (JUMP_LABEL (copy))++;
+
 	      /* This is a branch to the beginning of the loop; this is the
 		 last insn being copied; and this is not the last iteration.
 		 In this case, we want to change the original fall through
@@ -2502,6 +2504,7 @@ iteration_info (loop, iteration_var, ini
     {
       HOST_WIDE_INT offset = 0;
       struct induction *v = REG_IV_INFO (REGNO (iteration_var));
+      rtx biv_initial_value;
 
       if (REGNO (v->src_reg) >= max_reg_before_loop)
 	abort ();
@@ -2523,8 +2526,9 @@ iteration_info (loop, iteration_var, ini
 	{
 	  struct induction *biv_inc;
 
-	  *increment
-	    = fold_rtx_mult_add (v->mult_val, *increment, const0_rtx, v->mode);
+	  *increment = fold_rtx_mult_add (v->mult_val,
+					  extend_value_for_giv (v, *increment),
+					  const0_rtx, v->mode);
 	  /* The caller assumes that one full increment has occured at the
 	     first loop test.  But that's not true when the biv is incremented
 	     after the giv is set (which is the usual case), e.g.:
@@ -2542,11 +2546,13 @@ iteration_info (loop, iteration_var, ini
 	fprintf (loop_dump_stream,
 		 "Loop unrolling: Giv iterator, initial value bias %ld.\n",
 		 (long) offset);
+
       /* Initial value is mult_val times the biv's initial value plus
 	 add_val.  Only useful if it is a constant.  */
+      biv_initial_value = extend_value_for_giv (v, bl->initial_value);
       *initial_value
 	= fold_rtx_mult_add (v->mult_val,
-			     plus_constant (bl->initial_value, offset),
+			     plus_constant (biv_initial_value, offset),
 			     v->add_val, v->mode);
     }
   else
@@ -2910,6 +2916,7 @@ find_splittable_givs (loop, bl, unroll_t
 				loop->start);
 	      biv_initial_value = tem;
 	    }
+	  biv_initial_value = extend_value_for_giv (v, biv_initial_value);
 	  value = fold_rtx_mult_add (v->mult_val, biv_initial_value,
 				     v->add_val, v->mode);
 	}
@@ -3471,10 +3478,12 @@ final_giv_value (loop, v)
 	  insert_before = NEXT_INSN (loop_end);
 
 	  /* Put the final biv value in tem.  */
-	  tem = gen_reg_rtx (bl->biv->mode);
+	  tem = gen_reg_rtx (v->mode);
 	  record_base_value (REGNO (tem), bl->biv->add_val, 0);
-	  emit_iv_add_mult (increment, GEN_INT (n_iterations),
-			    bl->initial_value, tem, insert_before);
+	  emit_iv_add_mult (extend_value_for_giv (v, increment),
+			    GEN_INT (n_iterations),
+			    extend_value_for_giv (v, bl->initial_value),
+			    tem, insert_before);
 
 	  /* Subtract off extra increments as we find them.  */
 	  for (insn = NEXT_INSN (v->insn); insn != loop_end;
--- gcc/c-decl.c.jj	Sat Feb  3 23:48:11 2001
+++ gcc/c-decl.c	Mon Feb  5 14:50:26 2001
@@ -4648,8 +4648,8 @@ grokdeclarator (declarator, declspecs, d
      controlled separately by its own initializer.  */
 
   if (type != 0 && typedef_type != 0
-      && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (typedef_type)
-      && TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type) == 0)
+      && TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type) == 0
+      && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (typedef_type))
     {
       type = build_array_type (TREE_TYPE (type), 0);
       if (size_varies)
@@ -5305,7 +5305,7 @@ finish_struct (t, fieldlist, attributes)
     }
 
   /* Install struct as DECL_CONTEXT of each field decl.
-     Also process specified field sizes,m which is found in the DECL_INITIAL.
+     Also process specified field sizes, which is found in the DECL_INITIAL.
      Store 0 there, except for ": 0" fields (so we can find them
      and delete them, below).  */
 
--- gcc/ChangeLog.GnuPro.jj	Mon Feb  5 14:36:29 2001
+++ gcc/ChangeLog.GnuPro	Mon Feb  5 14:38:06 2001
@@ -0,0 +1,767 @@
+2000-11-17  Jim Wilson  <wilson@redhat.com>
+
+	* config/ia64/ia64.c (emit_insn_group_barriers, case CALL_INSN): 
+	Don't clear need_barrier is next_insn is a CALL_INSN, or has
+	instruction type B or UNKNOWN.
+
+2000-11-15  Bernd Schmidt  <bernds@redhat.co.uk>
+
+	* ia64.c (struct group): New structure.
+	(last_group): New static array.
+	(group_idx): New static variable.
+	(emit_group_barrier_after, errata_find_address_regs, errata_emit_nops):
+	New static functions.
+	(emit_insn_group_barriers): Initialize and keep track of group_idx
+	and last_group.
+	Call errata_emit_nops if TARGET_B_STEP or TARGET_A_STEP.
+	Replace all calls to emit_insn_after that emit a group barrier to use
+	emit_group_barrier_after.
+	* ia64.h (MASK_B_STEP): New.
+	(other MASK_XXX macros): Renumbered.
+	(TARGET_B_STEP): New.
+	(TARGET_SWITCHES): Add -mb-step.
+
+2000-11-08  Richard Henderson  <rth@redhat.com>
+
+	* flow.c (init_propagate_block_info): Protect the rtx stored in
+	mem_set_list from modification by find_auto_inc.
+	(mark_set_1): Likewise.
+
+2000-11-16  Jim Wilson  <wilson@redhat.com>
+
+	* config/ia64/ia64.c (ia64_encode_section_info): Disallow decls with
+	DECL_EXTERNAL set.
+
+2000-08-15  Richard Henderson  <rth@cygnus.com>
+
+	* flow.c (mark_used_reg): Set reg_cond_reg appropriately.
+
+2000-10-31  Jim Wilson  <wilson@redhat.com>
+
+	* defaults.h (ASM_OUTPUT_DEBUG_LABEL): New.
+	* tm.texi (ASM_OUTPUT_DEBUG_LABEL): Document.
+	* dwarf2out.c (dwarf2out_begin_block): Use ASM_OUTPUT_DEBUG_LABEL
+	instead of ASM_OUTPUT_INTERNAL_LABEL.
+	(dwarf2out_end_block, dwarf2out_label): Likewise.
+	* final.c (final_scan_insn, case NOTE_INSN_DELETED_LABEL): Likewise
+	* config/ia64/ia64.h (ASM_OUTPUT_DEBUG_LABEL): Define.
+	
+2000-10-24  Jim Wilson  <wilson@cygnus.com>
+
+	* expmed.c (store_bit_field): Move integer pun code down after
+	code that calls emit_move_insn for entire register move.
+	* stor-layout.c (compute_record_mode): Revert Mar 25, Aug 18, and
+	Oct 20 changes.  Only store mode in TYPE_MODE if RECORD_TYPE.
+	
+2000-10-23  Jim Wilson  <wilson@cygnus.com>
+
+	* ia64.c (ia64_print_operand, case 'r'): Correct comment.  Handle
+	CONST_INT.
+	* ia64.md (cmpsi_adjusted): Use %r3.
+	(cmpdi_adjusted): Likewise.
+
+2000-10-19  Jim Wilson  <wilson@cygnus.com>
+
+	* c-decl.c (start_decl): Check for error_mark_node type before using
+	COMPLETE_TYPE_P.
+	(finish_decl): Likewise.  Don't give an error if decl type is
+	already error_mark_node.
+
+Sun Sep 17 10:46:17 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>
+
+	* c-decl.c (grokdeclarator): Reorder tests to avoid looking at
+	TYPE_MAIN_VARIANT of ERROR_MARK.
+
+2000-10-19  Jim Wilson  <wilson@cygnus.com>
+
+	* haifa-sched.c (compute_trg_info): Add explanatory comments.
+	New local update_blocks.  Use update_blocks to remove duplicates
+	when computing update blocks.  Check for bblst_table overflow.
+	(schedule_block): Add explanatory comment.  Reduce bblst_size by
+	factor of 2.
+	* config/ia64/ia64.md (movdi_symbolic): Document loss of REG_LABEL
+	notes.
+	
+2000-10-05  Jim Wilson  <wilson@cygnus.com>
+
+	* function.c (fixup_var_refs_1, case SET): When gen_move_insn returns a
+	SEQUENCE, call emit_insn_before, copy PATTERN and REG_NOTES of last
+	sequence insn to INSN, and delete last sequence insn.
+
+2000-09-25  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (INDEX_REG_CLASS): Define to GENERAL_REGS.
+	(REGNO_OK_FOR_INDEX_P): Define to REGNO_OK_FOR_BASE_P.
+	(LEGITIMATE_ADDRESS_DISP): Use LEGITIMATE_ADDRESS_REG.
+	(REG_OK_FOR_INDEX): Define to REG_OK_FOR_BASE_P.
+
+2000-08-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* loop.c (scan_loop): Ensure update_end label does not
+	go away until reg_scan_update is run.
+
+2000-09-19  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/crtbegin.asm (__dso_handle): Delete use of
+	HAVE_GAS_HIDDEN macro.
+
+2000-08-20  Richard Henderson  <rth@cygnus.com>
+
+	* flow.c (merge_blocks_nomove): Don't seek back past the bb note.
+
+2000-07-20  Zack Weinberg  <zack@wolery.cumb.org>
+
+	* tradcpp.c (main): Don't munge -D options.
+	(make_definition): Bring -D handling in line with cpplib.
+	(do_define): Strip all leading whitespace from macro definitions.
+
+2000-07-19  Zack Weinberg  <zack@wolery.cumb.org>
+
+	* tradcpp.c (rescan): Do not recognize directives when the #
+	is indented.
+
+2000-09-18  Jim Wilson  <wilson@cygnus.com>
+
+	* unroll.c (iteration_info): Pass increment to extend_for_giv_value
+	before passing to fold_rtx_mult_add.
+
+	* unroll.c (final_giv_value): Pass increment through
+	extend_value_for_giv before passing it to emit_iv_add_mult.
+
+	* function.c (fixup_var_refs_1, case ZERO_EXTRACT): If we have a
+	paradoxical subreg, then directly substitute the replacement and
+	return.
+
+2000-09-12  Jim Wilson  <wilson@cygnus.com>
+
+	* ifcvt.c (noce_process_if_block): If A and B are the same, and no
+	else block, and X has side-effects, then fail.
+
+2000-07-15  Zack Weinberg  <zack@wolery.cumb.org>
+
+        * cpplib.c (cpp_push_buffer): Don't set new->lineno to 1.
+
+2000-09-11  Richard Henderson  <rth@cygnus.com>
+
+	* cse.c (fold_rtx): Honor NO_FUNCTION_CSE.
+
+2000-07-18  Zack Weinberg  <zack@wolery.cumb.org>
+
+	* gcc.c (.h spec): Fix typo.
+
+2000-07-17  Zack Weinberg  <zack@wolery.cumb.org>
+
+	* cppmain.c: Do not set pfile->printer if no_output is on.
+
+2000-09-07  Jim Wilson  <wilson@cygnus.com>
+
+	* reload.c (push_reload): Use CLASS_CANNOT_CHANGE_MODE_P in addition
+	to CLASS_CANNOT_CHANGE_MODE.
+	* config/ia64/ia64.h (CLASS_CANNOT_CHANGE_MODE_P): True only if the
+	mode classes are different.
+
+2000-09-01  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.md (mulsi3): Use grfr_register_operand.
+	(madddi3): Likewise.
+	(maddsi3): New.
+
+2000-08-29  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.md (muldi3): Use grfr_register_operand
+	for the inputs.
+
+2000-09-01  Jim Wilson  <wilson@cygnus.com>
+
+	* calls.c (emit_call_1): Add REG_NORETURN note to call if ECF_NORETURN.
+	* combine.c (distribute_notes): Handle REG_NORETURN.
+	* rtl.c (reg_note_name): Add REG_NORETURN.
+	* rtl.h (enum reg_note): Likewise.
+
+	* config/ia64/ia64-protos.h (emit_safe_across_calls): Renamed from
+	ia64_file_start.
+	* config/ia64/ia64.c (emit_safe_across_calls): Likewise.
+	(rtx_needs_barrier): Handle unspec_volatile 8 and 9.
+	(emit_predicate_relation_info): Handle conditional calls with
+	REG_NORETURN.
+	* config/ia64/ia64.h (ASM_FILE_START): Call emit_safe_across_calls
+	instead of ia64_file_start.
+	* config/ia64/sysv4.h (ASM_FILE_START): Likewise.
+	* config/ia64/ia64.md (safe_across_calls_all,
+	save_across_calls_normal): New patterns.
+
+	* loop.c (check_final_value): Check for biv use before checking for
+	giv use.  Check for both biv and giv uses.  Always set last_giv_use
+	if there is a giv use.
+
+2000-08-25  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.h (struct machine_function): Add n_varargs.
+	* config/ia64/ia64.c (ia64_compute_frame_size): Use it.
+	(ia64_expand_prologue): Likewise.
+	(ia64_setup_incoming_varargs): Set it.  Properly skip the current
+	argument for stdargs.
+
+2000-08-25  Jim Wilson  <wilson@cygnus.com>
+
+	* cse.c (cse_insn): Don't pass label subtraction to force_const_mem.
+
+	* function.c (gen_mem_addressof): Clear MEM_ALIAS_SET if no decl.
+
+2000-08-24  Richard Henderson  <rth@cygnus.com>
+
+	* stmt.c (expand_asm_operands): Treat EXTRA_CONSTRAINT like g or X.
+
+	* config/ia64/ia64-protos.h: Update.
+	* config/ia64/ia64.c (gr_register_operand): New.
+	(fr_register_operand, grfr_register_operand): New.
+	(gr_nonimmediate_operand, grfr_nonimmediate_operand): New.
+	(grfr_reg_or_8bit_operand): New.
+	(gr_reg_or_0_operand): Rename from reg_or_0_operand and 
+	use gr_register_operand.
+	(gr_reg_or_5bit_operand, gr_reg_or_6bit_operand): Likewise.
+	(gr_reg_or_8bit_operand, gr_reg_or_8bit_adjusted_operand): Likewise.
+	(gr_reg_or_8bit_and_adjusted_operand): Likewise.
+	(gr_reg_or_14bit_operand, gr_reg_or_22bit_operand): Likewise.
+	(fr_reg_or_fp01_operand): Likewise.
+	(not_postinc_memory_operand): New.
+	(ia64_split_timode): Remove unused variables.
+	(rtx_needs_barrier): Check arguments to cmpxchg.
+	(builtin_description): Remove.
+	(bdesc_2argsi, bdesc_2argdi): Remove.
+	(ia64_init_builtins): Declare all builtins directly.
+	(ia64_expand_fetch_and_op): Rewrite to be called from
+	ia64_expand_builtin directly.  Use expand_binop and co.
+	(ia64_expand_op_and_fetch): Likewise.
+	(ia64_expand_compare_and_swap): Likewise.
+	(ia64_expand_binop_builtin): Remove.
+	(ia64_expand_lock_test_and_set): New.
+	(ia64_expand_lock_release): New.
+	(ia64_expand_builtin): Use them.
+	* config/ia64/ia64.h (CONSTRAINT_OK_FOR_S): New.
+	(EXTRA_CONSTRAINT): Use it.
+	(PREDICATE_CODES): Update.
+	* config/ia64/ia64.md (*): Use gr_register_operand and co.
+	(mf): Indicate that we set memory as well as use it.
+	(fetchadd_acq_si): Show memory being modified as well.
+	(fetchadd_acq_di, cmpxchg_acq_si, cmpxchg_acq_di): Likewise. 
+	(val_compare_and_swap_si, val_compare_and_swap_di): Remove.
+	(lock_test_and_set_si, lock_test_and_set_di): Remove.
+	(fetch_and_add_si, fetch_and_sub_si, fetch_and_or_si): Remove.
+	(fetch_and_and_si, fetch_and_xor_si, fetch_and_nand_si): Remove.
+	(fetch_and_add_di, fetch_and_sub_di, fetch_and_or_di): Remove.
+	(fetch_and_and_di, fetch_and_xor_di, fetch_and_nand_di): Remove.
+	(add_and_fetch_di, sub_and_fetch_di, or_and_fetch_di): Remove.
+	(and_and_fetch_di, xor_and_fetch_di, nand_and_fetch_di): Remove.
+	(add_and_fetch_si, sub_and_fetch_si, or_and_fetch_si): Remove.
+	(and_and_fetch_si, xor_and_fetch_si, nand_and_fetch_si): Remove.
+	* config/ia64/ia64intrin.h (*): Cast result to the appropriate
+	return type.  Pretty print definitions.
+
+2000-08-24  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.md (movdi): Don't call gen_movdi_symbolic if
+	we have a SYMBOL_REF with SYMBOL_REF_FLAG set.
+
+2000-08-23  Jim Wilson  <wilson@cygnus.com>
+
+	* frame.h (IA64_UNW_EHANDLER, IA64_UNW_UHANDLER): New.
+	* config/ia64/frame-ia64.c (__get_personality): Return zero if neither
+	EHANDLER nor UHANDLER bit is set.
+	(__get_except_table): Likewise.
+
+2000-08-21  Jim Wilson  <wilson@cygnus.com>
+
+	* real.c (ereal_from_int, ereal_from_uint, significand_size): Handle
+	INTEL_EXTENDED_IEEE_FORMAT.
+	(toe64): Delete INTEL_EXTENDED_IEEE_FORMAT support.  Unconditionally
+	clear last two bytes of output FP value.
+
+2000-08-20  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.c (emit_insn_group_barriers): Stop if ar.lc
+	assigned before a loop.
+
+	* config/ia64/ia64.md (ashlsi3): Zero extend the shift count.
+	(ashrsi3, lshrsi3): Likewise.
+
+2000-08-19  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.c (reg_or_5bit_operand): New.
+	(ia64_depz_field_mask): New.
+	* config/ia64/ia64.h (CONSTRAINT_OK_FOR_R): New.
+	(PREDICATE_CODES): Update.
+	* config/ia64/ia64.md: Update commentary.
+	(depz_internal): New.
+	(ashlsi3): Implement directly.
+	(ashrsi3, lshrsi3): Simplify; rely on extv and extzv for constants.
+	(ashldi3): Use shladd.
+	* config/ia64/ia64-protos.h: Update.
+
+2000-08-18  Richard Henderson  <rth@cygnus.com>
+
+	* combine.c (make_compound_operation): Break after creating
+	the extraction.
+
+2000-08-12  Geoffrey Keating  <geoffk@cygnus.com>
+
+	* tree.h (DECL_OFFSET_ALIGN): Make the off_align field of
+	the tree structure an exponent rather than an explicit alignment
+	so it doesn't overflow.
+	(SET_DECL_OFFSET_ALIGN): New macro.
+	* stor-layout.c (place_union_field): Use SET_DECL_OFFSET_ALIGN
+	rather than DECL_OFFSET_ALIGN.
+	(place_field): Likewise.
+	* expmed.c (store_bit_field): Abort on align==0 to avoid
+	antisocial machine behaviour.
+
+2000-07-26  Alexandre Oliva  <aoliva@redhat.com>
+
+	* c-decl.c (finish_enum): Convert enumerations that fit in an
+	`int' to `int'.
+	(build_enumerator): In pedantic mode, cast to `int' those that
+	don't.
+
+2000-07-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	* c-decl.c (duplicate_decls): Do not call make_var_volatile() in
+	case of invalid volatile re-declaration.
+
+2000-08-14  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in (ia64-*): Set float_format for i386 long double.
+
+	* real.c (GET_REAL): Treat 128-bit INTEL_EXTENDED_IEEE_FORMAT
+	as we would for i386 XFmode.
+	(PUT_REAL): Likewise.
+	(endian, ereal_atof, real_value_truncate): Likewise.
+	(ereal_isneg, toe64, etens, make_nan): Likewise.
+	* real.h (REAL_VALUE_TO_TARGET_LONG_DOUBLE): Likewise.
+
+	* config/ia64/ia64-protos.h: Update.
+	* config/ia64/ia64.c (general_tfmode_operand): New.
+	(destination_tfmode_operand): New.
+	(tfreg_or_fp01_operand): New.
+	(ia64_split_timode): New.
+	(spill_tfmode_operand): New.
+	(ia64_expand_prologue): Use TFmode not XFmode.
+	(ia64_expand_epilogue): Likewise.
+	(ia64_function_arg): Likewise.
+	(ia64_function_arg_advance): Likewise.
+	(ia64_return_in_memory): Likewise.
+	(ia64_function_value): Likewise.
+	(ia64_print_operand): Likewise.
+	(ia64_register_move_cost): Set GR<->FR to 5.
+	(ia64_secondary_reload_class): Get GR for TImode memory op.
+	* config/ia64/ia64.h (ROUND_TYPE_SIZE): Remove.
+	(ROUND_TYPE_ALIGN): Remove.
+	(LONG_DOUBLE_TYPE_SIZE): Set to 128.
+	(INTEL_EXTENDED_IEEE_FORMAT): Define.
+	(HARD_REGNO_NREGS): Use TFmode, not XFmode.
+	(HARD_REGNO_MODE_OK): Likewise.  Disallow TImode in FRs.
+	(MODES_TIEABLE_P): Use TFmode, not XFmode.
+	(CLASS_MAX_NREGS): Likewise.
+	(ASM_OUTPUT_LONG_DOUBLE): Output by 4 byte hunks.
+	(PREDICATE_CODES): Update.
+	* config/ia64/ia64.md (movti): New.
+	(movti_internal): Use a clobber for memory alternatives.
+	(reload_inti, reload_outti): New.
+	(movsfcc_astep): Predicate properly.
+	(movdfcc_astep): Likewise.
+	(movxf): Remove.
+	(movtf): New.
+	(extendsftf2, extenddftf2): New.
+	(trunctfsf2, trunctfdf2): New.
+	(floatditf2, fix_trunctfdi2): New.
+	(floatunsditf2, fixuns_trunctfdi2): New.
+	(addtf3, subtf3, multf3, abstf2): New.
+	(negtf2, nabstf2, mintf3, maxtf3): New.
+	(maddtf3, msubtf3, nmultf3, nmaddtf3): New.
+	(cmptf): New.
+	(fr_spill): Use TFmode, not XFmode.
+	(fr_restore): Likewise.
+	* config/ia64/lib1funcs.asm (__divtf3): New.
+	* config/ia64/t-ia64 (LIB1ASMFUNCS): Add it.
+
+2000-08-14  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (ASM_SPEC): Pass -mconstant-gp and -mauto-pic
+	to GNU as.  For Intel as, pass -M const_gp and -M no_plabel.
+	* config/ia64/linux.h (ASM_SPEC): Pass -mconstant-gp and -mauto-pic
+	to GNU as.
+
+2000-08-14  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.md (movdi): Delay calling ia64_expand_load_address.
+	(movdi_symbolic): New.
+
+2000-08-14  Richard Henderson  <rth@cygnus.com>
+
+	* expr.c (emit_group_load): Don't force constants into registers.
+	Special case source already in the correct mode.
+
+2000-08-12  Richard Henderson  <rth@cygnus.com>
+
+	* sibcall.c (uses_addressof): Accept both addressof and
+	current_function_internal_arg_pointer inside a mem.
+	(optimize_sibling_and_tail_recursive_call): Fail tail recursion
+	if current_function_uses_addressof.
+	* stmt.c (expand_return): Kill tail recursion and HAVE_return
+	optimizations.
+
+2000-08-11  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.md (addsi3): Remove expander.
+	(subsi3, mulsi3, negsi2, one_cmplsi2): Likewise.
+	(*addsi3_shladd): New.
+
+2000-08-11  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.c (do_spill): Pass cfa offset to move expander.
+	(do_restore): Likewise.
+	(gen_movdi_x, gen_fr_spill_x, gen_fr_restore_x): New.
+	(ia64_expand_prologue, ia64_expand_epilogue): Use them.
+	(rtx_needs_barrier): Track actual bit manipulation for
+	ar.unat moves, gr_spill, and gr_restore.
+	(emit_insn_group_barriers): Special case gr_spill/gr_restore.
+	(process_set): Don't handle varargs spills.
+	* config/ia64/ia64.md (gr_spill): Accept cfa offset.  Emit
+	.mem.offset here instead of in process_set.
+	(gr_restore): Likewise.
+
+2000-08-11  Richard Henderson  <rth@cygnus.com>
+
+	* reload.c (push_secondary_reload): When invoking a reload_{in,out}
+	pattern, always allocate a tertiary scratch register.
+
+2000-08-11  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.h (PROMOTE_MODE): Only extend to SImode.
+
+2000-08-11  Richard Henderson  <rth@cygnus.com>
+
+	* function.c (put_reg_into_stack): Allow type to be NULL.
+	(schedule_fixup_var_refs): Likewise.
+	(gen_mem_addressof): Allow decl to be NULL.
+	(put_addressof_into_stack): Likewise.
+
+	* flow.c (merge_blocks_nomove): Be more careful about
+	locating the beginning of block A.
+
+2000-08-08  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64-protos.h: Remove duplicates.  Update
+	for massive code rearrangements.
+	* config/ia64/ia64.c (ia64_arpfs_regno): Remove.
+	(ia64_rp_regno, ia64_fp_regno, ia64_input_regs): Remove.
+	(ia64_local_regs, ia64_need_regstk): Remove.
+	(ar_ccv_reg_operand): New.
+	(ia64_gp_save_reg): New.
+	(struct ia64_frame_info): Combine most of the size elements;
+	add new gr save elements.
+	(find_gr_spill): New.
+	(next_scratch_gr_reg): New.
+	(mark_reg_gr_used_mask): New.
+	(ia64_compute_frame_size): Rewrite.  Allocate special AR regs
+	to GR backing store regs when possible.
+	(ia64_initial_elimination_offset): New.
+	(ia64_rap_fp_offset): Remove.
+	(save_restore_insns): Remove.
+	(setup_spill_pointers): New.
+	(finish_spill_pointers): New.
+	(spill_restore_mem): New.
+	(do_spill, do_restore): New.
+	(ia64_expand_prologue): Rewrite to use them.
+	(ia64_expand_epilogue): Likewise.
+	(ia64_direct_return): Update for current_frame_info changes.
+	(ia64_function_prologue): Simplify .prologue emission.  Emit
+	.spill when needed.
+	(ia64_setup_incoming_varargs): Don't ever emit rtl.
+	(ia64_dbx_register_number): New.
+	(ia64_initialize_trampoline): New.
+	(ia64_secondary_reload_class): Request GR_REGS for integer
+	arithmetic destined for FR_REGS.
+	(ia64_init_machine_status): Don't reset return_address_pointer_rtx.
+	(ia64_mark_machine_status): Mark ia64_gp_save.
+	(rws_access_regno): Rename from rws_access_reg; don't treat
+	predicates specially.
+	(rws_access_reg): New.  Update all callers.
+	(rtx_needs_barrier): Remove dead unspecs.
+	(ia64_epilogue_uses): Mark ar.pfs and ar.unat live on exit.
+	(ia64_encode_section_info): Silence signed/unsigned warnings.
+	(spill_offset, sp_offset, spill_offset_emitted): Remove.
+	(tmp_reg, tmp_saved): Remove.
+	(process_set): Rewrite to expect complicated bits via 
+	REG_FRAME_RELATED_EXPR.
+	(ia64_expand_fetch_and_op): Use emit_move_insn; be explicit
+	in the use of ar.ccv; never set RTX_UNCHANGING_P.
+	(ia64_expand_op_and_fetch): Likewise.
+	(ia64_expand_compare_and_swap): Likewise.
+	(ia64_expand_builtin): Likewise.
+	* config/ia64/ia64.h (AR_UNAT_REGNUM): New.
+	(FIRST_PSEUDO_REGISTER): Update.
+	(AR_M_REGNO_P): Update.
+	(FIXED_REGS): Don't mark three local registers as used.
+	(EXTRA_CC_MODES): New.
+	(SELECT_CC_MODE): New.
+	(HARD_REGNO_NREGS): Allow DImode in p0; handle CCImode.
+	(HARD_REGNO_MODE_OK): Disallow CCImode from non-predicates.
+	(FRAME_GROWS_DOWNWARD): Unset.
+	(STARTING_FRAME_OFFSET): Zero.
+	(ELIMINABLE_REGS): Eliminate from the soft to hard frame pointer.
+	(INITIAL_ELIMINATION_OFFSET): Defer to out of line function.
+	(HARD_FRAME_POINTER_REGNUM): New.
+	(CAN_DEBUG_WITHOUT_FP): Define.
+	(TRAMPOLINE_TEMPLATE): Remove.
+	(TRAMPOLINE_SIZE): Lower to 32.
+	(TRAMPOLINE_ALIGNMENT): Lower to 64.
+	(INITIALIZE_TRAMPOLINE): Defer to out of line function.
+	(PREDICATE_CODES): Update.
+	(struct machine_function): Add ia64_gp_save.
+	* config/ia64/ia64.md: Purge unused unspecs.
+	(movsi patterns): Allow moves to/from AR_M_REGS.
+	(movdi patterns): Allow moves to/from p0.
+	(call patterns): Move most setjmp hackery to ia64_gp_save_reg.
+	(gr_spill, gr_restore): Indicate ar.unat read/written.
+	(nonlocal_goto): Don't pass old frame_pointer.
+	(nonlocal_goto_receiver): Remove.
+	(exception_receiver): New.
+	(builtin_setjmp_setup): New.
+	(builtin_setjmp_receiver): New.
+	* config/ia64/lib1funcs.asm (__ia64_save_stack_nonlocal): Bundle.
+	(__ia64_nonlocal_goto): Bundle.  Don't kill r7.
+	(__ia64_restore_stack_nonlocal): Likewise.
+	(__ia64_trampoline): New.
+	* config/ia64/sysv4.h (DBX_REGISTER_NUMBER): Defer to out of line
+	function.
+	* config/ia64/t-ia64 (LIB1ASMFUNCS): Add __trampoline.
+
+2000-08-08  Richard Henderson  <rth@cygnus.com>
+
+	* frame.h (ia64_frame_state): Add my_psp.
+	* libgcc2.c (ia64_throw_helper): Add throw_sp argument.
+	(__throw): Pass it in.  Don't clobber r7.
+	* config/ia64/frame-ia64.c (init_ia64_reg_loc): Mark inline.
+	(execute_one_ia64_descriptor) [mem_stack_v]: Sets psp.when
+	and nothing to do with sp.
+	(normalize_reg_loc): Use frame->my_psp.
+	(frame_translate): Handle frame-pointer-less functions.  Set
+	spill_base correctly, in absence of being told.
+	(__build_ia64_frame_state): New sp argument.  Fill in frame->my_sp.
+	(__ia64_backtrace_helper): New sp argument.  Use
+	builtin_return_address instead of label addresses.
+	(print_record) [mem_stack_v]: No size member.
+
+2000-08-08  Richard Henderson  <rth@cygnus.com>
+
+	* regclass.c (choose_hard_reg_mode): Iterate over all CC modes.
+
+2000-08-08  Richard Henderson  <rth@cygnus.com>
+
+	* tm.texi (LOCAL_REGNO): Document.
+	* flow.c (LOCAL_REGNO, EPILOGUE_USES): Provide default.
+	(mark_regs_live_at_end): Don't mark LOCAL_REGNO registers.
+	* reload1.c (reload): Likewise when considering nonlocal labels.
+
+	* config/ia64/ia64.h (LOCAL_REGNO): New.
+	* config/sparc/sparc.h (LOCAL_REGNO): New.
+
+2000-08-07  Richard Henderson  <rth@cygnus.com>
+
+	* expmed.c (store_bit_field): Don't require MEM_IN_STRUCT_P.
+	* expr.c (emit_group_store): Don't set it.
+
+2000-08-06  Richard Henderson  <rth@cygnus.com>
+
+	* stmt.c (expand_goto): Do virtual_stack_vars_rtx replacement for
+	HAVE_nonlocal_goto as well.
+
+2000-08-02  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64-protos.h (flag_ssa): Declare.
+	* config/ia64/ia64.md (movti_internal, movti_internal+1): New.
+
+2000-08-01  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_function_arg): Fix last change.  Verify
+	type exists before using it.  Use number of words as alignment
+	otherwise.
+	(ia64_function_arg_partial_nregs, ia64_function_arg_advance,
+	ia64_va_arg): Propagate ia64_function_args changes here.
+
+2000-08-01  Richard Henderson  <rth@cygnus.com>
+
+	* config/elfos.h (ASM_DECLARE_OBJECT_NAME): Care for null DECL.
+	* config/ia64/sysv4.h (ASM_OUTPUT_ALIGNED_DECL_LOCAL): Likewise.
+
+2000-07-31  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_function_arg): Use alignment not size
+	when computing offset.
+
+2000-07-30  Anthony Green  <green@redhat.com>
+
+	* config/ia64/crtbegin.asm (__EH_FRAME_BEGIN__): Align correctly.
+
+2000-07-30  Michael Hayes  <mhayes@cygnus.com>
+	    Richard Henderson  <rth@cygnus.com>
+
+	* Makefile.in (OBJS): Add doloop.o.
+	* doloop.c: New file.
+
+	* final.c (insn_current_reference_address): Return 0 before final.
+	* flags.h (flag_branch_on_count_reg): Fix typos in commentary.
+	* jump.c (any_uncondjump_p): Likewise.
+	* loop.c (indirect_jump_in_function): Make static.
+	(strength_reduce): Call doloop_optimize.
+	(insert_bct, instrument_loop_bct): Remove.
+	* loop.h (doloop_optimize): Prototype.
+	* recog.c (split_all_insns): Split all INSN_P.
+	* toplev.c (flag_branch_on_count_reg): Default on.
+
+	* config/c4x/c4x.c (c4x_optimization_options): Don't set
+	flag_branch_on_count_reg.
+	* config/i386/i386.c (override_options): Likewise.
+	* config/rs6000/rs6000.c (optimization_options): Likewise.
+
+	* config/i386/i386.md (decrement_and_branch_on_count): Remove.
+	(doloop_end): New.
+	(dbra_ge): Remove, as well as all it's splitters.
+
+	* config/rs6000/rs6000.md (decrement_and_branch_on_count): Remove.
+	(doloop_end): New.
+
+	* config/ia64/ia64-protos.h (ar_lc_reg_operand): Declare.
+	(ia64_register_move_cost): Declare.
+	* config/ia64/ia64.c (ar_lc_reg_operand): New.
+	(struct ia64_frame_info): Add ar_size.
+	(ia64_compute_frame_size): Set it.
+	(save_restore_insns): Save and restore ar.lc.
+	(ia64_register_move_cost): New, moved from header file.  Handle
+	application registers.
+	(REG_AR_PFS, REG_AR_EC): Remove.  Replace with AR_*_REGNUM numbers.
+	(emit_insn_group_barriers): Special case doloop_end_internal.
+	(ia64_epilogue_uses): Mark ar.lc live at end.
+	* config/ia64/ia64.h (AR_CCV_REGNUM, AR_LC_REGNUM): New registers.
+	(AR_EC_REGNUM, AR_PFS_REGNUM): New registers.
+	(FIRST_PSEUDO_REGISTER): Make room.
+	(AR_M_REGNO_P, AR_I_REGNO_P, AR_REGNO_P): New.
+	(FIXED_REGISTERS, CALL_USED_REGISTERS): Update.
+	(REG_ALLOC_ORDER): Update.
+	(HARD_REGNO_MODE_OK): Update.
+	(REGISTER_NAMES): Update.
+	(enum reg_class): Add AR_M_REGS and AR_I_REGS.
+	(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update.
+	(REGNO_REG_CLASS): Update.
+	(LEGITIMATE_ADDRESS_DISP): Displacement range is 9 bits, not 10.
+	(REGISTER_MOVE_COST): Move out of line.
+	(PREDICATE_CODES): Update.
+	* config/ia64/ia64.md (movdi patterns): Handle ar register classes.
+	(addsi3_plus1_alt, adddi3_plus1_alt): New.
+	(shladd_elim splitter): Allow constants in the predicate.
+	(doloop_end, doloop_end_internal): New.
+
+2000-07-30  Richard Henderson  <rth@cygnus.com>
+
+	* flow.c (init_propagate_block_info): Use pc_set.
+
+2000-07-28  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_print_operand): Fix typos.
+	Sign extend mode size before negating.
+
+2000-07-28  Bernd Schmidt  <bernds@cygnus.co.uk>
+
+	* cse.c (canon_hash): Handle PRE_MODIFY/POST_MODIFY.
+	(cse_insn): Likewise.
+	(addr_affects_sp_p): Likewise.
+	* expr.c (move_by_pieces): Likewise.
+	(clear_by_pieces): Likewise.
+	* gcse.c (oprs_unchanged_p): Likewise.
+	* haifa-sched.c (sched_analyze_2): Likewise.
+	* recog.c (offsettable_address_p): Likewise.
+	* regclass.c (record_address_regs): Likewise.
+	* reload.c (find_reusable_reload): Likewise.
+	(push_reload): Likewise.
+	(operands_match_p): Likewise.
+	(decompose): Likewise.
+	(find_reloads_address_1): Likewise.
+	(find_inc_amount): Likewise.
+	* reload1.c (elimination_effects): Likewise.
+	* resource.c (mark_set_resources): Likewise.
+	* flow.c (attempt_auto_inc): New function; mostly broken out
+	of find_auto_inc.
+	(find_auto_inc): Split into two functions and enhanced to
+	generate POST_MODIFY.
+	* rtl.def (PRE_MODIFY, POST_MODIFY): Adjust comment.
+	* rtl.h (count_all_occurrences):  Declare.
+	(HAVE_{PRE,POST}_MODIFY_{DISP,REG}): Provide default of 0 if not
+	defined.
+	* rtlanal.c (count_all_occurrences): New function.
+	* tm.texi (HAVE_POST_MODIFY_DISP, HAVE_PRE_MODIFY_DISP,
+	HAVE_POST_MODIFY_REG, HAVE_PRE_MODIFY_REG): Document.
+
+	* config/ia64/ia64-protos.h (destination_operand): Declare.
+	* config/ia64/ia64.c (destination_operand): New function.
+	(ia64_print_operand): Handle POST_MODIFY.
+	(rtx_needs_barrier): Likewise.
+	* config/ia64/ia64.h (HAVE_POST_MODIFY_DISP): Define to 1.
+	(HAVE_POST_MODIFY_REG): Define to 1.
+	(MAX_REGS_PER_ADDRESS): Change to 2.
+	(GO_IF_LEGITIMATE_ADDRESS): Accept POST_MODIFY too.
+	(LEGITIMATE_ADDRESS_REG): New helper macro.
+	(LEGITIMATE_ADDRESS_DISP): Likewise.
+	(PREDICATE_CODES): Add entry for destination_operand.
+	* config/ia64/ia64.md (all mov patterns): Use destination_operand
+	predicate for operand 0.
+
+2000-07-27  Jim Wilson  <wilson@cygnus.com>
+
+	* dwarf2out.c (gen_decl_die): Don't call gen_abstract_function if
+	DECL_INITIAL (decl) == NULL_TREE.
+
+2000-07-27  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.md (movqicc_astep, movqi_internal_astep): New.
+	(movhicc_astep, movhi_internal_astep): New.
+	(movsicc_astep, movsi_internal_astep): New.
+	(movdicc_astep, movdi_internal_astep): New.
+	(movsfcc_astep, movsf_internal_astep): New.
+	(movdfcc_astep, movdf_internal_astep): New.
+	(movxfcc_astep, movxf_internal_astep): New.
+	(cmovdi_internal_astep, cmovsi_internal_astep): New.
+	Unify the cmov[ds]i splitters.
+
+2000-07-24  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.c (ia64_print_operand): Handle "%,".
+	* config/ia64/ia64.h (PRINT_OPERAND_PUNCT_VALID_P): Likewise.
+	* config/ia64/ia64.md (movdi_internal): Use it.
+
+2000-07-20  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (ASM_OUTPUT_MI_THUNK): Handle DELTA values
+	larger than 14 bits.
+
+2000-07-19  Jim Wilson  <wilson@cygnus.com>
+
+	* config/ia64/ia64.h (HARD_REGNO_MODE_OK): Don't allow XFmode in
+	GR_REGS.
+
+2000-07-17  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64.md (movdi): Split out load address code.
+	New post-reload splitter for symbolic operands.
+	(movdi_internal): Abort if we didn't split symbolic operands
+	when we should have.
+	* config/ia64/ia64.c (ia64_expand_load_address): New, from movdi bits.
+	(ia64_reorg): Split insns when not optimizing.
+	* config/ia64/ia64-protos.h (ia64_expand_load_address): Declare.
+
+2000-07-15  Richard Henderson  <rth@cygnus.com>
+
+	* config/ia64/ia64-protos.h (ia64_move_ok): Prototype.
+	* config/ia64/ia64.c (ia64_move_ok): New function.
+	* config/ia64/ia64.md (movqi, movqi_internal): Use it.
+	(movhi, movsi, movdi, movsf, movdf, movxf): Likewise.
+
--- gcc/dwarf2out.c.jj	Sat Feb  3 23:48:01 2001
+++ gcc/dwarf2out.c	Mon Feb  5 15:10:33 2001
@@ -9934,7 +9934,7 @@ dwarf2out_begin_block (blocknum)
      register unsigned blocknum;
 {
   function_section (current_function_decl);
-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);
+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);
 }
 
 /* Output a marker (i.e. a label) for the end of the generated code for a
@@ -9945,7 +9945,7 @@ dwarf2out_end_block (blocknum)
      register unsigned blocknum;
 {
   function_section (current_function_decl);
-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BLOCK_END_LABEL, blocknum);
+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, BLOCK_END_LABEL, blocknum);
 }
 
 /* Returns nonzero if it is appropriate not to emit any debugging
@@ -9980,7 +9980,7 @@ dwarf2out_label (insn)
     {
       function_section (current_function_decl);
       sprintf (label, INSN_LABEL_FMT, current_funcdef_number);
-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, label,
+      ASM_OUTPUT_DEBUG_LABEL (asm_out_file, label,
 				 (unsigned) INSN_UID (insn));
     }
 }
--- gcc/configure.in.jj	Sat Feb  3 23:47:51 2001
+++ gcc/configure.in	Tue Feb  6 00:16:07 2001
@@ -2026,6 +2026,7 @@ changequote([,])dnl
 		then
 			target_cpu_default="${target_cpu_default}|MASK_GNU_LD"
 		fi
+		float_format=i386
 		;;
 	ia64*-*-linux*)
 		tm_file=ia64/linux.h
@@ -2034,6 +2035,7 @@ changequote([,])dnl
  		if test x$enable_threads = xyes; then
  			thread_file='posix'
  		fi
+		float_format=i386
 		;;
 	m32r-*-elf*)
 		extra_parts="crtinit.o crtfini.o"
--- gcc/configure.jj	Sat Feb  3 23:47:51 2001
+++ gcc/configure	Tue Feb  6 00:16:52 2001
@@ -4995,6 +4995,7 @@ for machine in $build $host $target; do
 		then
 			target_cpu_default="${target_cpu_default}|MASK_GNU_LD"
 		fi
+		float_format=i386
 		;;
 	ia64*-*-linux*)
 		tm_file=ia64/linux.h
@@ -5003,6 +5004,7 @@ for machine in $build $host $target; do
  		if test x$enable_threads = xyes; then
  			thread_file='posix'
  		fi
+		float_format=i386
 		;;
 	m32r-*-elf*)
 		extra_parts="crtinit.o crtfini.o"
--- gcc/real.c.jj	Thu Jul 27 19:46:44 2000
+++ gcc/real.c	Tue Feb  6 14:18:20 2001
@@ -95,7 +95,9 @@ netlib.att.com: netlib/cephes.   */
 
    The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support
    and may deactivate XFmode since `long double' is used to refer
-   to both modes.
+   to both modes.  Defining INTEL_EXTENDED_IEEE_FORMAT at the same 
+   time enables 80387-style 80-bit floats in a 128-bit padded
+   image, as seen on IA-64.
 
    The macros FLOAT_WORDS_BIG_ENDIAN, HOST_FLOAT_WORDS_BIG_ENDIAN,
    contributed by Richard Earnshaw <Richard.Earnshaw@cl.cam.ac.uk>,
@@ -244,30 +246,31 @@ unknown arithmetic type
    A REAL_VALUE_TYPE is guaranteed to occupy contiguous locations
    in memory, with no holes.  */
 
-#if MAX_LONG_DOUBLE_TYPE_SIZE == 96
+#if MAX_LONG_DOUBLE_TYPE_SIZE == 96 || \
+    (defined(INTEL_EXTENDED_IEEE_FORMAT) && MAX_LONG_DOUBLE_TYPE_SIZE == 128)
 /* Number of 16 bit words in external e type format */
-#define NE 6
-#define MAXDECEXP 4932
-#define MINDECEXP -4956
-#define GET_REAL(r,e) bcopy ((char *) r, (char *) e, 2*NE)
-#define PUT_REAL(e,r)				\
-do {						\
-  if (2*NE < sizeof(*r))			\
-    bzero((char *)r, sizeof(*r));		\
-  bcopy ((char *) e, (char *) r, 2*NE);		\
-} while (0)
-#else /* no XFmode */
-#if MAX_LONG_DOUBLE_TYPE_SIZE == 128
-#define NE 10
-#define MAXDECEXP 4932
-#define MINDECEXP -4977
-#define GET_REAL(r,e) bcopy ((char *) r, (char *) e, 2*NE)
-#define PUT_REAL(e,r)				\
-do {						\
-  if (2*NE < sizeof(*r))			\
-    bzero((char *)r, sizeof(*r));		\
-  bcopy ((char *) e, (char *) r, 2*NE);		\
-} while (0)
+# define NE 6
+# define MAXDECEXP 4932
+# define MINDECEXP -4956
+# define GET_REAL(r,e)  memcpy ((char *)(e), (char *)(r), 2*NE)
+# define PUT_REAL(e,r)						\
+	do {							\
+	  memcpy ((char *)(r), (char *)(e), 2*NE);		\
+	  if (2*NE < sizeof(*r))				\
+	    memset ((char *)(r) + 2*NE, 0, sizeof(*r) - 2*NE);	\
+	} while (0)
+# else /* no XFmode */
+#  if MAX_LONG_DOUBLE_TYPE_SIZE == 128
+#   define NE 10
+#   define MAXDECEXP 4932
+#   define MINDECEXP -4977
+#   define GET_REAL(r,e) memcpy ((char *)(e), (char *)(r), 2*NE)
+#   define PUT_REAL(e,r)					\
+	do {							\
+	  memcpy ((char *)(r), (char *)(e), 2*NE);		\
+	  if (2*NE < sizeof(*r))				\
+	    memset ((char *)(r) + 2*NE, 0, sizeof(*r) - 2*NE);	\
+	} while (0)
 #else
 #define NE 6
 #define MAXDECEXP 4932
@@ -497,11 +500,13 @@ endian (e, x, mode)
       switch (mode)
 	{
 	case TFmode:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
 	  /* Swap halfwords in the fourth long.  */
 	  th = (unsigned long) e[6] & 0xffff;
 	  t = (unsigned long) e[7] & 0xffff;
 	  t |= th << 16;
 	  x[3] = (long) t;
+#endif
 
 	case XFmode:
 	  /* Swap halfwords in the third long.  */
@@ -539,11 +544,13 @@ endian (e, x, mode)
       switch (mode)
 	{
 	case TFmode:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
 	  /* Pack the fourth long.  */
 	  th = (unsigned long) e[7] & 0xffff;
 	  t = (unsigned long) e[6] & 0xffff;
 	  t |= th << 16;
 	  x[3] = (long) t;
+#endif
 
 	case XFmode:
 	  /* Pack the third long.
@@ -737,15 +744,18 @@ ereal_atof (s, t)
       e53toe (tem, e);
       break;
 
-    case XFmode:
-      asctoe64 (s, tem);
-      e64toe (tem, e);
-      break;
-
     case TFmode:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
       asctoe113 (s, tem);
       e113toe (tem, e);
       break;
+#endif
+      /* FALLTHRU */
+
+    case XFmode:
+      asctoe64 (s, tem);
+      e64toe (tem, e);
+      break;
 
     default:
       asctoe (s, e);
@@ -872,8 +882,13 @@ ereal_from_int (d, i, j, mode)
       break;
 
     case 128:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
       etoe113 (dg, df);
       e113toe (df, dg);
+#else
+      etoe64 (dg, df);
+      e64toe (df, dg);
+#endif
       break;
 
     default:
@@ -926,8 +941,13 @@ ereal_from_uint (d, i, j, mode)
       break;
 
     case 128:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
       etoe113 (dg, df);
       e113toe (df, dg);
+#else
+      etoe64 (dg, df);
+      e64toe (df, dg);
+#endif
       break;
 
     default:
@@ -1070,9 +1090,12 @@ real_value_truncate (mode, arg)
   switch (mode)
     {
     case TFmode:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
       etoe113 (e, t);
       e113toe (t, t);
       break;
+#endif
+      /* FALLTHRU */
 
     case XFmode:
       etoe64 (e, t);
@@ -1486,7 +1509,7 @@ ereal_isneg (x)
 
 /*  e type constants used by high precision check routines */
 
-#if MAX_LONG_DOUBLE_TYPE_SIZE == 128
+#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && !defined(INTEL_EXTENDED_IEEE_FORMAT)
 /* 0.0 */
 unsigned EMUSHORT ezero[NE] =
  {0x0000, 0x0000, 0x0000, 0x0000,
@@ -3653,13 +3676,11 @@ toe64 (a, b)
   else
     {
       q = b + 4;			/* point to output exponent */
-      /* The purpose of this conditional is to avoid scribbling beyond
-         the end of a long double, in case the type is only 80 bits wide.  */
-      if (LONG_DOUBLE_TYPE_SIZE == 96)
-	{
-	  /* Clear the last two bytes of 12-byte Intel format */
-	  *(q+1) = 0;
-	}
+      /* Clear the last two bytes of 12-byte Intel format.  q is pointing
+	 into an array of size 6 (e.g. x[NE]), so the last two bytes are
+	 always there, and there are never more bytes, even when we are using
+	 INTEL_EXTENDED_IEEE_FORMAT.  */
+      *(q+1) = 0;
     }
 #endif
 
@@ -4560,7 +4581,7 @@ enormlz (x)
 #define NTEN 12
 #define MAXP 4096
 
-#if MAX_LONG_DOUBLE_TYPE_SIZE == 128
+#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && !defined(INTEL_EXTENDED_IEEE_FORMAT)
 static unsigned EMUSHORT etens[NTEN + 1][NE] =
 {
   {0x6576, 0x4a92, 0x804a, 0x153f,
@@ -6276,12 +6297,15 @@ make_nan (nan, sign, mode)
    used like NaN's, but probably not in the same way as IEEE.  */
 #if !defined(DEC) && !defined(IBM) && !defined(C4X)
     case TFmode:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
       n = 8;
       if (REAL_WORDS_BIG_ENDIAN)
 	p = TFbignan;
       else
 	p = TFlittlenan;
       break;
+#endif
+      /* FALLTHRU */
 
     case XFmode:
       n = 6;
@@ -6892,8 +6916,13 @@ switch (GET_MODE_BITSIZE (mode))
 
   case 96:
     return 64;
+
   case 128:
+#ifndef INTEL_EXTENDED_IEEE_FORMAT
     return 113;
+#else
+    return 64;
+#endif
 
   default:
     abort ();
--- gcc/real.h.jj	Tue Jul 18 21:15:48 2000
+++ gcc/real.h	Tue Feb  6 14:22:37 2001
@@ -207,11 +207,15 @@ extern REAL_VALUE_TYPE real_value_trunca
   ereal_from_uint (&d, lo, hi, mode)
 
 /* IN is a REAL_VALUE_TYPE.  OUT is an array of longs. */
+#if defined(INTEL_EXTENDED_IEEE_FORMAT) && MAX_LONG_DOUBLE_TYPE_SIZE == 128
+#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT) (etarldouble ((IN), (OUT)))
+#else
 #define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT) 		\
    (LONG_DOUBLE_TYPE_SIZE == 64 ? etardouble ((IN), (OUT))	\
     : LONG_DOUBLE_TYPE_SIZE == 96 ? etarldouble ((IN), (OUT))	\
     : LONG_DOUBLE_TYPE_SIZE == 128 ? etartdouble ((IN), (OUT))  \
     : abort())
+#endif
 #define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT) (etardouble ((IN), (OUT)))
 
 /* IN is a REAL_VALUE_TYPE.  OUT is a long. */
